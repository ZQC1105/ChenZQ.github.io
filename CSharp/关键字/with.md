## [表达式 with - 非破坏性突变创建具有修改属性的新对象](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/with-expression)

你贴出的示例已经把“**with 表达式保持运行时类型**”这一核心规则演示得很清楚了——  
无论左侧变量是**什么静态类型**，`with` 都会**拷贝实际对象的运行时类型**，再按对象初始值设定符里的名单改写属性，然后**原样返回那个运行时类型的新实例**。

一句话记忆：  
“**静态类型只管编译期；with 之后，骨子里（运行时）还是原来的那个‘种’。**”

------------------------------------------------
把示例拆开再看一眼：

```csharp
Point p1 = new NamedPoint("A", 0, 0);   // 静态类型 Point，运行时类型 NamedPoint
Point p2 = p1 with { X = 5, Y = 3 };    // with 克隆的是 NamedPoint
Console.WriteLine(p2 is NamedPoint);    // True
Console.WriteLine(p2);                  // NamedPoint { X = 5, Y = 3, Name = A }
```

------------------------------------------------
规则小结（官方一句话版）

1. 左侧操作数可以是  
   - 任何 `record`（class 或 struct）  
   - 任何 `struct`（含元组）  
   - 匿名类型  

2. 返回的新实例  
   - **运行时类型** ≡ 左侧操作数的**实际运行时类型**（不会向上转成静态类型）。  
   - **静态类型** ≡ 左侧操作数的**声明类型**（编译期推断）。  

3. 赋值过程  
   - 先调用该运行时类型的**受保护拷贝构造函数**。  
   - 再把 `with` 里出现的每个属性按名逐个赋值（init-only 属性也可写，因为仍处于构造期）。  

------------------------------------------------
边缘情况速记

- 如果将来在派生层里新增属性，而 `with` 里写了新增属性，但左侧实际对象是基类实例，会**编译失败**（CS8857：找不到该成员）。  
- 结构体（`record struct` 或普通 `struct`）同样遵守“保持运行时类型”规则，不过值类型没有继承层次，所以运行时类型就是本身。
`p1` **丝毫没变**。

`with` 表达式做的是**不可变快照**：

1. 先克隆出一份 **新实例**（运行时类型与 `p1` 相同，即 `NamedPoint`）。  
2. 把克隆体的 `X`、`Y` 改成 5、3。  
3. 返回这份克隆体并赋给 `p2`。

原对象 `p1` 的所有字段/属性仍然是  
`Name = "A", X = 0, Y = 0`，内存地址、哈希值、只读状态统统保持不变。

一句话：  
“**with 是‘复制-改-返回新’，绝非‘就地改’**；  
在 `record` 的世界里，旧值永远冻住。”