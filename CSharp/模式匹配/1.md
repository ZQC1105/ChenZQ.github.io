## [模式匹配](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/patterns)

C# 模式匹配（Pattern Matching）从 C# 7 开始引入，经过 8、9、10、11 五个版本的迭代，已经发展成**一套独立的“子语言”**，几乎可以在任何需要“判断 + 提取”的场景里替代传统的 `if/else + 强制转换 + 声明临时变量` 三连击。

下面给一份“一页式全景图”：  
先列语法，再给使用场景，最后写性能/陷阱速查。

------------------------------------------------
一、语法总览（按出现时间排序）

| 名称         | 示例                        | 最低版本 |
| ------------ | --------------------------- | -------- |
| 1. 常量模式  | `x is 42`                   | C# 7     |
| 2. 类型模式  | `x is string s`             | C# 7     |
| 3. var 模式  | `x is var v`                | C# 7     |
| 4. 弃元模式  | `x is _`                    | C# 7     |
| 5. 元组解构  | `(x, y) is (0, 0)`          | C# 7     |
| 6. 属性模式  | `p is { X: 0, Y: > 0 }`     | C# 8     |
| 7. 位置模式  | `p is (0, 0)`               | C# 8     |
| 8. 关系模式  | `x is > 0 and < 100`        | C# 9     |
| 9. 逻辑模式  | `x is 1 or 2 or > 90`       | C# 9     |
| 10. 否定模式 | `x is not null`             | C# 9     |
| 11. 切片模式 | `int[] { 1, .., 5 }`        | C# 11    |
| 12. 列表模式 | `int[] [1, 2, .. var rest]` | C# 11    |

------------------------------------------------
二、实战场景地图

1. 告别“先 is 再 as”  
   ```csharp
   // 老写法
   if (obj is string && ((string)obj).Length > 0) …

   // 模式匹配
   if (obj is string { Length: > 0 } s) …
   ```

2. switch 表达式（C# 8）——“返回值”写法  
   ```csharp
   string Describe(int n) => n switch
   {
       0 => "zero",
       > 0 and < 10 => "digit",
       10 or 100 or 1000 => "round",
       _ => "other"
   };
   ```

3. 属性模式做“免拆包”校验  
   ```csharp
   if (response is { StatusCode: 200, Body: { Length: > 0 } }) …
   ```

4. 位置模式 + 元组同时匹配多返回值  
   ```csharp
   (int dx, int dy) delta = (5, 0);
   string dir = delta switch
   {
       (0, 0) => "origin",
       (0, >0) => "north",
       (0, <0) => "south",
       (>0, 0) => "east",
       (<0, 0) => "west",
       _ => "diagonal"
   };
   ```

5. 列表模式（C# 11）一眼看穿数组头尾  
   ```csharp
   int[] nums = { 1, 2, 3, 4, 5 };
   bool ok = nums is [1, 2, .., 4, 5];   // true
   ```

6. 空值合并一步到位  
   ```csharp
   var len = text is not null and var s ? s.Length : -1;
   ```

------------------------------------------------
三、底层实现与性能

- **is 模式** 与 **switch 表达式** 均由编译器生成 **哈希跳转 + 类型测试缓存**，  
  对密集型类型分支比 `if/else` 链更快。  
- 属性/位置模式会尽可能 **复用已生成的 get_ 方法**，不会反射。  
- 列表模式对数组做一次长度检查 + 逐元素比较，**复杂度 O(n)**，无额外分配。  
- 当 switch 表达式覆盖全部可能性时，编译器会提示 **“缺失分支”**（可开启 `TreatWarningsAsErrors` 做 exhaustive check）。

------------------------------------------------
四、常见陷阱速查

| 场景                                    | 结果                                                 |
| --------------------------------------- | ---------------------------------------------------- |
| `x is string s` 后在外部用 `s`          | 编译错误：s 仅作用在模式内部                         |
| 同时写 `case string s:` 和 `case null:` | 顺序无所谓，null 优先                                |
| 在 `==` 重载的类型上用常量模式          | 会调用 **is** 而不是 **==**，小心 NaN、浮点精度      |
| 列表模式对 `List<T>` 使用               | **仅数组、Span、字符串**支持，List 需先 `.ToArray()` |
| 把 mutable 结构体放进属性模式           | 每次 `get` 都会复制，**性能炸弹**                    |

------------------------------------------------
五、记忆口诀

“先判后取，一箭双雕；  
常量类型，属性位置；  
逻辑关系，列表切片；  
switch 表达式，返回值忘 break。”

是的，模式匹配一旦“套娃”过深，就会从 **优雅** 变成 **晦涩**。

------------------------------------------------
一、可读性红线（经验值）

| 嵌套深度 | 例子                                                        | 阅读体验 |
| -------- | ----------------------------------------------------------- | -------- |
| 1 层     | `x is string s`                                             | 一眼懂   |
| 2 层     | `{ Length: > 0 }`                                           | 尚可     |
| 3 层     | `[1, .. { X: 0 }]`                                          | 开始皱眉 |
| 4 层+    | `is [1, .. { Prop: (>0 and <100) or { Inner: not null } }]` | 需要纸笔 |

------------------------------------------------
二、社区公认的“度”

1. 一个 `switch` 表达式里 **不要超过 3-4 个逻辑组合**（`and/or/not`）。  
2. 属性模式 **不要一次性匹配超过 3 个属性**；再多就拆方法或拆记录。  
3. 列表模式只用于 **“头尾固定”** 的短数组；长度未知或结构复杂用循环。  
4. 出现 **重复模式** → 提炼成私有静态方法或本地函数，用 **when 子句** 调用：

```csharp
static bool IsRound(int n) => n is 10 or 100 or 1000;

string Describe(int n) => n switch
{
    var x when IsRound(x) => "round",
    > 0 and < 10 => "digit",
    _ => "other"
};
```

------------------------------------------------
三、快速自查表

| 场景                  | 建议                 |
| --------------------- | -------------------- |
| 模式行宽 > 80 列      | 换行或拆分           |
| 需要注释解释模式      | 直接重构成 `if`/方法 |
| 同一模式出现 2 次     | 抽局部函数           |
| reviewer 要求单步调试 | 模式里别写复杂表达式 |

------------------------------------------------
一句话总结  
“模式匹配是盐，少一点提鲜，一把撒下去就咸得发苦。”