<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title> | CZQDocs </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content=" | CZQDocs ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/ZQC1105/zqc1105.github.io/blob/main/docs/异步/概念.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="CZQDocs">
            CZQDocs
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">

<p><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/asynchronous-programming/">使用 async 和 await 进行异步编程</a>
好的，我们来详细讲解 C# 中的异步编程。这是现代 C# 开发中一个至关重要且强大的特性，它能显著提升应用程序的响应性和可扩展性。</p>
<h2 id="为什么需要异步编程">为什么需要异步编程？</h2>
<p>在传统的同步编程模型中，当一个方法执行一个耗时操作（如文件 I/O、网络请求、数据库查询、调用外部 API 等）时，调用线程会一直阻塞，直到该操作完成。</p>
<p>对于桌面应用 (WPF/WinForms)：如果在 UI 线程上执行耗时的同步操作，整个界面会“冻结”，用户无法进行任何交互，体验极差。
对于 Web 应用 (ASP.NET)：服务器处理每个请求通常使用一个线程。如果线程被阻塞在 I/O 操作上，它就无法处理其他请求，导致服务器资源浪费，吞吐量下降。</p>
<p>异步编程的核心目标就是：在等待耗时操作（尤其是 I/O 操作）完成时，不阻塞当前线程，让线程可以去执行其他任务，从而提高资源利用率和程序响应性。</p>
<h2 id="c-异步编程的核心async-和-await">C# 异步编程的核心：async 和 await</h2>
<p>C# 提供了非常简洁的语法来实现异步编程：async 和 await 关键字。它们是基于 任务 (Task) 模型构建的。</p>
<h3 id="async-关键字">async 关键字</h3>
<p>作用：用于修饰一个方法、lambda 表达式或匿名方法，表明该方法是异步的。
位置：放在返回类型之前。
返回类型：
Task：用于没有返回值的异步方法（类似于 void）。
Task<t>：用于有返回值的异步方法，T 是返回值的类型。
ValueTask / ValueTask<t>：在某些高性能场景下替代 Task，以减少堆分配。
void：仅用于事件处理程序。返回 void 的异步方法很难被调用者跟踪其完成状态和异常，应尽量避免。
注意：async 本身不会使方法异步执行。它只是启用了 await 关键字，并改变了方法的编译方式。 2. await 关键字</t></t></p>
<p>作用：等待一个 Task 或 Task<t> 完成。当遇到 await 时，如果任务尚未完成，控制权会立即返回给调用者，不会阻塞线程。一旦任务完成，方法的执行会从 await 之后的代码恢复。
位置：只能在标记为 async 的方法内部使用。
原理：await 实际上是一个“语法糖”。编译器会将 async 方法转换成一个状态机 (State Machine)。当 await 遇到未完成的任务时，状态机会保存当前的上下文（局部变量、执行位置等），然后注册一个回调（continuation），当任务完成后，这个回调会被调度执行，恢复方法的执行。</t></p>
<h2 id="基本语法示例">基本语法示例</h2>
<pre><code class="lang-csharp">using System;
using System.Net.Http;
using System.Threading.Tasks;

class Program
{
// Main 方法也可以是异步的 (C# 7.1+)
static async Task Main(string[] args)
{
Console.WriteLine(&quot;开始获取网页内容...&quot;);

// 调用异步方法并等待其完成
string content = await GetWebContentAsync(&quot;https://www.example.com&quot;);

Console.WriteLine($&quot;获取到的内容长度: {content.Length}&quot;);
Console.WriteLine(&quot;程序结束。&quot;);
}

// 异步方法：返回 Task&lt;string&gt;
static async Task&lt;string&gt; GetWebContentAsync(string url)
{
// HttpClient 用于发送 HTTP 请求
using var client = new HttpClient();

// await 关键字等待 GetStringAsync 完成
// GetStringAsync 是一个真正的异步 I/O 操作
string content = await client.GetStringAsync(url);

// 当 GetStringAsync 完成后，执行会恢复到这里
return content;
}
}
</code></pre>
<p>执行流程分析：</p>
<ol>
<li>Main 开始执行，打印 &quot;开始获取网页内容...&quot;。</li>
<li>执行 await GetWebContentAsync(...)，进入 GetWebContentAsync 方法。</li>
<li>在 GetWebContentAsync 中，创建 HttpClient。</li>
<li>执行 await client.GetStringAsync(url)。GetStringAsync 发起一个网络请求，并立即返回一个 Task<string>（表示未来的结果）。</string></li>
<li>因为 Task 尚未完成，await 操作导致 GetWebContentAsync 方法的执行被“挂起”，控制权返回给 Main 方法。</li>
<li>关键点：此时，执行 Main 的线程（比如主线程）没有被阻塞！它可以去处理其他事情（在控制台应用中可能只是空闲，但在 UI 或 Web 应用中可以处理其他请求或 UI 事件）。</li>
<li>当网络请求完成，GetStringAsync 返回的 Task 变为“已完成”状态，并携带了网页内容。</li>
<li>系统调度 GetWebContentAsync 方法中 await 之后的代码继续执行（即 return content;）。</li>
<li>GetWebContentAsync 方法返回一个已完成的 Task<string> 给 Main。</string></li>
<li>Main 方法中 await 操作完成，content 变量被赋值，继续执行后续代码。</li>
</ol>
<h2 id="关键概念深入">关键概念深入</h2>
<ol>
<li>线程与异步</li>
</ol>
<p>误解：“异步 = 多线程”。
真相：异步 I/O 操作（如 HttpClient.GetStringAsync, FileStream.ReadAsync）通常不需要额外的线程来等待 I/O 完成。操作系统会处理底层的 I/O 请求，当数据准备好时，通过回调通知 .NET 运行时。.NET 运行时（通过 ThreadPool）负责调度这些回调。
线程池 (ThreadPool)：await 之后的代码（continuation）默认会在 ThreadPool 的某个线程上执行。这可能导致上下文切换。
ConfigureAwait(false)：
在类库中，为了性能和避免死锁，建议在 await 后使用 .ConfigureAwait(false)。
它告诉运行时：后续的 continuation 不需要回到原始的 SynchronizationContext（比如 UI 线程）。
在 UI 应用或 ASP.NET 的请求上下文中，如果不使用 ConfigureAwait(false)，continuation 会尝试回到原始上下文执行，这可能引起死锁（如果同步等待异步方法）。</p>
<pre><code class="lang-csharp">// 在类库中推荐写法
string content = await client.GetStringAsync(url).ConfigureAwait(false); 2. 异常处理

异常在异步方法中通过 Task 的 Exception 属性传播。
使用 try-catch 块包裹 await 表达式，可以捕获异步方法中抛出的异常。

csharp
static async Task&lt;string&gt; GetWebContentAsync(string url)
{
try
{
using var client = new HttpClient();
return await client.GetStringAsync(url);
}
catch (HttpRequestException ex)
{
Console.WriteLine($&quot;HTTP 请求失败: {ex.Message}&quot;);
throw; // 可以选择重新抛出或处理
}
catch (TaskCanceledException ex)
{
Console.WriteLine($&quot;请求超时: {ex.Message}&quot;);
throw;
}
} 3. 并发执行多个异步操作

顺序执行：使用 await 一个接一个地调用。

csharp
var content1 = await GetWebContentAsync(url1);
var content2 = await GetWebContentAsync(url2); // 必须等第一个完成后才开始

并发执行：先启动所有任务，再 await 它们。这样多个 I/O 操作可以同时进行。

csharp
// 启动所有任务 (不等待)
var task1 = GetWebContentAsync(url1);
var task2 = GetWebContentAsync(url2);
var task3 = GetWebContentAsync(url3);

// 等待所有任务完成
var results = await Task.WhenAll(task1, task2, task3);
// results 是一个 string[] 数组

// 或者分别 await
var content1 = await task1;
var content2 = await task2;
var content3 = await task3;

Task.WhenAny：等待第一个完成的任务。

csharp
var task1 = GetWebContentAsync(url1);
var task2 = GetWebContentAsync(url2);

var firstCompletedTask = await Task.WhenAny(task1, task2);
var result = await firstCompletedTask; // 获取第一个完成的任务的结果 4. 取消异步操作 (CancellationToken)

长时间运行的操作应该支持取消。

csharp
static async Task&lt;string&gt; GetWebContentAsync(string url, CancellationToken cancellationToken)
{
using var client = new HttpClient();
// 将 CancellationToken 传递给支持取消的异步方法
var response = await client.GetAsync(url, cancellationToken);
response.EnsureSuccessStatusCode();
var content = await response.Content.ReadAsStringAsync(cancellationToken);
return content;
}

// 调用
var cts = new CancellationTokenSource();
// 可以在某个条件满足时调用 cts.Cancel() 来取消操作
cts.CancelAfter(TimeSpan.FromSeconds(10)); // 10 秒后自动取消

try
{
string content = await GetWebContentAsync(&quot;https://slow-website.com&quot;, cts.Token);
}
catch (OperationCanceledException)
{
Console.WriteLine(&quot;操作被取消。&quot;);
}
</code></pre>
<h2 id="最佳实践与注意事项">最佳实践与注意事项</h2>
<ol>
<li>避免 async void：除非是事件处理程序，否则始终返回 Task 或 Task<t>。async void 无法被 await，异常处理困难。</t></li>
<li>不要阻塞异步代码：避免在异步方法中使用 .Result 或 .Wait()。这极易导致死锁，尤其是在有 SynchronizationContext 的环境中（如 UI 或 ASP.NET）。
错误做法：
<pre><code class="lang-csharp">public string GetData()
{
return GetWebContentAsync(&quot;...&quot;).Result; // 危险！可能导致死锁
}
</code></pre>
</li>
<li>使用 ConfigureAwait(false)：在编写类库时，为了性能和避免潜在的死锁，await 后应使用 .ConfigureAwait(false)。</li>
<li>正确处理异常：使用 try-catch 包裹 await。</li>
<li>支持取消：为长时间运行的操作提供 CancellationToken 参数。</li>
<li>理解返回类型：明确你的异步方法是返回 Task 还是 Task<t>。</t></li>
<li>并发与并行：Task.WhenAll 实现的是并发（concurrency），多个操作重叠执行，但不一定在多个 CPU 核心上并行（parallelism）运行。真正的并行计算通常使用 Parallel 类或 PLINQ。</li>
</ol>
<h2 id="总结">总结</h2>
<p>C# 的 async/await 提供了一种优雅、高效的方式来处理异步操作，特别是 I/O 密集型任务。它通过释放线程来等待 I/O 完成，极大地提高了应用程序的可伸缩性和响应性。理解其背后的 Task 模型、状态机原理以及 SynchronizationContext 的作用，是避免陷阱（如死锁）和编写高质量异步代码的关键。</p>
<p>掌握异步编程是成为一名合格的现代 C# 开发者的必备技能。</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/ZQC1105/zqc1105.github.io/blob/main/docs/异步/概念.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
