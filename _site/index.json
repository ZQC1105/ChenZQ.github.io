{
  "docs/ASP-NET-Core/FromBody.html": {
    "href": "docs/ASP-NET-Core/FromBody.html",
    "title": "[FromBody] | CZQDocs",
    "summary": "[FromBody] 模型绑定的 推理规则（Inference Rules） 和 使用限制，这是开发者在设计 Web API 时非常容易踩坑的地方。 下面我将为您 详细、清晰地讲解 这些规则背后的原理和实际影响。 \uD83D\uDD0D 背景：什么是 [FromBody]？ [FromBody] 是一个模型绑定特性，用于告诉 ASP.NET Core： “从 HTTP 请求体（Request Body）中读取数据，并反序列化为指定类型。” 通常用于 POST、PUT 请求，传输 JSON 数据。 json { \"name\": \"Laptop\", \"price\": 999 } ⚠️ 核心原则：每个请求体只能读取一次 HTTP 请求体是一个 流（Stream），只能被读取一次。因此，ASP.NET Core 不允许从请求体绑定多个参数，除非你明确指定方式。 \uD83D\uDCDA [FromBody] 的推理规则详解 ASP.NET Core 会尝试“推断”哪些参数应该从请求体绑定，但这种推理有严格规则。 ✅ 规则 1：简单类型不会自动推断为 [FromBody] ❌ 错误示例： [HttpPost] public IActionResult Create([FromBody] int id) // OK { // ... } ❌ 以下写法不会自动推断： csharp [HttpPost] public IActionResult Create(int id) // ❌ id 不会从 Body 绑定！ { // id 值为 0 } \uD83D\uDD39 原因： int、string、bool 等是 简单类型（primitive types） 框架默认从 查询字符串、路由、表单 绑定简单类型 不会自动从请求体读取简单类型 ✅ 正确做法： [HttpPost] public IActionResult Create([FromBody] int id) { // 必须显式使用 [FromBody] } \uD83D\uDCA1 请求示例： http POST /api/values Content-Type: application/json 42 ⚠️ 注意：发送原始值（如 42）需要启用 AllowSynchronousIO 或使用特殊配置，通常不推荐。更常见的是传对象。 ✅ 规则 2：复杂类型（类、记录等）会自动推断为 [FromBody] ✅ 正确示例： public class Product { public string Name { get; set; } } [HttpPost] public IActionResult Create(Product product) // ✅ 自动推断为 [FromBody] { // product 会从 JSON 请求体中绑定 } \uD83D\uDD39 原因： Product 是 复杂类型（POCO） ASP.NET Core 默认推断：复杂类型参数来自请求体 相当于隐式加了 [FromBody] \uD83D\uDCA1 请求示例： http POST /api/products Content-Type: application/json { \"name\": \"Laptop\" } \uD83D\uDEAB 多参数从 Body 绑定的限制 ❌ 问题：一个请求体，不能绑定多个参数 HTTP 请求体只能被读取一次。因此，不能同时从 Body 绑定两个或多个参数。 ❌ 情况 1：两个复杂类型（无 [FromBody]） csharp [HttpPost] public IActionResult Action1(Product product, Order order) \uD83D\uDD34 结果：❌ 异常！ 错误信息： InvalidOperationException: Cannot bind multiple parameters to the request body. ❌ 为什么？ Product 和 Order 都是复杂类型 框架尝试推断两者都来自 [FromBody] 但只能有一个参数来自 Body 冲突，抛出异常 ❌ 情况 2：一个 [FromBody]，一个复杂类型 [HttpPost] public IActionResult Action2(Product product, [FromBody] Order order) \uD83D\uDD34 结果：❌ 异常！ 错误信息： InvalidOperationException: A method cannot have multiple parameters which are bound from the request body. ❌ 为什么？ order 显式标记为 [FromBody] product 是复杂类型 → 自动推断为 [FromBody] 仍然是 两个参数试图从 Body 绑定 冲突，抛出异常 ❌ 情况 3：两个都显式 [FromBody] [HttpPost] public IActionResult Action3([FromBody] Product product, [FromBody] Order order) \uD83D\uDD34 结果：❌ 同样异常！ 即使你写了两个 [FromBody]，框架仍然不允许。 ❌ 为什么？ 语法上看似“明确”，但底层仍然违反“只能读取一次 Body”的规则 ASP.NET Core 在模型绑定阶段就阻止这种设计 ✅ 正确解决方案：使用包装类（Wrapper Class） 如果你想传多个对象，必须将它们封装在一个类中。 ✅ 正确做法： public class CreateRequest { public Product Product { get; set; } public Order Order { get; set; } } [HttpPost] public IActionResult Create([FromBody] CreateRequest request) { var product = request.Product; var order = request.Order; // 处理逻辑 } \uD83D\uDCA1 请求示例： json { \"product\": { \"name\": \"Laptop\" }, \"order\": { \"quantity\": 2 } } ✅ 其他合法组合（混合来源） 你可以从 不同来源 绑定多个参数，只要 只有一个来自 Body。 ✅ 示例 1：Body + Query csharp [HttpPost] public IActionResult Create( [FromBody] Product product, [FromQuery] string source) { // product 来自 Body // source 来自 ?source=web } 请求：POST /api/products?source=web ✅ 示例 2：Body + Route csharp [HttpPost(\"{userId}\")] public IActionResult Create( [FromBody] Product product, [FromRoute] int userId) { // product 来自 Body // userId 来自路径 } 请求：POST /api/products/123 总结表：哪些写法合法？ 方法签名 是否合法 原因 Create(Product p) ✅ 合法 复杂类型自动推断 [FromBody] Create([FromBody] int id) ✅ 合法 简单类型需显式标注 Create(int id) ❌ 无效 简单类型不会自动从 Body 绑定 Create(Product p, Order o) ❌ 异常 两个复杂类型 → 两个推断 [FromBody] Create(Product p, [FromBody] Order o) ❌ 异常 一个推断 + 一个显式 → 仍是两个 Create([FromBody] p, [FromBody] o) ❌ 异常 显式两个也不行 Create([FromBody] Request req) ✅ 合法 只有一个 Body 参数（包装类） \uD83D\uDCDA 微软官方文档参考 模型绑定文档： https://docs.microsoft.com/zh-cn/aspnet/core/mvc/models/model-binding FromBody 文档部分： 搜索 “[FromBody]” 或 “请求体绑定” ✅ 最佳实践建议 简单类型必须显式使用 [FromBody] 避免多个 Body 参数 使用包装类（DTO）封装多个对象 显式标注 [FromBody] 提高可读性（即使复杂类型可推断） csharp [HttpPost] public IActionResult Create([FromBody] Product product) // 推荐显式 { // ... } 总结 ✅ 您的理解完全正确！ 简单类型（如 int、string）不会自动推断为 [FromBody]，必须显式标注。 复杂类型（如 Product）会自动推断为 [FromBody]。 不能有多个参数来自请求体，否则抛出异常。 正确做法：使用 包装类（DTO） 将多个对象合并为一个。 这正是 ASP.NET Core 为了保证性能和一致性所做的设计约束。"
  },
  "docs/ASP-NET-Core/FromForm.html": {
    "href": "docs/ASP-NET-Core/FromForm.html",
    "title": "您提到的“框架默认从 查询字符串、路由、表单 绑定简单类型”中的 “表单”，指的是 HTTP 请求中的 表单数据（Form Data），通常在 POST 或 PUT 请求中通过 HTML 表单或 application/x-www-form-urlencoded 格式提交。 | CZQDocs",
    "summary": "您提到的“框架默认从 查询字符串、路由、表单 绑定简单类型”中的 “表单”，指的是 HTTP 请求中的 表单数据（Form Data），通常在 POST 或 PUT 请求中通过 HTML 表单或 application/x-www-form-urlencoded 格式提交。 下面我将为您 详细讲解 ASP.NET Core 中“表单类型”的绑定机制，包括其格式、使用方式、与模型绑定的关系，以及实际示例。 什么是“表单类型”？ 在 HTTP 请求中，“表单数据”是指以 键值对（key-value pairs） 形式发送的数据，常见于： HTML 提交 使用 POST 方法提交登录、注册等数据 移动端或前端通过 FormData 对象发送数据 常见的表单 Content-Type： 类型 说明 application/x-www-form-urlencoded 默认的表单编码格式，如：name=john&age=25 multipart/form-data 用于上传文件 + 表单数据，如： text/plain 不常用，原始文本 application/json 不是表单格式，是 JSON 格式 ✅ ASP.NET Core 默认从 application/x-www-form-urlencoded 和 multipart/form-data 中绑定表单数据。 \uD83E\uDDE9 模型绑定如何处理“表单”数据？ ASP.NET Core 的模型绑定系统会自动从表单中提取数据，并绑定到控制器或 Razor Page 的参数或属性上。 绑定优先级（默认顺序）： [FromRoute] → 路由参数（如 /users/123） [FromQuery] → 查询字符串（如 ?name=john） [FromForm] → 表单数据（如 name=john 在 POST Body 中） [FromBody] → JSON/XML 等请求体数据 [FromHeader] → 请求头 ⚠️ 注意：简单类型（如 int、string）默认不会从 [FromBody] 绑定，但会从 [FromForm] 绑定。 ✅ 示例 1：HTML 表单提交（x-www-form-urlencoded） \uD83D\uDCC4 HTML 表单： html 提交 \uD83D\uDCE1 发送的请求： http POST /users/create Content-Type: application/x-www-form-urlencoded name=John&age=30 \uD83D\uDDA5 ASP.NET Core 控制器： [HttpPost(\"create\")] public IActionResult Create(string name, int age) { // name = \"John\" // age = 30 // 框架自动从表单数据绑定 return Ok(new { name, age }); } ✅ 无需任何 [From...] 特性，框架会自动从表单中绑定 name 和 age。 ✅ 示例 2：使用 [FromForm] 显式声明 虽然可以自动推断，但推荐显式使用 [FromForm] 提高可读性： [HttpPost(\"create\")] public IActionResult Create([FromForm] string name, [FromForm] int age) { return Ok(new { name, age }); } ✅ 示例 3：绑定到模型类（复杂类型） public class User { public string Name { get; set; } public int Age { get; set; } } [HttpPost(\"create\")] public IActionResult Create([FromForm] User user) { // user.Name = \"John\" // user.Age = 30 return Ok(user); } ✅ 框架会自动将表单字段 name 和 age 映射到 User 对象的属性。 ✅ 示例 4：文件上传（multipart/form-data） 当表单包含文件时，使用 multipart/form-data。 \uD83D\uDCC4 HTML： html 上传 \uD83D\uDDA5 控制器： [HttpPost(\"upload\")] public async Task<IActionResult> Upload( [FromForm] string name, [FromForm] IFormFile avatar) { if (avatar != null && avatar.Length > 0) { var filePath = Path.Combine(\"uploads\", avatar.FileName); using var stream = new FileStream(filePath, FileMode.Create); await avatar.CopyToAsync(stream); } return Ok(new { name, fileName = avatar.FileName }); } ✅ IFormFile 专门用于接收上传的文件。 ❗ 重要：表单绑定与 JSON 绑定的区别 特性 表单数据（[FromForm]） JSON 数据（[FromBody]） Content-Type application/x-www-form-urlencoded 或 multipart/form-data application/json 数据格式 key=value&key2=value2 { \"key\": \"value\" } 简单类型绑定 ✅ 支持（默认） ❌ 不支持（需显式 [FromBody]） 文件上传 ✅ 支持（multipart） ❌ 不支持 多参数绑定 ✅ 支持（多个简单类型） ❌ 只能一个 [FromBody] 参数 推荐场景 HTML 表单、传统 POST RESTful API、前后端分离 ✅ 如何强制使用 [FromForm]？ 如果你的 API 同时支持 JSON 和 表单，但你想明确只从表单绑定，必须显式使用 [FromForm]： [HttpPost] public IActionResult Create([FromForm] User user) // 只接受表单 { // 如果 Content-Type 是 application/json，绑定会失败 } \uD83D\uDCDA 微软官方文档参考 模型绑定 - FromForm https://docs.microsoft.com/zh-cn/aspnet/core/mvc/models/model-binding#fromform-attribute 上传文件 https://docs.microsoft.com/zh-cn/aspnet/core/mvc/models/file-uploads ✅ 总结 问题 回答 “表单类型”是什么？ 指 application/x-www-form-urlencoded 或 multipart/form-data 格式的请求体 简单类型能从表单绑定吗？ ✅ 能！ string、int 等会自动从表单绑定 需要 [FromForm] 吗？ 可选，但推荐显式使用以提高可读性 能上传文件吗？ ✅ 能，使用 multipart/form-data + IFormFile 和 JSON 绑定冲突吗？ 是，一个请求只能有一种格式，框架根据 Content-Type 选择绑定源 \uD83D\uDCCC 记住： 当你看到 name=john&age=25 在请求体中，这就是“表单类型”，ASP.NET Core 默认会从这里绑定简单类型和复杂类型。"
  },
  "docs/ASP-NET-Core/Nginx反向代理.html": {
    "href": "docs/ASP-NET-Core/Nginx反向代理.html",
    "title": "| CZQDocs",
    "summary": "发布并运行你的 ASP.NET Core 项目 ✅ 确认服务运行在 http://localhost:5000（或你配置的端口） 配置 Nginx 反向代理 C:\\nginx-1.24.0\\ ├── conf\\ ← 配置文件 ├── html\\ ← 默认网页 |—— logs\\ ← 日志 ├── nginx.exe ← 主程序 └── ... 配置 Nginx 反向代理 编辑配置文件：conf/nginx.conf worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # ========== 反向代理配置开始 ========== server { listen 80; server_name localhost; location / { proxy_pass http://localhost:5000; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; } # 可选：静态文件缓存（如果有前端） # location /static/ { # alias C:/path/to/static/files/; # expires 30d; # } } # ========== 反向代理配置结束 ========== } listen 80; 监听 80 端口（HTTP） server_name localhost; 域名（可改为 yourdomain.com） proxy_pass http://localhost:5000; 转发到你的 ASP.NET Core 服务 proxy_set_header 传递原始请求信息，确保后端能正确获取 IP、协议等 ⚠️ 注意：proxy_set_header Host $host; 很重要，否则后端生成的链接可能出错。 所有请求都经过 Nginx，你可以在此基础上添加： 负载均衡 缓存 静态文件服务 HTTPS 访问日志 C:\\nginx-1.24.0\\logs\\access.log 限流等 后续 生成 HTTPS 证书 写一个自动启动脚本 配置负载均衡 部署到 Linux 服务器"
  },
  "docs/ASP-NET-Core/模型绑定-查询和路径.html": {
    "href": "docs/ASP-NET-Core/模型绑定-查询和路径.html",
    "title": "模型绑定 | CZQDocs",
    "summary": "模型绑定 [FromQuery] 在 ASP.NET Core 中，模型绑定（Model Binding）是一个核心功能，它能自动将 HTTP 请求中的数据（如查询字符串、路由数据、表单字段、JSON 正文等）映射到控制器操作方法的参数或复杂对象的属性上。 [FromQuery] 和 [FromRoute] 是两个用于明确指定模型绑定来源的特性（Attributes），它们属于“源参数绑定器”（Source Parameter Binders）。使用它们可以精确控制参数从请求的哪个部分获取数据。 一、[FromQuery] 作用 [FromQuery] 特性指示模型绑定器从 HTTP 请求的查询字符串（Query String） 中提取数据来绑定参数。 语法 [FromQuery] T parameterName 3. 使用场景 适用于 GET 请求中传递筛选、分页、排序等参数。 4. 示例 假设有一个获取用户列表的 API，支持分页： [HttpGet(\"users\")] public IActionResult GetUsers([FromQuery] int page = 1, [FromQuery] int pageSize = 10) { // 处理逻辑 return Ok(new { Page = page, PageSize = pageSize }); } 当访问 URL： GET /users?page=2&pageSize=20 page 参数会绑定为 2 pageSize 参数会绑定为 20 如果省略参数，则使用默认值（如 page=1, pageSize=10）。 绑定复杂对象（较少见） 你也可以用 [FromQuery] 绑定一个包含多个属性的 POCO 类型： public class UserQueryParams { public int? Page { get; set; } = 1; public int? PageSize { get; set; } = 10; public string? SortBy { get; set; } public bool Descending { get; set; } } [HttpGet(\"users\")] public IActionResult GetUsers([FromQuery] UserQueryParams queryParams) { // queryParams 自动从 query string 填充 return Ok(queryParams); } 请求： /users?page=3&pageSize=15&sortBy=name&descending=true 将正确填充 queryParams 对象。 ⚠️ 注意：复杂对象从查询字符串绑定时，不支持嵌套对象或集合的深度绑定（如 filter[name]=john），需要自定义模型绑定器。 [FromRoute] 作用 [FromRoute] 特性指示模型绑定器从 路由模板中定义的路由数据（Route Data） 提取值来绑定参数。 语法 [FromRoute] T parameterName 3. 使用场景 适用于 RESTful 风格的 URL，例如根据 ID 获取资源。 4. 示例 [HttpGet(\"users/{id:int}\")] public IActionResult GetUserById([FromRoute] int id) { // 从路由中提取 id return Ok(new { Id = id }); } 当访问： GET /users/123 id 参数会被绑定为 123 5. 路由参数名称匹配 ASP.NET Core 默认通过 参数名匹配 来绑定路由数据。例如： [HttpGet(\"orders/{orderId}/items/{itemId}\")] public IActionResult GetItem( [FromRoute] int orderId, [FromRoute] int itemId) { return Ok(new { OrderId = orderId, ItemId = itemId }); } 访问 /orders/5/items/10 将正确绑定 orderId=5, itemId=10。 ✅ 提示：即使参数顺序不同，只要名字匹配路由占位符即可。 6. 显式指定路由键名（可选） 你可以显式指定从哪个路由键取值： [FromRoute(Name = \"id\")] int userId 这在参数名与路由占位符不一致时很有用： [HttpGet(\"{id}\")] public IActionResult GetUser([FromRoute(Name = \"id\")] int userId) { return Ok(new { UserId = userId }); } 对比总结 特性 [FromQuery] [FromRoute] 数据来源 查询字符串（URL 中 ? 后的部分） 路由模板中的占位符（如 {id}） 典型用途 分页、过滤、搜索参数 RESTful 资源定位（如 /users/123） 示例 URL /users?page=2&size=10 /users/123 是否必需 否（可设默认值） 通常必需（除非有默认值或可空类型） 支持复杂对象 有限支持（扁平结构） 不推荐用于复杂对象 最佳实践建议 显式使用 [FromQuery] 和 [FromRoute] 提高可读性 即使框架能自动推断，显式标注能让代码意图更清晰。 csharp // 推荐写法 public IActionResult Search([FromQuery] string q, [FromRoute] int tenantId) 避免歧义 如果参数名同时出现在路由和查询字符串中，使用 [FromQuery] 或 [FromRoute] 可避免混淆。 结合 [ApiController] 使用 在标记了 [ApiController] 的控制器中，对于复杂类型参数，默认从正文绑定（Body），简单类型默认从查询或路由绑定，因此明确标注更安全。 验证输入 结合数据注解（如 [Required], [Range]）进行验证： csharp public IActionResult GetUsers([FromQuery][Range(1, 1000)] int page = 1) 常见问题 Q: 不加 [FromQuery] 或 [FromRoute] 会怎样？ A: ASP.NET Core 会尝试根据参数类型和位置自动推断来源： 简单类型（int, string, Guid 等）：尝试从路由、查询字符串、表单字段等按优先级绑定。 复杂类型：默认从 Body 绑定（尤其是 [ApiController] 下）。 但自动推断可能导致意外行为，推荐显式指定来源以增强可维护性和可预测性。 总结 [FromQuery]：从 URL 查询字符串绑定数据，适合传递非关键性的筛选参数。 [FromRoute]：从 URL 路径的路由段中绑定数据，适合标识资源的唯一路径。 两者都是控制模型绑定行为的重要工具，在构建清晰、可维护的 Web API 时应合理使用。"
  },
  "docs/ASP-NET-Core/模型验证.html": {
    "href": "docs/ASP-NET-Core/模型验证.html",
    "title": "介绍 | CZQDocs",
    "summary": "介绍 关于 ModelState.IsValid 以及它在 ASP.NET Core MVC 中如何与数据注释（如 [Required]、[EmailAddress]）配合进行模型验证，微软官方文档提供了非常详细的说明。 ✅ 官方文档地址（推荐）： \uD83D\uDD17 ASP.NET Core 中的模型验证 URL: https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/validation \uD83D\uDCDA 该页面涵盖的核心内容包括： 主题 说明 \uD83D\uDD39 验证属性（如 [Required], [EmailAddress]） 如何使用数据注释进行声明式验证。 \uD83D\uDD39 ModelState.IsValid 如何在控制器中使用它判断模型是否有效。 \uD83D\uDD39 验证错误处理 当验证失败时如何返回视图或返回错误 JSON。 \uD83D\uDD39 客户端验证 如何启用基于 jQuery 的客户端验证（无刷新校验）。 \uD83D\uDD39 自定义验证 创建自定义验证属性或实现 IValidatableObject。 \uD83D\uDD39 复杂类型验证 验证嵌套对象、集合等。 \uD83E\uDDEA 示例代码（来自文档） [HttpPost] public IActionResult Create(Product product) { if (ModelState.IsValid) { // 模型验证通过，保存数据 \\_context.Products.Add(product); \\_context.SaveChanges(); return RedirectToAction(\"Index\"); } // 验证失败，返回视图并显示错误 return View(product); } 你可以在上述文档中找到这个模式的完整解释。 \uD83D\uDD17 其他相关官方链接（可选阅读） 模型绑定概述： https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/model-binding 标记帮助程序中的验证显示（asp-validation-for）： https://learn.microsoft.com/zh-cn/aspnet/core/mvc/views/working-with-forms ✅ 建议 你可以将这个页面（https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/validation）作为 ASP.NET Core 模型验证的权威参考指南，内容全面且持续更新，适用于 ASP.NET Core 3.1 到最新的 .NET 8 版本。 如果你使用的是英文阅读，也可以切换为英文版： \uD83C\uDF10 https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation"
  },
  "docs/EF-Core/Code-First和Database-First.html": {
    "href": "docs/EF-Core/Code-First和Database-First.html",
    "title": "| CZQDocs",
    "summary": "这是一个非常核心的问题。EF Core 的 Code First 和 Database First 的主要区别在于开发流程的起点和“权威来源”（Source of Truth）不同。 Code First：以 C# 代码为起点和权威。 Database First：以数据库为起点和权威。 Entity Framework Core: Code First vs Database First 对比两种开发模式：代码优先与数据库优先 代码优先和数据库优先 特性 Code First (代码优先) Database First (数据库优先) 起点 (Starting Point) 你先编写 C# 实体类 (Blog, Post) 和 DbContext。 数据库已经存在，包含表 (Blogs, Posts) 和关系。 权威来源 (Source of Truth) C# 代码 是定义数据模型的权威。数据库结构应与代码保持一致。 数据库 是定义数据模型的权威。C# 代码应与数据库结构保持一致。 工作流程 1. 编写/修改 C# 实体类。 2. 使用 Add-Migration 命令创建迁移文件。 3. 使用 Update-Database 命令将变更应用到数据库（创建/修改表）。 1. 数据库结构发生变化（或首次接入）。 2. 使用 dotnet ef dbcontext scaffold 命令反向生成 C# 实体类和 DbContext。 3. 在代码中使用生成的类进行数据访问。 模型配置 主要通过 Fluent API (OnModelCreating) 和 数据注释 来配置，覆盖默认约定。 Scaffolding 工具根据数据库结构自动生成 Fluent API 配置，确保精确映射。 主要工具命令 - dotnet ef migrations add <Name> - dotnet ef database update - dotnet ef dbcontext scaffold <连接字符串> <Provider> 适用场景 - 新项目开发，开发者主导数据模型设计。 - 希望通过版本控制管理数据库变更历史。 - 偏好在 C# 中定义领域模型。 - 集成到现有/遗留系统。 - 数据库由 DBA 或专门团队 设计和管理。 - 项目需要严格遵守已有的数据库规范。 代码生成 不生成实体类代码。开发者手动编写。 生成实体类和 DbContext 代码。 数据库生成 通过迁移 (Migrations) 从代码生成和更新数据库。 数据库已存在，不通过 EF Core 生成。 变更管理 代码变更 → 迁移 → 数据库变更。 数据库变更 → 重新 Scaffolding → 代码变更。 优点 - 开发者体验好，代码即文档。 - 迁移提供清晰的数据库版本历史。 - 易于在团队中通过代码审查模型变更。 - 快速接入现有数据库。 - 确保模型与复杂或非标准的数据库结构精确匹配。 缺点 - 需要学习和管理迁移。 - 对于极其复杂的遗留数据库，可能难以用约定和配置完美映射。 - 生成的代码通常不应手动修改（否则重新 Scaffolding 会丢失）。 - 缺少清晰的数据库变更历史记录（除非数据库本身有版本控制）。 - 对数据库的依赖性强。 总结 选择 Code First 当你从零开始一个新项目，希望用 C# 代码来驱动数据库设计，并利用 Migrations 来优雅地管理数据库的演进。 选择 Database First 当你需要连接到一个已经存在且结构复杂的数据库（例如公司的核心业务系统），并且数据库的结构是“既定事实”，你只需要生成匹配的代码来与之交互。 现代趋势： 虽然两种模式都有效，但微软和社区目前更推荐 Code First with Migrations，因为它提供了更好的可维护性、可测试性和与 DevOps 流程的集成。Database First 仍然是处理遗留系统集成的强有力工具。"
  },
  "docs/EF-Core/Database-First.html": {
    "href": "docs/EF-Core/Database-First.html",
    "title": "| CZQDocs",
    "summary": "Database First *简短回答：在 Database First 模式下，生成的 OnModelCreating 中的 Fluent API 配置 技术上不是绝对必须的，但对于正确映射复杂的数据库结构来说，它几乎是必不可少的，也是工具生成它的根本原因。 让我们深入解释一下： 为什么 Database First 会生成 Fluent API 配置？ 虽然 EF Core 有强大的约定 (Conventions)，但现实世界的数据库（尤其是遗留系统或由 DBA 设计的数据库）往往不符合这些约定。Scaffolding 工具需要确保生成的模型能精确地、无歧义地反映现有数据库的每一个细节。 Fluent API 提供了最强大和最精确的配置方式，可以覆盖所有约定无法处理或处理错误的情况。以下是一些常见的、必须使用 Fluent API 配置的例子： 不符合约定的主键/外键名称: 约定: 主键期望名为 Id 或 <类名>Id。 现实: 数据库主键可能是 Blog_PK, blog_id, RecordId 等。 Fluent API: modelBuilder.Entity ().HasKey(b => b.Blog_PK); 不符合约定的表名或列名: 约定: 类 Blog 映射到表 Blogs，属性 Url 映射到列 Url。 现实: 表可能是 tblBlog，列可能是 blog_url。 Fluent API: modelBuilder.Entity ().ToTable(\"tblBlog\"); 和 modelBuilder.Entity ().Property(b => b.Url).HasColumnName(\"blog_url\"); 复杂的数据类型和精度: 约定: string 属性可能被映射为 nvarchar(max) 或默认长度。 现实: 列 Title 是 nvarchar(100)，Price 是 decimal(18,2)。 Fluent API: modelBuilder.Entity ().Property(p => p.Title).HasMaxLength(100); 和 modelBuilder.Entity ().Property(p => p.Price).HasPrecision(18, 2); 复杂的外键关系和级联删除: 约定: 可能无法正确推断自引用关系或非标准的外键名称。 现实: 需要明确配置外键属性、导航属性以及 OnDelete 行为（如 Restrict, Cascade）。 Fluent API: modelBuilder.Entity ().HasOne(p => p.Blog).WithMany(b => b.Posts).HasForeignKey(\"blog_fk_id\").OnDelete(DeleteBehavior.Cascade); 索引: 约定: 不会自动为非主键列创建索引。 现实: 数据库中已有 IX_Blog_Url 索引。 Fluent API: modelBuilder.Entity ().HasIndex(b => b.Url).HasDatabaseName(\"IX_Blog_Url\"); 如果没有 Fluent API 配置会怎样？ 如果 Scaffolding 工具不生成这些 Fluent API 配置，而是完全依赖约定，那么： 生成的模型将无法准确反映数据库结构。 当 EF Core 尝试查询或保存数据时，会因为表名、列名、主键不匹配而抛出 SqlException。 数据类型不匹配可能导致数据截断或转换错误。 关系无法建立，导致导航属性无法正常工作。 为什么不用数据注释 (Data Annotations)？ 你可能会问，为什么不用 [Table], [Column], [Key] 这些特性呢？这也是个好问题。 Fluent API 更强大: 对于非常复杂的配置（如复杂的索引、特定的约束、某些数据库特定的配置），数据注释可能无能为力，而 Fluent API 可以。 保持实体类“干净”: 数据注释会直接“污染”你的实体类。而 Fluent API 集中在 OnModelCreating 方法中，使实体类保持为更纯粹的 POCO (Plain Old CLR Object)。 工具生成的便利性: Scaffolding 工具更容易将所有配置集中写在一个地方（OnModelCreating），而不是分散到多个类的多个属性上。 结论 因此，虽然 EF Core 的核心模型最终是内存中的元数据，而这个元数据可以通过约定、数据注释或 Fluent API 三种方式中的任何一种来构建，但在 Database First 场景下： Scaffolding 工具选择生成 Fluent API 配置是经过深思熟虑的最佳实践。 它确保了生成的模型能够精确、完整、可靠地映射到任意复杂或非标准的现有数据库。 它避免了依赖可能失败的约定，并提供了数据注释无法比拟的灵活性和控制力。 所以，虽然从技术上讲，如果数据库完美符合所有 EF Core 的约定，你可能不需要 Fluent API，但在实际的 Database First 项目中，这些生成的 Fluent API 配置是保证模型正确性的关键，是不可或缺的。"
  },
  "docs/EF-Core/Realtions.html": {
    "href": "docs/EF-Core/Realtions.html",
    "title": "| CZQDocs",
    "summary": "关系简介 一对多关系 在 EF Core 的一对多关系里，外键的核心作用可以概括为三点： 建立表间关联 外键字段放在“多”端表中，用来存储“一”端表的主键值，从而把两条记录绑定在一起。例如 Blog-Post 关系里，Post 表的 BlogId 外键指向 Blog 表的 Id，表示这条帖子属于哪个博客。 保证引用完整性 数据库会强制检查：插入或更新 Post 记录时，其 BlogId 必须在 Blog 表中真实存在，否则操作失败。这防止了出现“孤儿”记录。 支撑导航与级联行为 有了外键，EF Core 才能生成 Blog.Posts 这样的集合导航属性，让代码可以直接 blog.Posts.ToList() 拉取所有相关帖子。 同时可在 OnModelCreating 里通过 .HasForeignKey().OnDelete(DeleteBehavior.Cascade) 配置级联删除：删除 Blog 时，数据库自动把该 Blog 的所有 Post 一并删除，保持数据一致。 一句话总结：外键是“多”端表里的一个字段，它把两条记录拴在一起，既保证数据正确，又让 EF Core 能自动生成导航属性和级联逻辑。 一对一 在 EF Core 的一对一关系里，外键的作用与一对多类似，但有两点关键差异： 外键位置与唯一性 外键放在“依赖”端（从表），并必须加唯一约束，确保“一”对“一”的映射不会变成“一”对“多”。 例如：User-UserProfile 关系中，UserProfile 表的 UserId 字段既是外键又是唯一键，表示每个用户只能有一个资料。 级联与可选性 外键列是否允许 NULL 决定了关系是“必需”还是“可选”。 若外键不允许 NULL，则删除主表记录时，从表记录也会被级联删除（或抛异常），保证不会留下孤立记录。 若外键允许 NULL，则关系是可选的，级联删除行为需要显式配置。 一句话总结：一对一的外键仍负责“挂靠”两条记录，但必须加唯一约束来保证“一对一”，并通过是否允许 NULL 来决定关系是否强制存在。 两条记录指的是一对一关系中的“主”与“从”两条数据。 以 User（主）和 UserProfile（从）为例： 主记录：User 表中的一条用户数据，主键为 Id。 从记录：UserProfile 表中的一条资料数据，包含外键 UserId，且该字段加唯一约束，确保同一个用户不能拥有两条资料记录。 外键 UserId 把 UserProfile 的这条记录“挂”在 User 上，形成一对一映射。"
  },
  "docs/EF-Core/SQL 数据库项目 .html": {
    "href": "docs/EF-Core/SQL 数据库项目 .html",
    "title": "| CZQDocs",
    "summary": "SQL 数据库项目 (SQL Database Project) 的工作模式 这是一个非常棒的问题，它触及了现代数据库开发实践的核心。将数据库使用 SQL 数据库项目（如 Visual Studio 的 SQL Server Data Tools - SSDT 项目或 .sqlproj）进行版本管理，是一种非常专业和推荐的做法，它代表了一种与 EF Core Code First Migrations 不同但同样有效的数据库变更管理哲学。 让我们来分析这种情况： 权威来源 (Source of Truth): 数据库的“定义”是一组 .sql 脚本文件，存放在版本控制系统（如 Git）中。这些脚本包括： Tables/.sql (创建表) Stored Procedures/.sql (存储过程) Views/.sql (视图) Functions/.sql (函数) Post-Deployment Scripts (部署后脚本，如种子数据) 构建与部署: 项目可以被编译成一个 .dacpac 文件（数据库层应用程序包）。 使用工具（如 SqlPackage.exe 或 Visual Studio 的发布功能）将 .dacpac 部署到目标数据库服务器。 部署工具会比较目标数据库的当前状态与 .dacpac 中定义的目标状态。 自动生成一个 增量更新脚本（包含 CREATE, ALTER, DROP 等语句），并执行它来使目标数据库与项目定义同步。 版本管理: 所有的 .sql 文件都受版本控制。 团队成员通过提交对这些脚本的修改来提议数据库变更。 变更通过 Pull Request (PR) 进行代码审查。 与 EF Core Code First Migrations 的对比 特性 SQL 数据库项目 (.sqlproj) EF Core Code First Migrations :--- :--- :--- 模型定义方式 声明式 (Declarative): 你定义数据库的期望最终状态。 命令式 (Imperative): 你定义从一个版本到另一个版本的变更步骤 (Up()/Down() 方法)。 工作流程 修改 .sql 脚本 -> 提交到 Git -> CI/CD 构建并部署 .dacpac。 修改 C# 实体 -> Add-Migration -> Update-Database (或发布迁移)。 工具 Visual Studio SSDT, SqlPackage.exe, Azure DevOps Pipeline 任务。 dotnet ef CLI, EF Core 运行时。 与 EF Core 的关系 独立于 ORM。你可以用任何技术（ADO.NET, Dapper, EF Core）连接到这个数据库。 紧密耦合于 EF Core。迁移是 EF Core 框架的一部分。 数据库结构 可以精确控制所有数据库对象（表、视图、存储过程、函数、索引、约束等）。 主要关注表、列、主键、外键、索引。对存储过程、复杂函数的支持较弱。 变更审查 审查的是 .sql 文件的变更，非常直接。 审查的是 C# 迁移代码，需要理解 EF Core 的 API。 部署可靠性 高度可靠，SqlPackage 是微软官方的成熟工具，能处理复杂的架构变更。 可靠，但复杂的 Up() 脚本如果编写不当可能出错。Down() 脚本有时难以完美实现。 适用团队 有专门 DBA 或数据库开发人员的团队。 以应用程序开发人员为主，希望数据库变更与应用代码变更紧密结合的团队。 如果你使用了 SQL 数据库项目，EF Core 应该如何配合？ 在这种情况下，EF Core 的 Database First 模式通常是更自然的选择： 数据库是权威: 你的 .sqlproj 项目是数据库结构的唯一来源。 生成模型: 当数据库结构通过 .sqlproj 部署发生变更后，你运行 dotnet ef dbcontext scaffold 命令，从更新后的数据库反向生成最新的 EF Core 实体类和 DbContext。 代码使用: 你的应用程序使用这些生成的类通过 EF Core 进行数据访问。 也可以结合使用吗？ 可以，但需要谨慎设计，避免冲突。 一种可能的混合模式是： 使用 SQL 数据库项目 来管理所有的数据库架构变更。这是“主”流程。 在开发过程中，为了快速迭代，开发人员可以使用 EF Core Migrations 在本地数据库进行一些实验性变更。 但最终，任何要合并到主分支的变更，都必须将 .sql 脚本手动或通过工具同步到 SQL 数据库项目中，并通过 .sqlproj 的标准流程进行部署。 部署后，再运行 scaffold 更新 EF 模型。 结论 如果你已经对数据库使用 SQL 数据库项目进行版本管理，这说明你采用了一种以数据库为中心、声明式、与 ORM 解耦的高级数据库开发实践。 这不是错误的选择，反而是一种非常专业和稳健的做法，尤其适合大型团队、复杂数据库或对数据库有严格合规要求的场景。 在这种模式下，EF Core 更适合作为 Database First 的数据访问层，而不是用它的 Migrations 来管理数据库架构。 选择 .sqlproj 还是 EF Migrations 并没有绝对的对错，关键在于团队的技术栈、偏好和项目的具体需求。两者都是管理数据库变更的有效工具。"
  },
  "docs/EF-Core/创建和配置模型.html": {
    "href": "docs/EF-Core/创建和配置模型.html",
    "title": "创建和配置模型 | CZQDocs",
    "summary": "创建和配置模型 在 EF Core 中，数据注释（Data Annotations） 和 Fluent API 在很多功能上确实可以相互替代，它们都用于对模型进行配置，以覆盖默认的约定。然而，两者在使用方式、灵活性和功能范围上存在一些关键区别。 相同点：可替代性 对于许多常见的配置需求，你既可以用数据注释，也可以用 Fluent API 来实现。例如： 配置目标 数据注释示例 Fluent API 示例 using System.ComponentModel.DataAnnotations; using System.ComponentModel.DataAnnotations.Schema; using Microsoft.EntityFrameworkCore; // 实体类定义 public class Blog { // 主键 [Key] public int Id { get; set; } // 必填字段，最大长度 200 [Required] [MaxLength(200)] public string Url { get; set; } // 导航属性：一对多关系中的“一”端 public ICollection<Post> Posts { get; set; } } public class Post { [Key] public int Id { get; set; } // 外键属性 [ForeignKey(\"BlogId\")] public int BlogId { get; set; } // 导航属性：一对多关系中的“多”端 public Blog Blog { get; set; } } // DbContext 配置 public class BloggingContext : DbContext { public DbSet<Blog> Blogs { get; set; } public DbSet<Post> Posts { get; set; } protected override void OnModelCreating(ModelBuilder modelBuilder) { // 表名映射 modelBuilder.Entity<Blog>().ToTable(\"Blogs\"); // 主键配置 modelBuilder.Entity<Blog>().HasKey(b => b.Id); modelBuilder.Entity<Post>().HasKey(p => p.Id); // 字符串长度/最大长度 modelBuilder.Entity<Blog>().Property(b => b.Url).HasMaxLength(200); // 必填字段 modelBuilder.Entity<Blog>().Property(b => b.Url).IsRequired(); // 关系配置（一对多） modelBuilder.Entity<Post>() .HasOne(p => p.Blog) // Post 有一个 Blog .WithMany(b => b.Posts) // Blog 有多个 Posts .HasForeignKey(p => p.BlogId); // 外键是 Post.BlogId } } 说明： [Key]：指定主键。 [Required]：表示该字段不能为空（对应数据库中的 NOT NULL）。 [MaxLength] / [StringLength]：限制字符串最大长度。 [Table(\"Blogs\")]：将 Blog 实体映射到名为 \"Blogs\" 的数据库表。 [ForeignKey(\"BlogId\")]：显式指定外键属性。 Fluent API：在 OnModelCreating 中使用 modelBuilder 进行更灵活的配置，优先级高于数据注解。 不同点：优势与限制 尽管功能有重叠，但两者在实际使用中各有优劣： ✅ 数据注释（Data Annotations） 优点： 简洁直观，直接写在实体类上，便于快速查看。 适合简单的、与业务逻辑紧密相关的验证规则（如 [Required], [EmailAddress]）。 缺点： 将 EF Core 的依赖引入了实体类，违反了“关注点分离”原则。 功能有限，无法完成一些高级或复杂配置。 不支持所有 Fluent API 的功能。 ⚠️ 注意：某些属性（如 [Column(Order = ...)]）在 EF Core 中已被移除或不支持顺序定义。 ✅ Fluent API 优点： 更强大、更灵活，支持几乎所有模型配置选项。 可以配置数据注释无法完成的内容，例如： 复合主键 索引创建（.HasIndex()） 值转换器（Value Converters） 查询过滤器（Query Filters） 复杂的关系导航配置 属性映射到 JSON 列等 保持实体类“纯净”，不依赖 EF Core 命名空间。 集中管理，在 OnModelCreating 中统一配置，便于维护。 缺点： 写法相对繁琐，代码量较多。 需要跳转到 DbContext 类才能查看完整配置。 推荐实践 大多数现代 EF Core 开发中推荐： ✅ 优先使用 Fluent API 进行模型配置，尤其是在大型项目或需要精细控制时。 \uD83D\uDFE1 数据注释可用于轻量级项目或结合 ASP.NET Core MVC 验证（如 [Required] 同时用于 UI 验证和数据库约束）。 \uD83D\uDD01 混合使用也是常见做法：用数据注释处理简单验证，Fluent API 处理复杂映射。 总结 是的，数据注释和 Fluent API 在部分功能上可以相互替代，比如设置主键、长度、必填等。 但 Fluent API 更强大、更灵活，能做数据注释做不到的事，因此在需要高级配置或追求代码清晰结构时，应优先选用 Fluent API。"
  },
  "docs/EF-Core/备用密钥.html": {
    "href": "docs/EF-Core/备用密钥.html",
    "title": "| CZQDocs",
    "summary": "备用密钥 你提供的这个例子非常经典，它展示了一个 非主键字段之间的实体关联。我们来结合代码详细讲解： modelBuilder.Entity<Post>() .HasOne(p => p.Blog) .WithMany(b => b.Posts) .HasForeignKey(p => p.BlogUrl) .HasPrincipalKey(b => b.Url); ✅ 先回答你的核心问题： .HasForeignKey(p => p.BlogUrl) 和 .HasPrincipalKey(b => b.Url) 必须一起使用吗？ \uD83D\uDD25 是的，在这种情况下必须一起使用！ 原因如下： 方法 作用 .HasForeignKey(...) 指定“外键字段” —— 哪个字段存储了引用值（这里是 Post.BlogUrl） .HasPrincipalKey(...) 指定“被引用的键” —— 引用的是主表中的哪个唯一字段（这里是 Blog.Url） \uD83D\uDC49 因为： 外键 BlogUrl 不是指向主键 BlogId 而是指向另一个字段 Url 所以 EF Core 无法自动推断关系目标，你必须明确告诉它：“我引用的是 Blog.Url 字段”，这就需要 .HasPrincipalKey()。 如果不写 .HasPrincipalKey(b => b.Url)，EF 默认会尝试引用主键 BlogId，就会出错或生成错误的关系。 \uD83E\uDDE9 一、整体关系图解 text Post 表 ┌─────────┬───────────┬──────────┬────────────┐ │ PostId │ Title │ Content │ BlogUrl │ ← 外键字段 └─────────┴───────────┴──────────┴────────────┘ │ ↓ 引用 Blog 表 ┌─────────┬──────────────┐ │ BlogId │ Url │ ← 被引用字段（不是主键！） └─────────┴──────────────┘ \uD83D\uDCCC 关系含义： “每篇博客文章（Post）属于一个博客（Blog），通过博客的 URL 关联” 例如： Post.BlogUrl = \"https://example.com\" → 对应 → Blog.Url = \"https://example.com\" \uD83D\uDD0D 二、逐行解释配置 csharp modelBuilder.Entity () .HasOne(p => p.Blog) // 一个 Post 属于一个 Blog .WithMany(b => b.Posts) // 一个 Blog 有多个 Posts .HasForeignKey(p => p.BlogUrl) // 外键是 Post.BlogUrl .HasPrincipalKey(b => b.Url); // 引用的是 Blog.Url（不是主键） .HasOne(p => p.Blog) 表示：Post 导航到一个 Blog 对象。 定义关系的一端：从 Post 到 Blog。 .WithMany(b => b.Posts) 表示：每个 Blog 可以有多个 Post。 定义另一端：从 Blog 到 Posts 的集合。 ✅ 合起来就是：一对多关系（1 对多） .HasForeignKey(p => p.BlogUrl) 明确指出：用来建立关系的“外键字段”是 Post 类的 BlogUrl 属性。 数据库存储的是对方 Blog 的某个唯一标识（这里是 Url）。 \uD83D\uDD27 作用： 在数据库中创建外键约束： sql FOREIGN KEY (BlogUrl) REFERENCES Blogs(Url) .HasPrincipalKey(b => b.Url) 关键点来了：告诉 EF Core，“我引用的不是主键 BlogId，而是 Url 字段” 所以 Blog.Url 必须能唯一标识一条记录 → 必须设置为备用密钥（Alternate Key） ⚠️ 如果你不先让 Url 成为备用密钥，这段代码会运行时报错！ ⚠️ 三、你漏掉了一步：必须配置备用密钥！ 你现在只写了关系映射，但 没有告诉 EF Core Blog.Url 是唯一标识符。 ❌ 当前代码会失败！ 你需要补充这一句： csharp protected override void OnModelCreating(ModelBuilder modelBuilder) { // \uD83D\uDC49 新增：把 Url 设为备用密钥（唯一 + 可被外键引用） modelBuilder.Entity () .HasAlternateKey(b => b.Url); // 原来的关系配置 modelBuilder.Entity () .HasOne(p => p.Blog) .WithMany(b => b.Posts) .HasForeignKey(p => p.BlogUrl) .HasPrincipalKey(b => b.Url); } 否则你会遇到错误： The referenced entity key 'Blog { Url }' does not contain all of the key properties. Either add the missing properties or specify an alternate name using 'HasForeignKey'. 或者更常见的： The properties {'Url'} on entity type 'Blog' are not configured as a primary or alternate key. They should be configured as a primary or alternate key to be used in a foreign key. \uD83E\uDDF1 数据库最终生成什么？ 加上 .HasAlternateKey(b => b.Url) 后，生成的 SQL 类似： sql -- Blog 表 CREATE TABLE Blogs ( BlogId int PRIMARY KEY, Url nvarchar(max) NOT NULL ); -- 创建唯一约束：Url 必须唯一（因为是备用密钥） ALTER TABLE Blogs ADD CONSTRAINT AK_Blogs_Url UNIQUE (Url); -- Post 表 CREATE TABLE Posts ( PostId int PRIMARY KEY, Title nvarchar(max), Content nvarchar(max), BlogUrl nvarchar(max) NOT NULL -- 外键字段 ); -- 创建外键：指向 Blogs.Url（不是主键！） ALTER TABLE Posts ADD CONSTRAINT FK_Posts_Blogs_BlogUrl FOREIGN KEY (BlogUrl) REFERENCES Blogs(Url); ✅ 正确完整的代码 internal class MyContext : DbContext { public DbSet<Blog> Blogs { get; set; } public DbSet<Post> Posts { get; set; } protected override void OnModelCreating(ModelBuilder modelBuilder) { // ✅ 第一步：设置备用密钥 modelBuilder.Entity<Blog>() .HasAlternateKey(b => b.Url); // ✅ 第二步：配置关系 modelBuilder.Entity<Post>() .HasOne(p => p.Blog) .WithMany(b => b.Posts) .HasForeignKey(p => p.BlogUrl) .HasPrincipalKey(b => b.Url); } } public class Blog { public int BlogId { get; set; } public string Url { get; set; } public List<Post> Posts { get; set; } } public class Post { public int PostId { get; set; } public string Title { get; set; } public string Content { get; set; } public string BlogUrl { get; set; } public Blog Blog { get; set; } } \uD83D\uDCCC 总结 问题 回答 .HasForeignKey 和 .HasPrincipalKey 必须一起用吗？ ✅ 是的！ 当外键不指向主键时，必须同时指定“谁是外键”和“引用谁” 为什么需要 .HasPrincipalKey？ 因为默认引用主键，现在你要引用非主键字段（如 Url），必须明确指定 HasPrincipalKey 指向的字段有什么要求？ 必须是 主键 或 备用密钥（即唯一标识） 我的代码有问题吗？ ❌ 有！缺了 .HasAlternateKey(b => b.Url)，必须补上 \uD83D\uDCA1 最佳实践建议： 尽量用主键做外键关联（最简单安全）。 只有在特殊业务场景下（如第三方系统用 URL 标识资源），才用非主键字段关联，并记得配置 备用密钥！ 如果你还有类似 Username、SSN、Code 等字段做关联的需求，这套模式完全适用。"
  },
  "docs/EF-Core/软删除.html": {
    "href": "docs/EF-Core/软删除.html",
    "title": "| CZQDocs",
    "summary": "软删除标记做成阴影属性的完整流程 1. 数据库表结构（SQL Server 示例） CREATE TABLE Blogs ( BlogId INT IDENTITY PRIMARY KEY, Url NVARCHAR(200) NOT NULL, -- 没有显式定义 IsDeleted，它只存在于 EF 模型里 ); 2. 实体类（完全不知道“软删除”这件事） public class Blog { public int BlogId { get; set; } public string Url { get; set; } // 不包含 IsDeleted、DeletedAt 等任何软删除字段 } 3. 在 OnModelCreating 里把 IsDeleted 声明为阴影属性，并加上全局过滤 protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity<Blog>() .Property<bool>(\"IsDeleted\") // 阴影属性：数据库列存在，但实体类看不到 .HasDefaultValue(false); modelBuilder.Entity<Blog>() .HasQueryFilter(b => !EF.Property<bool>(b, \"IsDeleted\")); // 全局过滤：默认查询只返回未删除的记录 } 4. 正常业务查询（自动忽略已删除数据） // 生成的 SQL 会自动加上 WHERE [IsDeleted] = 0 var activeBlogs = context.Blogs.ToList(); 5. 需要查看“已删除”数据时，显式关闭过滤器 // 生成的 SQL 不再带 WHERE [IsDeleted] = 0，能查出所有记录 var allBlogs = context.Blogs.IgnoreQueryFilters().ToList(); 6. 执行“软删除”操作 var blog = context.Blogs.Find(1); context.Entry(blog).Property(\"IsDeleted\").CurrentValue = true; context.SaveChanges(); // 数据库里该行的 IsDeleted 被设为 1，但记录仍在；下次普通查询就查不到它了 7. 恢复已删除数据 var blog = context.Blogs.IgnoreQueryFilters().First(b => b.BlogId == 1); context.Entry(blog).Property(\"IsDeleted\").CurrentValue = false; context.SaveChanges(); 一句话总结 把 IsDeleted 放进阴影属性后，实体类完全不感知软删除逻辑；EF Core 通过全局过滤器自动屏蔽已删除数据，业务代码只需在需要时用 .IgnoreQueryFilters() 打开“查看全部”的开关即可。 把 IsDeleted 放在阴影属性里确实能实现“实体类不感知”，但它只是软删除的一种实现技巧，并不是“最佳实践”的全部。 真正的“最佳实践”还要考虑： 级联软删除：父实体被软删除后，子实体是否也要自动标记为已删除？ 性能：软删除后数据量持续增长，查询会变慢，需要定期归档或清理。 恢复机制：如何把误删的数据一键恢复？有没有“回收站”界面？ 硬删除策略：某些场景（如合规要求）仍需物理删除，不能只靠软删除。 一句话总结：阴影属性 + 全局过滤器是实现软删除的一种手段，但“最佳实践”需要结合业务场景、性能、合规等多方面权衡，不能只靠这一招。 级联软删除 = “删父带子” 核心思路：父实体被打上删除标记后，所有子实体也自动被标记为已删除，且后续恢复时能一起还原。 1. 数据库准备 父表、子表都加 IsDeleted BIT DEFAULT 0（或 DeletedAt DATETIME2）。 外键保持 NOT NULL，确保关系完整。 2. EF Core 模型 父、子实体类都不写 IsDeleted 属性。 在 OnModelCreating 里把 IsDeleted 声明为阴影属性，并给父、子表都加上全局过滤器： modelBuilder.Entity<Parent>() .Property<bool>(\"IsDeleted\") .HasDefaultValue(false); modelBuilder.Entity<Parent>() .HasQueryFilter(p => !EF.Property<bool>(p, \"IsDeleted\")); // 子表同理 3. 级联软删除逻辑 删除父实体时，手动把所有子实体的 IsDeleted 也设为 true： var parent = context.Parents.Find(id); context.Entry(parent).Property(\"IsDeleted\").CurrentValue = true; var children = context.Children.Where(c => c.ParentId == id); foreach (var child in children) context.Entry(child).Property(\"IsDeleted\").CurrentValue = true; context.SaveChanges(); 恢复时同理：先把父实体的 IsDeleted 设回 false，再把子实体全部恢复。 4. 优化：自动级联 重写 SaveChanges，当发现父实体被软删除时，自动把所有关联子实体也标记为已删除。 或者用 EF Core 的 DeleteBehavior.Cascade 配合软删除标记，但需注意： 数据库层面不要启用 ON DELETE CASCADE，否则会物理删除子表，破坏软删除语义。 一句话总结：级联软删除 = 父子表都用阴影属性 + 全局过滤器，删除时手动或自动把所有子实体的 IsDeleted 一起设为 true，恢复时再一起还原。"
  },
  "docs/GitBash常用命令.html": {
    "href": "docs/GitBash常用命令.html",
    "title": "| CZQDocs",
    "summary": "查找占用 8080 端口的进程 PID netstat -ano | grep :8080 关闭 $ powershell -command \"Stop-Process -Id 12092 -Force\""
  },
  "docs/Markdown.html": {
    "href": "docs/Markdown.html",
    "title": "A First Level Header | CZQDocs",
    "summary": "A First Level Header A Second Level Header Now is the time for all good men to come to the aid of their country. This is just a regular paragraph. The quick brown fox jumped over the lazy dog's back. Header 3 This is a blockquote. This is the second paragraph in the blockquote. This is an H2 in a blockquote Some of these words are emphasized. Some of these words are emphasized also. Use two asterisks for strong emphasis. Or, if you prefer, use two underscores instead. Candy. Gum. Booze. Candy. Gum. Booze. Candy. Gum. Booze. Red Green Blue A list item. With multiple paragraphs. Another item in the list. This is an example link. I get 10 times more traffic from Google than from Yahoo or MSN. I start my morning with a cup of coffee and The New York Times. I strongly recommend against using any <blink> tags. I wish SmartyPants used named entities like &mdash; instead of decimal-encoded entities like &#8212;. int a=1;"
  },
  "docs/Nuget/1.html": {
    "href": "docs/Nuget/1.html",
    "title": "在 SharedLibrary 目录内 | CZQDocs",
    "summary": "要让两个独立的 .NET 解决方案（分别位于两个独立的 Git 仓库中）共同引用同一个 DLL 类库项目，并使用 Gitea 托管，你需要考虑如何共享这个类库项目。以下是几种可行的方案，各有优缺点，可根据你的团队规模、发布频率和维护需求选择： 方案一：使用 Git Submodule（推荐用于小型团队或内部共享） 原理：将类库项目作为一个子模块（submodule）添加到两个主解决方案的仓库中。 步骤： 创建独立的类库仓库： 在 Gitea 上创建一个新的仓库，例如 SharedLibrary。 将你的类库项目（.csproj 文件及代码）推送到这个仓库。 在主解决方案中添加 Submodule： 在本地克隆第一个解决方案仓库（SolutionA）。 在 SolutionA 的根目录下执行： bash git submodule add https://your-gitea.com/username/SharedLibrary.git SharedLibrary 这会在 SolutionA 仓库中创建一个 SharedLibrary 目录，并将其关联到远程的 SharedLibrary 仓库。 重复以上步骤，为 SolutionB 添加相同的 submodule。 在 .NET 项目中引用： 在 SolutionA 和 SolutionB 的主项目中，通过 项目引用 (Project Reference) 添加对 SharedLibrary/SharedLibrary.csproj 的引用。 例如，在 .csproj 文件中： xml 开发与更新： 当你在 SharedLibrary 中修改代码并提交后，需要在主解决方案仓库中更新 submodule 的指针： bash 在 SharedLibrary 目录内 git pull origin main 回到主仓库根目录 git add SharedLibrary git commit -m \"Update SharedLibrary to latest\" git push 其他开发者在拉取主仓库代码后，需要初始化 submodule： bash git clone --recurse-submodules https://your-gitea.com/username/SolutionA.git 或者 git clone https://your-gitea.com/username/SolutionA.git cd SolutionA git submodule update --init --recursive 优点： 代码完全同步，主项目直接引用源码。 调试方便，可以直接进入类库代码。 无需额外的包管理工具。 缺点： 管理复杂，需要处理 submodule 的更新和同步。 如果类库频繁更新，主项目需要频繁提交 submodule 指针更新。 对团队成员的 Git 熟练度有一定要求。 方案二：使用 NuGet 私有包（推荐用于生产环境或大型团队） 原理：将类库项目打包成 NuGet 包，发布到 Gitea 内置的 NuGet 包注册表 (Package Registry) 或自建的私有 NuGet 服务器，然后在两个主项目中通过 NuGet 引用。 步骤： 配置 Gitea 的 NuGet 包注册表： 登录 Gitea，进入 SharedLibrary 仓库。 导航到 Packages -> NuGet，按照提示获取你的私有 NuGet 源 URL，例如： https://your-gitea.com/username/SharedLibrary/packages/nuget 打包类库项目： 在 SharedLibrary.csproj 中配置包信息： xml net6.0 MyCompany.SharedLibrary 1.0.0 Your Name A shared library for common functionality. https://your-gitea.com/username/SharedLibrary 构建并打包： bash dotnet pack -c Release 这会生成一个 .nupkg 文件。 发布到 Gitea NuGet 源： 在 Gitea 中为你的用户或组织创建一个 Access Token（具有 write:packages 权限）。 使用 dotnet nuget push 命令发布： bash dotnet nuget push bin/Release/MyCompany.SharedLibrary.1.0.0.nupkg --source https://your-gitea.com/username/SharedLibrary/packages/nuget --api-key YOUR_GITEA_ACCESS_TOKEN 在主项目中引用 NuGet 包： 在 SolutionA 和 SolutionB 的项目中，添加对私有 NuGet 源的引用： bash dotnet nuget add source https://your-gitea.com/username/SharedLibrary/packages/nuget --name gitea-shared-library --username your-username --password YOUR_GITEA_ACCESS_TOKEN （注意：生产环境建议使用更安全的凭据管理方式） 安装包： bash dotnet add package MyCompany.SharedLibrary --version 1.0.0 优点： 版本化管理清晰，主项目可以独立选择依赖的版本。 解耦性强，主项目和类库项目完全独立。 发布流程自动化友好（可结合 CI/CD）。 是 .NET 生态的标准做法。 缺点： 调试类库代码不如直接引用源码方便（但可以通过 Source Link 或直接引用源码调试）。 需要设置和管理包注册表。 方案三：Monorepo（单一代码仓库） 原理：将两个主项目和共享类库合并到一个大的 Git 仓库中。 步骤： 创建一个新的仓库，包含三个子目录：SolutionA、SolutionB、SharedLibrary。 两个主项目通过相对路径引用 SharedLibrary 项目。 优点： 管理最简单，所有代码在一个地方。 共享代码的变更和主项目的更新可以原子化提交。 缺点： 违背了“两个独立仓库”的要求。 仓库可能变得臃肿，权限管理复杂。 不适合大型或独立发布的项目。 总结与建议 方案 适用场景 推荐度 :--- :--- :--- Git Submodule 小型团队，共享代码频繁变更，需要直接调试源码 ⭐⭐⭐⭐ NuGet 私有包 生产环境，需要版本控制，团队较大，追求标准化 ⭐⭐⭐⭐⭐ Monorepo 项目紧密耦合，愿意放弃独立仓库的结构 ⭐⭐ 强烈推荐使用方案二（NuGet 私有包），因为它符合 .NET 最佳实践，便于版本管理和持续集成，长期维护成本最低。Gitea 内置的包注册表功能使得搭建私有 NuGet 源非常方便。 你可以根据团队的实际情况和对复杂度的容忍度来选择最合适的方案。"
  },
  "docs/Testing/NET的单元测试最佳做法.html": {
    "href": "docs/Testing/NET的单元测试最佳做法.html",
    "title": "| CZQDocs",
    "summary": ".NET 的单元测试最佳做法 一、单元测试的优点 节省时间：相比耗时的功能测试，单元测试可毫秒级自动运行。 防止回归：代码变更后能快速验证现有功能是否被破坏。 可执行文档：清晰的测试用例能说明代码在不同输入下的预期行为。 促进解耦：难以测试的代码通常意味着耦合度过高，写测试会自然推动代码解耦。 二、良好单元测试的特征 (FIRST 原则) 快速 (Fast)：测试应快速执行。 独立 (Independent)：测试应能独立运行，不依赖外部环境（如数据库、文件系统）。 可重复 (Repeatable)：在相同条件下，测试结果应始终一致。 自我验证 (Self-Validating)：测试应自动判断通过或失败，无需人工检查。 适时 (Timely)：编写测试不应耗费过多不必要的时间。 三、关键概念辨析 Fake (伪对象)：存根（Stub）和模拟（Mock）的统称。 Stub (存根)：为测试提供可控的依赖项替代品，用于“安排”（Arrange）阶段，不用于断言。 Mock (模拟)：一种特殊的伪对象，其交互（如方法是否被调用）是测试断言（Assert）的一部分。 关键区别：如果在 Assert 阶段检查了该对象的状态或行为，它就是 Mock；否则，它就是 Stub。正确使用术语能避免团队误解。 四、核心最佳做法 遵循命名规范 测试名称应清晰表达三要素：被测方法、测试场景、预期结果。 例如：Add_EmptyString_ReturnsZero 比 Test_Single 更具描述性。 使用“排列-操作-断言” (Arrange-Act-Assert) 模式 Arrange (安排)：创建并配置对象和依赖项。 Act (操作)：调用被测方法。 Assert (断言)：验证结果是否符合预期。 此模式提升测试的可读性和结构清晰度。 编写最简通过测试 使用最简单、最小的数据来验证行为。例如，测试单个数字相加，用 \"0\" 比用 \"42\" 更能体现“最简”原则，减少不必要的复杂性。 避免“魔法字符串” (Magic Strings) 避免在测试中直接硬编码意义不明的值。应将其定义为有明确含义的常量。 例如：将 \"1001\" 定义为 const string MAXIMUM_RESULT = \"1001\";。 避免在测试中编写逻辑 测试代码中应尽量避免 if, for, while 等逻辑控制语句，以防止测试本身出现 Bug。 如果需要测试多种情况，应使用参数化测试（如 xUnit 的 [Theory] 和 [InlineData]），而不是在单个测试中用循环。 使用帮助程序方法，而非 Setup/Teardown 优先使用自定义的帮助方法来创建测试对象，而不是依赖测试框架的全局 Setup 方法。这能提高测试的可读性，避免不必要的共享状态和过度/不足的初始化。 避免单个测试包含多个 Act 操作 一个测试应只关注一个行为。如果一个测试中有多个 Act，应将其拆分为多个独立测试或使用参数化测试。这能确保测试失败时能精确定位问题。 通过公共方法测试私有方法 通常不需要为 private 方法编写直接的单元测试。应通过测试调用它的公共方法来间接验证其行为，因为私有方法的实现细节可能变化，而公共方法的行为才是最终的契约。 使用“接缝” (Seams) 处理静态依赖 当代码依赖静态调用（如 DateTime.Now）时，难以进行控制和测试。解决方案是引入“接缝”，即通过依赖注入将静态调用封装在接口中，然后在测试时用 Stub/Mock 替换，从而完全控制其返回值。 总结 该文档强调，优秀的单元测试不仅是验证代码正确性的工具，更是高质量的、可维护的活文档。关键在于写出可读性强、独立、稳定且专注的测试。遵循上述最佳实践，可以构建一个可靠的测试套件，从而增强代码质量、提升开发效率并有效防止回归。"
  },
  "docs/Testing/Nunit.html": {
    "href": "docs/Testing/Nunit.html",
    "title": "| CZQDocs",
    "summary": "Nunit 功能介绍 NUnit 是一个流行的开源单元测试框架，专为 .NET 平台设计。它提供了一套丰富的功能，帮助开发者编写、组织和运行单元测试，从而提高代码质量和可靠性。以下是 NUnit 的一些主要功能： 丰富的断言库 NUnit 提供了多种断言方法，允许开发者验证代码行为是否符合预期。例如，Assert.AreEqual、Assert.IsTrue、Assert.Throws 等，覆盖了各种常见的测试场景。 [Test] public void TestAddition() { int result = Calculator.Add(2, 3); Assert.AreEqual(5, result); } 灵活的测试组织 NUnit 支持通过属性（Attributes）来组织测试用例。开发者可以使用 [TestFixture] 来定义测试类，使用 [Test] 来标记测试方法，还可以使用 [SetUp] 和 [TearDown] 来进行测试前后的初始化和清理工作。 [SetUp]作用：在测试方法执行之前执行，通常用于初始化测试环境。 [TearDown] 作用：在测试方法执行之后执行，通常用于清理测试环境。 [TestFixture] public class CalculatorTests { private Calculator calculator; [SetUp] public void Setup() { calculator = new Calculator(); } [Test] public void TestAddition() { int result = calculator.Add(2, 3); Assert.AreEqual(5, result); } [TearDown] public void Teardown() { // 清理资源 } } 参数化测试 NUnit 支持参数化测试，允许开发者使用不同的输入数据运行同一个测试方法。可以使用 [TestCase] 属性来定义多个测试用例。 [Test] [TestCase(2, 3, 5)] [TestCase(-1, 1, 0)] [TestCase(0, 0, 0)] public void TestAddition(int a, int b, int expected) { int result = calculator.Add(a, b); Assert.AreEqual(expected, result); } 并行测试执行 NUnit 支持并行执行测试用例，能够显著减少测试运行时间。开发者可以通过配置属性来启用并行测试。 [TestFixture] [Parallelizable(ParallelScope.All)] public class CalculatorTests { // 测试方法 } 测试结果报告 NUnit 提供了多种格式的测试结果报告，方便开发者查看测试结果和分析失败原因。可以生成 XML、HTML 等格式的报告。 nunit3-console.exe MyTests.dll --result=TestResult.xml;format=nunit2 集成支持 NUnit 可以与多种持续集成工具（如 Jenkins、Azure DevOps、GitHub Actions 等）集成，方便自动化测试流程。 - name: Run NUnit Tests run: | dotnet test MyTests.csproj --logger \"trx;LogFileName=test_results.trx\" 扩展性 NUnit 提供了丰富的扩展点，允许开发者创建自定义的断言、属性和测试运行器，以满足特定的测试需求。 public class CustomAssert { public static void IsPositive(int value) { Assert.IsTrue(value > 0, \"Value should be positive\"); } } Assert的断言方法 在 NUnit 新的约束模型中，Assert 类提供了多种断言方法用于验证测试条件。以下是常用的断言方法分类和说明： Assert.Multiple Assert.Multiple NUnit 提供了一个名为 Assert.Multiple 的方法，允许在单个测试方法中运行多个断言。其作原理是，在测试方法中，使用 Assert.Multiple 方法包裹多个断言，然后使用 Assert.Multiple.End 方法结束。区别于单个断言，多个断言可以一起运行，如果其中某个断言失败，则整个测试方法会失败。 基本断言 Assert.That(actual, Is.EqualTo(expected)) - 验证两个值是否相等 Assert.That(actual, Is.Not.EqualTo(expected)) - 验证两个值是否不相等 Assert.That(actual, Is.SameAs(expected)) - 验证两个对象是否引用同一个实例 Assert.That(actual, Is.Not.SameAs(expected)) - 验证两个对象是否引用不同实例 Assert.That(object, Is.Null) - 验证对象是否为 null Assert.That(object, Is.Not.Null) - 验证对象是否不为 null Assert.That(condition, Is.True) - 验证条件是否为 true Assert.That(condition, Is.False) - 验证条件是否为 false 数值比较断言 Assert.That(value, Is.GreaterThan(expected)) - 验证值是否大于期望值 Assert.That(value, Is.GreaterThanOrEqualTo(expected)) - 验证值是否大于等于期望值 Assert.That(value, Is.LessThan(expected)) - 验证值是否小于期望值 Assert.That(value, Is.LessThanOrEqualTo(expected)) - 验证值是否小于等于期望值 Assert.That(value, Is.InRange(min, max)) - 验证值是否在指定范围内 字符串断言 Assert.That(actual, Does.Contain(expected)) - 验证字符串是否包含指定子串 Assert.That(actual, Does.StartWith(expected)) - 验证字符串是否以指定前缀开始 Assert.That(actual, Does.EndWith(expected)) - 验证字符串是否以指定后缀结束 Assert.That(actual, Is.EqualTo(expected).IgnoreCase) - 验证字符串是否相等（忽略大小写） Assert.That(actual, Does.Not.Contain(unexpected)) - 验证字符串是否不包含指定子串 集合断言 Assert.That(collection, Is.EquivalentTo(expected)) - 验证两个集合是否包含相同元素 Assert.That(collection, Contains.Item(element)) - 验证集合是否包含指定元素 Assert.That(collection, Does.Not.Contain(element)) - 验证集合是否不包含指定元素 Assert.That(collection, Is.Empty) - 验证集合是否为空 Assert.That(collection, Is.Not.Empty) - 验证集合是否不为空 Assert.That(collection, Has.Count.EqualTo(expected)) - 验证集合元素数量 文件断言 Assert.That(file, Does.Exist) - 验证文件是否存在 Assert.That(file, Does.Not.Exist) - 验证文件是否不存在 异常断言 Assert.That(code, Throws.TypeOf<ExceptionType>()) - 验证代码是否抛出指定类型的异常 Assert.That(code, Throws.Nothing) - 验证代码是否不抛出异常 Assert.That(code, Throws.Exception.With.Message.Contains(expected)) - 验证异常消息 逻辑组合断言 Assert.That(actual, Is.Not.EqualTo(unexpected)) - 逻辑非 Assert.That(actual, Is.GreaterThan(min).And.LessThan(max)) - 逻辑与 Assert.That(actual, Is.LessThan(min).Or.GreaterThan(max)) - 逻辑或 这些断言方法使用 NUnit 的约束模型，提供了更自然的语法和更好的错误消息，帮助开发者编写更具表达力的单元测试。 这些断言方法可以帮助开发者编写全面的单元测试，验证各种条件和场景。 总结 NUnit 是一个功能强大且灵活的单元测试框架，提供了丰富的功能来支持各种测试需求。通过使用 NUnit，开发者可以更轻松地编写高质量的测试用例，从而提升代码的可靠性和维护性。"
  },
  "docs/字符串/JSON.html": {
    "href": "docs/字符串/JSON.html",
    "title": "| CZQDocs",
    "summary": "在 .NET 中，JSON 序列化是将 .NET 对象转换为 JSON 字符串，以及将 JSON 字符串转换为 .NET 对象的过程。.NET 提供了多种 JSON 序列化库，最常用的是 System.Text.Json 和 Newtonsoft.Json（也称为 Json.NET）。 以下是关于这两种主流库的简要介绍和使用示例： System.Text.Json（推荐，现代 .NET 的首选） 这是 .NET Core 3.0+ 内置的高性能 JSON 库，位于 System.Text.Json 命名空间中。它是跨平台的，性能优秀，且与 .NET 生态深度集成。 基本用法 using System; using System.Text.Json; public class Person { public string Name { get; set; } public int Age { get; set; } } class Program { static void Main() { // 序列化对象为 JSON var person = new Person { Name = \"Alice\", Age = 30 }; string json = JsonSerializer.Serialize(person); Console.WriteLine(json); // 输出: {\"Name\":\"Alice\",\"Age\":30} // 反序列化 JSON 为对象 string jsonInput = \"{\\\"Name\\\":\\\"Bob\\\",\\\"Age\\\":25}\"; Person person2 = JsonSerializer.Deserialize<Person>(jsonInput); Console.WriteLine(person2.Name); // 输出: Bob } } 高级选项 你可以通过 JsonSerializerOptions 控制序列化行为： var options = new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase, // 属性名转为 camelCase WriteIndented = true // 格式化输出 }; string json = JsonSerializer.Serialize(person, options); 属性映射 使用 [JsonPropertyName] 特性指定 JSON 属性名： csharp public class Person { [JsonPropertyName(\"full_name\")] public string Name { get; set; } } Newtonsoft.Json（Json.NET，广泛使用） 这是最流行的第三方 JSON 库，功能非常强大，支持更复杂的场景（如动态对象、LINQ to JSON 等）。 安装 通过 NuGet 安装： bash Install-Package Newtonsoft.Json 基本用法 using Newtonsoft.Json; // 序列化 string json = JsonConvert.SerializeObject(person); // 反序列化 Person person = JsonConvert.DeserializeObject<Person>(json); 高级功能 支持 JsonProperty 特性 支持 JsonObject、JObject 等动态解析 更灵活的日期格式、空值处理等 public class Person { [JsonProperty(\"full_name\")] public string Name { get; set; } } `` 如何选择？ 特性 System.Text.Json Newtonsoft.Json ------ --------------------- ------------------- 性能 更快 稍慢 内置 .NET 3.0+ 需要 NuGet 包 功能丰富度 基础功能完善 功能更全面 兼容性 推荐新项目 旧项目或复杂需求 建议：新项目优先使用 System.Text.Json，除非需要 Newtonsoft.Json 的特定功能（如 ShouldSerializeXxx 方法、部分动态特性等）。 注意事项 确保类的属性有 public 的 getter 和 setter。 处理循环引用时需配置选项。 注意日期、枚举、空值的序列化行为。 如果你有具体的序列化需求（如日期格式、忽略属性、自定义转换器等），可以进一步说明，我可以提供更详细的代码示例。"
  },
  "docs/字符串/Newtonsoft.Json.html": {
    "href": "docs/字符串/Newtonsoft.Json.html",
    "title": "| CZQDocs",
    "summary": "Newtonsoft.Json（Json.NET）库的详细讲解，涵盖 日期格式、忽略属性 和 自定义转换器（Custom Converter） 的用法。 日期格式 (Date Formatting) 在 Newtonsoft.Json 中，有多种方式可以控制 DateTime 类型的序列化格式。 方法一：使用 JsonSerializerSettings 全局设置（推荐） using Newtonsoft.Json; var settings = new JsonSerializerSettings { Formatting = Formatting.Indented, // 美化输出 DateFormatString = \"yyyy-MM-dd HH:mm:ss\", // 自定义日期格式 DateTimeZoneHandling = DateTimeZoneHandling.Unspecified, // 保持原始时区信息 NullValueHandling = NullValueHandling.Ignore // 忽略 null 值 }; // 序列化 string json = JsonConvert.SerializeObject(yourObject, settings); ✅ 优点：全局统一，代码简洁。 方法二：使用 [JsonConverter] 特性（属性级别） using Newtonsoft.Json; using Newtonsoft.Json.Converters; public class Event { public string Name { get; set; } [JsonConverter(typeof(DateFormatConverter), \"dd/MM/yyyy\")] public DateTime StartDate { get; set; } } ⚠️ 注意：DateFormatConverter 是 Newtonsoft.Json 内置的转换器，但仅适用于 DateTime，且不支持 DateTime?。 方法三：自定义 DateTime 转换器（最灵活） using Newtonsoft.Json; using System; public class CustomDateTimeConverter : JsonConverter<DateTime> { private const string Format = \"yyyy年MM月dd日 HH:mm\"; public override void WriteJson(JsonWriter writer, DateTime value, JsonSerializer serializer) { writer.WriteValue(value.ToString(Format)); } public override DateTime ReadJson(JsonReader reader, Type objectType, DateTime existingValue, bool hasExistingValue, JsonSerializer serializer) { var value = reader.Value?.ToString(); return DateTime.ParseExact(value, Format, null); } } public class Event { public string Name { get; set; } [JsonConverter(typeof(CustomDateTimeConverter))] public DateTime StartDate { get; set; } } 忽略属性 (Ignoring Properties) 方法一：[JsonIgnore] —— 无条件忽略 csharp public class User { public string Name { get; set; } [JsonIgnore] // 永远不会序列化 public string Password { get; set; } public int Age { get; set; } } 方法二：[JsonProperty] + NullValueHandling public class Product { public string Name { get; set; } [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public string Description { get; set; } [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public int Stock { get; set; } = 0; } NullValueHandling.Ignore：当值为 null 时忽略该属性。 DefaultValueHandling.Ignore：当值为默认值（如 0, false）时忽略。 方法三：条件性忽略方法（ShouldSerializeXxx） public class Person { public string Name { get; set; } public string Email { get; set; } // 只有当 Email 不为 null 时才序列化 public bool ShouldSerializeEmail() { return !string.IsNullOrEmpty(Email); } } ✅ 这是 Newtonsoft.Json 特有的强大功能，System.Text.Json 不支持。 方法四：使用 JsonProperty 控制序列化行为 public class Order { [JsonProperty(Required = Required.Always)] // 反序列化时必须存在 public string OrderId { get; set; } [JsonProperty(Required = Required.AllowNull)] // 允许为 null public string Status { get; set; } } 自定义转换器（Custom Converter） Newtonsoft.Json 的自定义转换器非常灵活，适用于复杂类型、枚举、集合等。 示例：将枚举序列化为字符串名称 步骤 1：定义枚举 public enum Status { Pending, Approved, Rejected } public class Order { public string Id { get; set; } public Status Status { get; set; } } 步骤 2：创建自定义转换器 using Newtonsoft.Json; using System; public class EnumToStringConverter : JsonConverter { public override bool CanConvert(Type objectType) { return objectType.IsEnum; } public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) { writer.WriteValue(value.ToString()); } public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) { var value = reader.Value?.ToString(); return Enum.Parse(objectType, value, true); // 忽略大小写 } } ⚠️ 注意：JsonConverter（无泛型）需要重写 CanConvert 方法。 步骤 3：使用方式 方式 A：在属性上使用 public class Order { public string Id { get; set; } [JsonConverter(typeof(EnumToStringConverter))] public Status Status { get; set; } } 方式 B：在 JsonSerializerSettings 中注册 var settings = new JsonSerializerSettings(); settings.Converters.Add(new EnumToStringConverter()); settings.Formatting = Formatting.Indented; string json = JsonConvert.SerializeObject(order, settings); 更复杂示例：处理 TimeSpan public class TimeSpanConverter : JsonConverter<TimeSpan> { public override void WriteJson(JsonWriter writer, TimeSpan value, JsonSerializer serializer) { writer.WriteValue(value.ToString(@\"hh\\:mm\\:ss\")); } public override TimeSpan ReadJson(JsonReader reader, Type objectType, TimeSpan existingValue, JsonSerializer serializer) { return TimeSpan.Parse(reader.Value.ToString()); } } 总结：Newtonsoft.Json vs System.Text.Json 功能 Newtonsoft.Json System.Text.Json 自定义日期格式 DateFormatString 或 [JsonConverter] 必须自定义 JsonConverter 忽略属性 [JsonIgnore], [JsonProperty], ShouldSerializeXxx [JsonIgnore], DefaultIgnoreCondition 条件忽略 ✅ ShouldSerializeXxx() 方法 ❌ 不支持 自定义转换器 灵活，支持泛型和非泛型 仅支持泛型 JsonConverter 性能 较慢 更快 功能丰富度 极其丰富 基础功能完善 推荐实践 如果你已经使用 Newtonsoft.Json，可以继续使用它，特别是需要 ShouldSerializeXxx 或复杂转换逻辑时。 如果是新项目，建议优先尝试 System.Text.Json，性能更好，集成更紧密。 混合使用也是可行的（例如在 ASP.NET Core 中全局用 System.Text.Json，局部用 Newtonsoft.Json 处理复杂类型）。 如果你有具体的类型或格式需求（如 Guid 转小写、decimal 格式化等），我可以提供对应的 Newtonsoft.Json 自定义转换器示例。"
  },
  "docs/字符串/System.Text.Json.html": {
    "href": "docs/字符串/System.Text.Json.html",
    "title": "| CZQDocs",
    "summary": "日期格式 (Date Formatting) 默认情况下，System.Text.Json 会使用 ISO 8601 格式（如 \"2025-10-31T16:46:00Z\"）来序列化 DateTime 类型。但很多时候我们希望使用更易读或符合特定规范的格式。 方法一：通过 JsonSerializerOptions 全局设置 using System; using System.Text.Json; var options = new JsonSerializerOptions { WriteIndented = true, // 设置日期格式为 \"yyyy-MM-dd HH:mm:ss\" Converters = { new DateTimeConverter() } }; // 示例类 public class Event { public string Title { get; set; } public DateTime OccurredAt { get; set; } } // 使用 var evt = new Event { Title = \"会议\", OccurredAt = DateTime.Now }; string json = JsonSerializer.Serialize(evt, options); Console.WriteLine(json); // 输出: {\"Title\":\"会议\",\"OccurredAt\":\"2025-10-31 16:46:00\"} 方法二：创建自定义 DateTime 转换器 using System; using System.Text.Json; using System.Text.Json.Serialization; public class DateTimeConverter : JsonConverter<DateTime> { private const string Format = \"yyyy-MM-dd HH:mm:ss\"; public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) { return DateTime.ParseExact(reader.GetString(), Format, null); } public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options) { writer.WriteStringValue(value.ToString(Format)); } } ⚠️ 注意：如果 JSON 中的日期字符串格式不匹配，Read 方法会抛出异常。建议在生产环境中添加异常处理。 忽略属性 (Ignoring Properties) 有时我们不希望某些属性被序列化到 JSON 中，比如敏感信息或临时状态。 方法一：使用 [JsonIgnore] 特性 using System.Text.Json.Serialization; public class User { public string Name { get; set; } [JsonIgnore] // 序列化时忽略此属性 public string Password { get; set; } public int Age { get; set; } } var user = new User { Name = \"Alice\", Password = \"secret123\", Age = 30 }; string json = JsonSerializer.Serialize(user); Console.WriteLine(json); // 输出: {\"Name\":\"Alice\",\"Age\":30} —— Password 被忽略 方法二：条件性忽略（[JsonIgnore(Condition = ...)]） 使用 JsonIgnoreCondition 可以根据值是否为 null、默认值或相等来决定是否忽略。 using System.Text.Json.Serialization; public class Product { public string Name { get; set; } [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)] public string Description { get; set; } [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)] public int? Stock { get; set; } // null 时忽略 } 可用条件： Always：总是忽略 Never：从不忽略 WhenWritingNull：当值为 null 时忽略 WhenWritingDefault：当值为默认值（如 0, null, false）时忽略 方法三：全局忽略 null 值 var options = new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull }; 这会全局忽略所有 null 值的属性。 自定义转换器 (Custom Converter) 当默认的序列化行为无法满足需求时（如枚举转字符串、特殊类型处理、兼容旧格式等），可以编写自定义转换器。 示例：将枚举序列化为字符串而不是数字 默认情况下，枚举会被序列化为整数。我们希望它输出为字符串名称。 步骤 1：定义枚举 public enum Status { Pending, Approved, Rejected } public class Order { public string Id { get; set; } public Status Status { get; set; } } 步骤 2：创建自定义转换器 using System; using System.Text.Json; using System.Text.Json.Serialization; public class EnumToStringConverter<T> : JsonConverter<T> where T : struct, Enum { public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) { var value = reader.GetString(); return (T)Enum.Parse(typeof(T), value, true); // 忽略大小写 } public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options) { writer.WriteStringValue(value.ToString()); } } 步骤 3：使用转换器 方式 A：在属性上使用特性 public class Order { public string Id { get; set; } [JsonConverter(typeof(EnumToStringConverter<Status>))] public Status Status { get; set; } } 方式 B：在 JsonSerializerOptions 中注册 csharp var options = new JsonSerializerOptions(); options.Converters.Add(new EnumToStringConverter<Status>()); var order = new Order { Id = \"O001\", Status = Status.Approved }; string json = JsonSerializer.Serialize(order, options); Console.WriteLine(json); // 输出: {\"Id\":\"O001\",\"Status\":\"Approved\"} 更复杂的自定义转换器示例：处理 TimeSpan public class TimeSpanConverter : JsonConverter<TimeSpan> { public override TimeSpan Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) { return TimeSpan.Parse(reader.GetString()); } public override void Write(Utf8JsonWriter writer, TimeSpan value, JsonSerializerOptions options) { writer.WriteStringValue(value.ToString(@\"hh\\:mm\\:ss\")); } } 然后在属性上使用 [JsonConverter(typeof(TimeSpanConverter))]。 总结 需求 推荐方式 日期格式 创建 JsonConverter 并注册到 options.Converters 忽略属性 使用 [JsonIgnore] 或 [JsonIgnore(Condition = ...)] 自定义逻辑 继承 JsonConverter 实现 Read 和 Write 方法 这些技巧可以让你更灵活地控制 JSON 的输入输出，满足 API 兼容性、可读性或性能需求。如果你有具体的类型或格式需求，我可以提供更针对性的转换器代码。"
  },
  "docs/字符串/基本操作.html": {
    "href": "docs/字符串/基本操作.html",
    "title": "| CZQDocs",
    "summary": "下面是对这三种特性及其组合的全面介绍： C# 字符串处理三剑客：@、$ 和 \"\"\" 逐字字符串 (Verbatim Strings) - @ 语法：以 @ 符号开头，后跟双引号包围的字符串。 string path = @\"C:\\Users\\John\\Documents\\file.txt\"; string multiLine = @\"第一行 第二行 第三行\"; 功能： 忽略转义序列：字符串中的反斜杠 \\ 被视为普通字符，不需要转义。这在处理文件路径、正则表达式时非常方便。 支持多行：可以直接换行，换行符会成为字符串的一部分。 限制： 双引号需要转义：如果字符串内部需要包含双引号 \"，必须用两个双引号 \"\" 来表示。 string quote = @\"She said, \"\"Hello!\"\"\"; 格式受限：虽然支持多行，但格式（如缩进）会原样保留，有时不够灵活。 内插字符串 (Interpolated Strings) - $ 语法：以 $ 符号开头，后跟双引号包围的字符串，字符串中使用 {} 包围表达式。 string name = \"Alice\"; int age = 30; string greeting = $\"Hello, {name}! You are {age} years old.\"; // 结果: \"Hello, Alice! You are 30 years old.\" 功能： 嵌入表达式：可以直接在字符串中嵌入变量、属性、方法调用甚至复杂的表达式。 格式化：支持格式说明符。 double price = 123.456; string formatted = $\"Price: {price:C2}\"; // 货币格式，保留两位小数 优势：比 string.Format 或 + 拼接更直观、更易读。 、 原始字符串字面量 (Raw String Literals) - \"\"\" (C# 11+) 如前所述，使用三个双引号 \"\"\" 定界，提供最强大的多行和无转义体验。 组合使用：@、$ 和 \"\"\" 的协同效应 这三种特性可以按特定顺序组合，发挥最大威力。 组合 1: $ + @ (内插 + 逐字) 这是 C# 11 之前的经典组合，用于在逐字字符串中进行内插。 语法：\\(@\"...\" (注意顺序：\\) 在 @ 前) 示例： string directory = \"MyProject\"; string filePath = $@\"C:\\Projects\\{directory}\\config.json\"; // 结果: \"C:\\Projects\\MyProject\\config.json\" string name = \"Bob\"; string sql = $@\" SELECT FROM Users WHERE Name = '{name}' AND Status = 'Active'; \"; 注意：双引号仍需用 \"\" 转义。 组合 2: $ + \"\"\" (内插 + 原始) - 推荐！ C# 11 引入原始字符串后，这是处理复杂内插文本的最佳方式。 语法：\\(\"\"\"...\"\"\" (注意顺序：\\) 在 \"\"\" 前) 优势： 无需转义双引号和反斜杠。 支持多行。 支持内插。 支持修剪。 示例： string userName = \"Alice\"; int minAge = 18; string complexQuery = $\"\"\" SELECT u.Name, u.Email, o.OrderTotal FROM Users u LEFT JOIN Orders o ON u.Id = o.UserId WHERE u.Name LIKE '%{userName}%' AND u.Age >= {minAge} AND u.Status IN ('Active', 'Verified') ORDER BY o.OrderTotal DESC; \"\"\"; // JSON 内插 string status = \"Online\"; string userJson = $\"\"\" {{ \"name\": \"Charlie\", \"status\": \"{status}\", \"lastSeen\": \"{DateTime.UtcNow:O}\" }} \"\"\"; 注意： 修剪：原始字符串会自动移除首尾空白字符。 组合 3: $ + @ + \"\"\" 虽然语法上允许 $@\"\"\"...\"\"\"，但 @ 在原始字符串中是冗余的，因为原始字符串本身就具备逐字特性。直接使用 $\"\"\"...\"\"\" 即可。 对比总结表 特性 语法 多行 无需转义 \\ 无需转义 \" 内插 修剪 推荐场景 :--- :--- :--- :--- :--- :--- :--- :--- 普通字符串 \"...\" ❌ (需 \\n) ❌ ❌ ❌ ❌ 简单单行文本 逐字字符串 @\"...\" ✅ ✅ ❌ (\"\") ❌ ❌ 文件路径、简单多行 内插字符串 $\"...\" ❌ (需 \\n) ❌ ❌ ✅ ❌ 简单内插 逐字内插 $@\"...\" ✅ ✅ ❌ (\"\") ✅ ❌ C# 11 前的复杂内插 原始字符串 \"\"\"...\"\"\" ✅ ✅ ✅ ❌ ✅ 复杂多行文本 (无内插) 原始内插 $\"\"\"...\"\"\" ✅ ✅ ✅ ✅ ✅ C# 11+ 的首选方式 最佳实践建议 C# 11 及以上项目： 对于任何复杂的、多行的、包含引号或反斜杠的字符串（尤其是 JSON、SQL、HTML、正则表达式），优先使用 $\"\"\"...\"\"\"。 它结合了所有优点，代码最清晰。 旧版 C# 项目： 使用 $@\"...\" 作为替代方案。 记住双引号需要用 \"\" 转义。 简单场景： 单行简单文本用 \"...\"。 单行路径用 @\"...\"。 避免混合 @ 和 \"\"\"： $@\"\"\"...\"\"\" 虽然合法，但 @ 是多余的，直接用 $\"\"\"...\"\"\" 更简洁。 总结：$\"\"\"...\"\"\" 是现代 C# 中处理复杂字符串的终极武器。它让你可以像写纯文本一样编写字符串，同时享受内插和格式化的便利，是提升代码可读性和开发效率的利器。 好的，这是关于 C# 原始字符串字面量（Raw String Literals）的详细介绍。 C# 原始字符串字面量 (Raw String Literals) 全面介绍 从 C# 11 开始，C# 引入了原始字符串字面量 (Raw String Literals)。这是一个强大的新特性，旨在解决传统字符串在处理多行文本、包含大量引号或转义字符时的繁琐和易错问题。 什么是原始字符串字面量？ 原始字符串字面量允许你以最接近其最终形式的方式来定义字符串。它使用三个双引号 \"\"\" 作为定界符，字符串的内容被原封不动地包含在这些定界符之间。 核心特点： 多行支持：可以自然地跨越多行。 无需转义：字符串内部的引号 \"、反斜杠 \\、换行符等都不需要使用反斜杠进行转义。 保留格式：字符串的格式（包括缩进和空格）会被精确地保留。 2. 基本语法 string myString = \"\"\" 包含字符串内容的文本 可以跨越多行 \"\"\"; 开始定界符：\"\"\" (三个双引号)。 结束定界符：\"\"\" (三个双引号)，必须独占一行，并且其前面不能有任何空格或制表符（除非使用修剪功能，见下文）。 内容：开始和结束定界符之间的所有字符，包括换行符和空格，都会成为字符串的一部分。 3. 主要优势与应用场景 ✅ 优势 1：简化多行字符串 无需使用 + 拼接或 \\n 换行符。 // C# 11 之前 string poem = \"春风又绿江南岸，\\n\" + \"明月何时照我还？\\n\" + \"举头望明月，\\n\" + \"低头思故乡。\"; // C# 11 使用原始字符串 string poem = \"\"\" 春风又绿江南岸， 明月何时照我还？ 举头望明月， 低头思故乡。 \"\"\"; ✅ 优势 2：无需转义引号 在 JSON、SQL 或包含引号的文本中，再也不用写 \" 了。 // C# 11 之前 - 需要转义引号 string json = \"{\\\"name\\\": \\\"John\\\", \\\"age\\\": 30, \\\"city\\\": \\\"New York\\\"}\"; // C# 11 使用原始字符串 - 引号无需转义 string json = \"\"\"{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}\"\"\"; // 更复杂的 JSON 示例 string complexJson = \"\"\" { \"users\": [ { \"id\": 1, \"name\": \"Alice\", \"preferences\": { \"theme\": \"dark\", \"notifications\": true } } ] } \"\"\"; ✅ 优势 3：简化正则表达式 正则表达式中反斜杠 \\ 非常常见，传统字符串需要写成 \\。 // C# 11 之前 - 每个反斜杠都需要转义 string regexPattern = \"^\\\\d{3}-\\\\d{2}-\\\\d{4}$\"; // 匹配 Social Security Number // C# 11 使用原始字符串 - 反斜杠无需转义 string regexPattern = \"\"\"^\\d{3}-\\d{2}-\\d{4}$\"\"\"; ✅ 优势 4：编写清晰的 SQL 查询 string query = \"\"\" SELECT u.Name, o.OrderDate, o.Total FROM Users u JOIN Orders o ON u.Id = o.UserId WHERE u.Status = 'Active' AND o.OrderDate >= '2023-01-01' ORDER BY o.OrderDate DESC; \"\"\"; 高级功能：修剪 (Trimming) 和控制结束定界符位置 原始字符串字面量支持一个非常实用的功能：通过在结束定界符 \"\"\" 前添加空格或制表符来修剪字符串开头的空白。 规则：编译器会找到所有行（包括结束定界符所在行）开头的公共空白前缀，然后将其从每行中移除。 // 示例 1：修剪左侧空白 string text = \"\"\" 这行有 4 个空格的缩进。 这行有 8 个空格的缩进。 \"\"\"; // 结果字符串： // \"这行有 4 个空格的缩进。\\n 这行有 8 个空格的缩进。\\n\" // 示例 2：将结束定界符与内容对齐（常用） string aligned = \"\"\" SELECT FROM Users WHERE Active = 1 ORDER BY Name; \"\"\"; // 结果字符串： // \"这行有 4 个空格的缩进。\\n 这行有 8 个空格的缩进。\\n\" // 示例 2：将结束定界符与内容对齐（常用） string aligned = \"\"\" SELECT FROM Users WHERE Active = 1 ORDER BY Name; \"\"\"; // 结果字符串： // \"SELECT FROM Users\\nWHERE Active = 1\\nORDER BY Name;\\n\" // （左侧的 16 个空格被修剪掉了） // 示例 3：混合空格和制表符（不推荐，行为可能复杂） // 最好统一使用空格或制表符。 5. 插值 (Interpolation) 支持 原始字符串字面量完全支持字符串插值 $。 string name = \"Alice\"; int age = 30; string message = $\"\"\" Hello, my name is {name}. I am {age} years old. \"\"\"; // 结果: \"Hello, my name is Alice.\\nI am 30 years old.\\n\" 注意：插值表达式 {} 内部仍然遵循正常的 C# 语法，如果需要在插值表达式中使用 \"\"\"，可能需要额外的处理。 6. 注意事项与最佳实践 C# 11 及以上：确保你的项目目标框架支持 C# 11 (.NET 7 或更高版本，或配置了 C# 11)。 结束定界符：结束的 \"\"\" 必须独占一行。如果它和其他字符在同一行，编译器会报错。 修剪行为：理解修剪规则，合理利用它来保持代码美观而不影响字符串内容。 性能：与普通字符串字面量一样，原始字符串字面量也是在编译时确定的，没有运行时性能开销。 可读性：对于简单的单行字符串，传统字符串可能更简洁。原始字符串最适合复杂的多行、高转义需求的场景。 7. 总结 C# 的原始字符串字面量 (\"\"\"...\"\"\") 是一个革命性的特性，它： 极大地提升了处理 JSON、SQL、正则表达式、模板等多行或高转义文本的代码可读性和可维护性。 消除了繁琐的引号和反斜杠转义。 简化了多行字符串的编写。 它是现代 C# 开发中处理复杂字符串文本的首选工具。一旦你开始使用它，就很难再回到传统的字符串拼接和转义方式了。"
  },
  "docs/字符串/比较.html": {
    "href": "docs/字符串/比较.html",
    "title": "| CZQDocs",
    "summary": "首选 StringComparison 枚举 这是最重要、最核心的实践。在调用任何涉及字符串比较的方法时（如 string.Equals, string.Compare, string.StartsWith, string.Contains, string.IndexOf 等），应使用接受 StringComparison 枚举作为参数的重载。 为什么？ 避免歧义：默认的字符串比较行为（通常是区分大小写的序号比较）可能不符合你的业务逻辑。 提高性能：某些比较类型（如 Ordinal）比文化感知比较更快。 增强可读性：代码明确表达了你的意图。 防止错误：尤其是在处理用户输入或跨区域环境时，不正确的比较可能导致安全漏洞或逻辑错误。 常用 StringComparison 成员： 枚举值 含义 推荐场景 :--- :--- :--- Ordinal 区分大小写的序号比较（基于字符的 Unicode 码点）。 首选！ 用于技术性比较，如文件名、URL、GUID、XML 标签、哈希值、字典键等。性能最高。 OrdinalIgnoreCase 不区分大小写的序号比较。 当需要忽略大小写进行技术性比较时（如比较 HTTP 头名称 \"Content-Type\" 和 \"content-type\"）。性能高。 CurrentCulture 基于当前线程的文化设置进行区分大小写的语言学比较。 当需要根据用户的本地化规则对用户可见的字符串进行排序或显示时。 CurrentCultureIgnoreCase 基于当前线程的文化设置进行不区分大小写的语言学比较。 同上，但忽略大小写。 InvariantCulture 基于固定不变的文化（invariant culture）进行区分大小写的语言学比较。 当需要一种与区域无关、稳定一致的比较结果时（例如，在持久化数据或网络协议中）。 InvariantCultureIgnoreCase 基于固定不变的文化进行不区分大小写的语言学比较。 同上，但忽略大小写。 默认选择：Ordinal 或 OrdinalIgnoreCase 微软强烈建议： 对于大多数编程场景，尤其是那些不面向最终用户的、基于技术标识符的比较，请使用 Ordinal 或 OrdinalIgnoreCase。 原因： 性能：序号比较是最快的，因为它直接比较字符的二进制值。 稳定性：结果不会因用户的区域设置而改变。 安全性：避免了因文化差异导致的意外行为。 示例： // ✅ 推荐：使用 StringComparison 明确指定 bool isEqual = string.Equals(str1, str2, StringComparison.Ordinal); bool startsWith = fileName.StartsWith(\"log\\_\", StringComparison.OrdinalIgnoreCase); int index = text.IndexOf(\"ERROR\", StringComparison.OrdinalIgnoreCase); // ❌ 不推荐：依赖默认行为（通常是 Ordinal，但不明确） bool isEqual = str1 == str2; bool startsWith = fileName.StartsWith(\"log\\_\"); // 可能不是你想要的！ 文化感知比较 (CurrentCulture) 的适用场景 仅在以下情况使用 CurrentCulture 或 CurrentCultureIgnoreCase： 比较或排序面向最终用户的文本。 结果将显示给用户，并且需要符合用户的语言习惯。 例如：联系人列表按姓名排序、文档标题搜索等。 // 示例：对用户姓名进行排序 Array.Sort(names, StringComparer.CurrentCulture); 避免使用不带 StringComparison 参数的重载 许多字符串方法有多个重载。应优先选择接受 StringComparison 参数的那个。 // ❌ 避免 if (input.ToLower() == \"yes\") { ... } // ToLower 分配内存，且行为不明确 // ✅ 推荐 if (string.Equals(input, \"yes\", StringComparison.OrdinalIgnoreCase)) { ... } // ❌ 避免 if (path.EndsWith(\".txt\")) { ... } // ✅ 推荐 if (path.EndsWith(\".txt\", StringComparison.OrdinalIgnoreCase)) { ... } 使用 StringComparer 类进行集合操作 当创建基于字符串的集合（如 Dictionary<string, T> 或 HashSet ）时，使用 StringComparer 来指定比较方式。 // 创建一个不区分大小写的字典 var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase) { { \"Key1\", \"Value1\" }, { \"KEY2\", \"Value2\" } }; // 这样可以通过 \"key1\" 或 \"KEY1\" 来访问 Console.WriteLine(dict[\"key1\"]); // 输出 \"Value1\" 6. 注意 == 操作符的行为 string 类型重载了 == 操作符，它执行的是区分大小写的序号比较（相当于 StringComparison.Ordinal）。 可以安全使用 == 进行简单的、区分大小写的相等判断。 但如果有忽略大小写的需求，必须使用 Equals 方法并指定 StringComparison.OrdinalIgnoreCase。 string a = \"Hello\"; string b = \"HELLO\"; Console.WriteLine(a == b); // False (Ordinal) Console.WriteLine(string.Equals(a, b, StringComparison.OrdinalIgnoreCase)); // True 7. 跨平台一致性考虑 在 .NET Framework 和 .NET Core/.NET 5+ 之间，或在不同操作系统上，文化感知比较的结果可能略有差异。如果需要绝对一致的结果，优先使用 Ordinal、OrdinalIgnoreCase 或 InvariantCulture。 总结：微软推荐的检查清单 明确指定：在所有字符串比较操作中，使用 StringComparison 枚举。 默认序号：除非有特定的语言学需求，否则优先选择 StringComparison.Ordinal 或 StringComparison.OrdinalIgnoreCase。 用户界面用文化：仅在向用户显示排序或比较结果时，使用 CurrentCulture。 集合用 StringComparer：为字符串集合指定合适的比较器。 避免旧式方法：不要依赖 ToLower()/ToUpper() 进行比较，这既低效又可能出错。 遵循这些实践，可以确保你的字符串比较代码是高效、正确、安全且可维护的。"
  },
  "docs/异步/ConfigureAwait.html": {
    "href": "docs/异步/ConfigureAwait.html",
    "title": ".NET 中 ConfigureAwait 的最佳实践指南。 | CZQDocs",
    "summary": ".NET 中 ConfigureAwait 的最佳实践指南。 ConfigureAwait 是一个在异步编程中至关重要但又常常被误解或误用的方法。正确使用它可以避免死锁、提升性能，并确保代码的可移植性。 .NET 中 ConfigureAwait(false) 的最佳实践 核心概念：什么是 ConfigureAwait？ 当你 await 一个 Task 时，默认行为（即调用 ConfigureAwait(true) 或不调用）是： 在异步操作完成后，尝试捕获当前的 SynchronizationContext。 如果捕获到了上下文（例如 UI 线程的上下文），则回调（continuation）会在同一个上下文中执行。 如果没有捕获到上下文（例如在控制台应用或 ASP.NET Core 中），则回调会在线程池线程上执行。 ConfigureAwait(false) 的作用就是明确告诉运行时：不要捕获当前的上下文，回调可以在任何线程池线程上执行。 2. 为什么需要 ConfigureAwait(false)？—— 主要风险与收益 风险：UI 应用中的死锁 场景：在 WinForms/WPF/UWP 等 UI 应用中，主线程（UI 线程）有一个特殊的 SynchronizationContext，它负责将工作排队回 UI 线程。 问题：如果在 UI 线程上同步阻塞一个 async 方法（例如错误地使用 .Result 或 .Wait()），而该方法内部 await 了一个需要回到 UI 线程的任务，就会发生死锁。 UI 线程在等待任务完成。 任务完成后需要回到 UI 线程执行回调。 但 UI 线程正被阻塞，无法处理回调。 → 死锁。 解决：在库代码中使用 ConfigureAwait(false)，可以避免回调尝试回到 UI 线程，从而打破死锁循环。 收益：性能提升 捕获和恢复 SynchronizationContext 是有开销的。 在不需要特定上下文的场景下（如大多数非 UI 的逻辑处理），使用 ConfigureAwait(false) 可以避免不必要的上下文切换开销，让回调直接在完成工作的线程上继续执行，提高吞吐量。 3. 最佳实践：何时使用 ConfigureAwait(false)？ 以下是业界广泛接受的最佳实践： ✅ 应该使用 ConfigureAwait(false) 的场景 类库 (Library) 代码中的每一个 await： 这是最重要的规则。如果你编写的是一个通用类库（NuGet 包、共享组件等），你不知道你的代码将在何种上下文中被调用（可能是 ASP.NET Framework, WinForms, WPF, 控制台，还是 ASP.NET Core）。 为了安全性和性能，库代码中的每一个 await 都应使用 ConfigureAwait(false)。 目的： 防止死锁：避免因调用者在 UI 线程上同步阻塞而导致死锁。 提升性能：避免不必要的上下文调度。 保持中立性：不干扰调用者的上下文。 // MyLibrary.cs - 类库代码 public async Task<string> GetDataAsync() { // 即使是在 ASP.NET Core 中，也建议在库中使用 false var response = await httpClient.GetStringAsync(url).ConfigureAwait(false); var processed = await ProcessDataAsync(response).ConfigureAwait(false); return processed; } ASP.NET (Framework) 应用中的“后台”逻辑： 在传统的 ASP.NET (非 Core) 中，存在 AspNetSynchronizationContext，它会将 await 后的回调排回请求上下文队列，这可能影响吞吐量。 在非 UI 更新的业务逻辑层、数据访问层中，使用 ConfigureAwait(false) 可以释放 IIS 工作线程，提高服务器并发能力。 注意：在需要访问 HttpContext.Current 等请求特定状态的地方，可能仍需上下文，需谨慎评估。 ❌ 不应该使用 ConfigureAwait(false) 的场景 UI 应用 (WinForms, WPF, UWP, Blazor Server) 的事件处理程序或 ViewModel 中： 在这些场景中，你通常需要在 await 后更新 UI 控件。 UI 控件只能由创建它们的线程（通常是 UI 线程）访问。 使用 ConfigureAwait(true)（默认行为）可以确保回调回到 UI 线程，让你能安全地更新 UI。 // MainWindow.xaml.cs - WPF 应用 private async void Button_Click(object sender, RoutedEventArgs e) { // 默认行为会回到 UI 线程 var data = await myService.GetDataAsync(); // 假设库内部已用 ConfigureAwait(false) // 这行代码安全地在 UI 线程执行 textBox.Text = data; } 需要访问特定上下文状态的代码： 例如，在 ASP.NET Framework 中，某些操作可能依赖 HttpContext.Current，而它与 AspNetSynchronizationContext 绑定。使用 false 可能导致后续代码无法访问上下文。 已经处于无上下文环境的应用： ASP.NET Core：从设计上就没有 AspNetSynchronizationContext，await 后默认就在线程池线程上继续。因此，在 ASP.NET Core 应用中，ConfigureAwait(false) 不会带来性能提升，因为本来就不会捕获上下文。 控制台应用：通常也没有 SynchronizationContext。 结论：在这些应用中，使用 ConfigureAwait(false) 不是必需的，但也不有害。为了代码一致性或未来可移植性，一些团队仍会选择使用。 实践建议与工具 对库开发者：养成习惯，在写库时，所有 await 都加 .ConfigureAwait(false)。可以借助代码分析工具（如 Microsoft.VisualStudio.Threading.Analyzers）来检查遗漏。 对应用开发者： 如果你在写 UI 应用，关注那些不涉及 UI 更新的 await，考虑是否需要 false（但通常整个方法逻辑都与 UI 相关，所以很少用）。 如果你在写 ASP.NET Core 应用，知道 ConfigureAwait(false) 不是必须的，可以根据团队规范决定是否使用。 永远不要在公共 API 的返回值上使用 ConfigureAwait： ConfigureAwait 返回的是一个 ConfiguredTaskAwaitable，而不是 Task。这会破坏方法签名，让调用者无法正常使用 await 或 ContinueWith 等。ConfigureAwait 应该在 await 表达式内部使用。 5. 总结 场景 是否使用 ConfigureAwait(false) 理由 :--- :--- :--- 通用类库 (Library) ✅ 强烈推荐 防止死锁，提升性能，保持上下文中立 UI 应用 (WPF/WinForms) 的 UI 逻辑 ❌ 避免 需要回到 UI 线程更新控件 ASP.NET Framework 的后台逻辑 ✅ 推荐 提高服务器吞吐量 ASP.NET Core 应用 ⚠️ 可选/无影响 默认无上下文，使用与否无性能差异 控制台应用 ⚠️ 可选/无影响 通常无上下文 核心原则： “库用 false，应用看情况。” 类库为了安全和性能，应普遍使用 ConfigureAwait(false)；而应用程序则根据其类型和具体需求来决定。"
  },
  "docs/异步/ValueTask.html": {
    "href": "docs/异步/ValueTask.html",
    "title": ".NET 中 ValueTask 的全面指南。 | CZQDocs",
    "summary": ".NET 中 ValueTask 的全面指南。 ValueTask 全面指南：超越 Task 的高性能异步选择 在 .NET 的异步编程世界里，Task 和 Task 是长期以来的基石。然而，随着对性能要求的日益提高，特别是在高吞吐量、低延迟的场景下（如 Web 服务器、微服务、游戏服务器），Task 的内存分配开销逐渐成为瓶颈。为了解决这个问题，.NET 引入了 ValueTask 和 ValueTask ，作为 Task 的高性能补充。 本指南将深入探讨 ValueTask 的设计哲学、工作原理、优势、陷阱以及最佳实践。 为什么 (Why) 需要 ValueTask？—— Task 的痛点 Task 是一个引用类型（class）。每次创建一个未完成的 Task 对象（例如，通过 Task.Run 或异步方法中遇到 await 且操作未立即完成时），都会在托管堆 (heap) 上分配内存。 对于频繁执行、快速完成的异步操作，这种分配会带来显著的性能问题： 内存压力：大量的短期 Task 对象会迅速填满内存。 垃圾回收 (GC) 压力：这些短期对象会频繁触发 GC，尤其是 Gen0 垃圾回收，导致 CPU 时间被消耗在内存管理上，而不是业务逻辑上。 性能开销：内存分配和 GC 都是昂贵的操作。 ValueTask 的设计目标就是消除或减少这种高频、短时异步操作的内存分配。 2. 是什么 (What) —— ValueTask 的核心概念 ValueTask 和 ValueTask 是结构体 (struct)，因此是值类型。它们本身存储在栈上（或内联在调用者中），不会在堆上产生分配。 但 ValueTask 并不是凭空产生结果的。它内部通过一个巧妙的设计来实现零分配或低分配： 成功且同步完成的场景： 如果异步操作可以立即、同步地完成（例如，从内存缓存中读取数据，且数据存在），ValueTask 可以直接将结果（或一个表示成功的标记）内联存储在结构体内部。 这种情况下，完全不需要堆分配。 需要异步等待的场景： 如果操作不能立即完成（例如，需要从网络或磁盘读取数据），ValueTask 会包装一个真实的 Task 对象。 这个 Task 对象仍然会在堆上分配，但这是不可避免的，因为需要一个对象来协调异步操作的生命周期。 ValueTask 作为一个轻量级的“外壳”，持有对这个 Task 的引用。 关键点：ValueTask 本身是一个值类型外壳，它根据操作的完成方式，要么直接持有结果（零分配），要么引用一个 Task（一次分配，但这是必须的）。 3. 何时 (When) 使用 ValueTask？—— 最佳实践与场景 ValueTask 并非 Task 的通用替代品。它的使用有明确的适用场景和限制。 应该使用 ValueTask 的场景： 高频调用的 I/O 操作：尤其是那些有很大概率同步完成的操作。 示例：Stream.ReadAsync、Stream.WriteAsync。如果数据已经在缓冲区中，读取可以立即完成，返回一个零分配的 ValueTask 。如果数据不在缓冲区，需要等待 I/O 完成，则返回一个包装了 Task 的 ValueTask 。 自定义异步原语：当你在编写一个可能快速完成的异步方法时。 示例：一个异步缓存查找方法。如果缓存命中，可以立即返回结果，非常适合 ValueTask 。 性能关键路径：在对性能要求极高，且经过分析确认 Task 分配是瓶颈的代码中。 ❌ 不应该使用 ValueTask 的场景： 返回 ValueTask 的方法体中包含了 await： 这是最常见的陷阱！如果你在 async 方法中使用 await，编译器会强制创建一个状态机，这个状态机本身就是一个引用类型，会产生堆分配。此时使用 ValueTask 不会带来任何性能收益，反而增加了复杂性。 ValueTask 的优势在于避免创建 Task 对象，但如果状态机本身就在堆上，省一个 Task 的意义不大。 规则：只有当你能同步返回结果或直接返回一个已存在的 Task 时，ValueTask 才有意义。对于典型的 async/await 方法，坚持使用 Task。 需要多次 await 同一个返回值： ValueTask 不是设计来被多次 await 的。await 一个 ValueTask 会消耗它（内部状态可能改变）。多次 await 可能导致未定义行为或异常。 如果你需要多次检查或等待同一个操作，必须使用 Task，因为 Task 是可以安全地被多次 await 的。 传递给 Task.WhenAll 或 Task.WhenAny： 这些方法期望 Task 对象。虽然有 ValueTask 的重载，但通常不如直接使用 Task 高效或直观。如果需要组合多个操作，考虑是否值得为单个操作使用 ValueTask。 作为方法参数： 将 ValueTask 作为参数传递会迫使它被装箱（因为方法参数是引用），这违背了使用值类型的初衷。应优先使用 Task 作为参数。 ValueTask 的陷阱与注意事项 不可变性：ValueTask 在 await 后不应再被使用。 装箱风险：任何需要将 ValueTask 当作 object 或接口（如 IValueTaskSource）处理的场景都可能导致装箱，产生堆分配。 调试复杂性：由于 ValueTask 可能代表两种不同的内部状态（内联结果或引用 Task），调试时可能不如 Task 直观。 API 设计：公开的 API 是否返回 ValueTask 需要仔细权衡。它向调用者传达了“此方法可能快速完成”的信号，但也增加了调用者的使用复杂性。 5. 总结 Task 是默认选择：对于绝大多数异步方法，特别是包含 await 的 async 方法，始终使用 Task。它简单、安全、语义清晰。 ValueTask 是性能优化工具：它是一个高级工具，用于在特定场景下（高频、可能同步完成的 I/O 操作）减少内存分配和 GC 压力。 核心原则：ValueTask 的价值在于避免不必要的堆分配。如果使用它反而引入了状态机分配或使用上的复杂性，那么它就失去了意义。 简单记忆： “用 Task 写代码，用 ValueTask 优化 I/O。” 在决定使用 ValueTask 之前，务必进行性能分析，确认 Task 分配确实是瓶颈，并且你的使用方式符合最佳实践，避免陷入陷阱。"
  },
  "docs/异步/概念.html": {
    "href": "docs/异步/概念.html",
    "title": "| CZQDocs",
    "summary": "使用 async 和 await 进行异步编程 好的，我们来详细讲解 C# 中的异步编程。这是现代 C# 开发中一个至关重要且强大的特性，它能显著提升应用程序的响应性和可扩展性。 为什么需要异步编程？ 在传统的同步编程模型中，当一个方法执行一个耗时操作（如文件 I/O、网络请求、数据库查询、调用外部 API 等）时，调用线程会一直阻塞，直到该操作完成。 对于桌面应用 (WPF/WinForms)：如果在 UI 线程上执行耗时的同步操作，整个界面会“冻结”，用户无法进行任何交互，体验极差。 对于 Web 应用 (ASP.NET)：服务器处理每个请求通常使用一个线程。如果线程被阻塞在 I/O 操作上，它就无法处理其他请求，导致服务器资源浪费，吞吐量下降。 异步编程的核心目标就是：在等待耗时操作（尤其是 I/O 操作）完成时，不阻塞当前线程，让线程可以去执行其他任务，从而提高资源利用率和程序响应性。 C# 异步编程的核心：async 和 await C# 提供了非常简洁的语法来实现异步编程：async 和 await 关键字。它们是基于 任务 (Task) 模型构建的。 async 关键字 作用：用于修饰一个方法、lambda 表达式或匿名方法，表明该方法是异步的。 位置：放在返回类型之前。 返回类型： Task：用于没有返回值的异步方法（类似于 void）。 Task ：用于有返回值的异步方法，T 是返回值的类型。 ValueTask / ValueTask ：在某些高性能场景下替代 Task，以减少堆分配。 void：仅用于事件处理程序。返回 void 的异步方法很难被调用者跟踪其完成状态和异常，应尽量避免。 注意：async 本身不会使方法异步执行。它只是启用了 await 关键字，并改变了方法的编译方式。 2. await 关键字 作用：等待一个 Task 或 Task 完成。当遇到 await 时，如果任务尚未完成，控制权会立即返回给调用者，不会阻塞线程。一旦任务完成，方法的执行会从 await 之后的代码恢复。 位置：只能在标记为 async 的方法内部使用。 原理：await 实际上是一个“语法糖”。编译器会将 async 方法转换成一个状态机 (State Machine)。当 await 遇到未完成的任务时，状态机会保存当前的上下文（局部变量、执行位置等），然后注册一个回调（continuation），当任务完成后，这个回调会被调度执行，恢复方法的执行。 基本语法示例 using System; using System.Net.Http; using System.Threading.Tasks; class Program { // Main 方法也可以是异步的 (C# 7.1+) static async Task Main(string[] args) { Console.WriteLine(\"开始获取网页内容...\"); // 调用异步方法并等待其完成 string content = await GetWebContentAsync(\"https://www.example.com\"); Console.WriteLine($\"获取到的内容长度: {content.Length}\"); Console.WriteLine(\"程序结束。\"); } // 异步方法：返回 Task<string> static async Task<string> GetWebContentAsync(string url) { // HttpClient 用于发送 HTTP 请求 using var client = new HttpClient(); // await 关键字等待 GetStringAsync 完成 // GetStringAsync 是一个真正的异步 I/O 操作 string content = await client.GetStringAsync(url); // 当 GetStringAsync 完成后，执行会恢复到这里 return content; } } 执行流程分析： Main 开始执行，打印 \"开始获取网页内容...\"。 执行 await GetWebContentAsync(...)，进入 GetWebContentAsync 方法。 在 GetWebContentAsync 中，创建 HttpClient。 执行 await client.GetStringAsync(url)。GetStringAsync 发起一个网络请求，并立即返回一个 Task （表示未来的结果）。 因为 Task 尚未完成，await 操作导致 GetWebContentAsync 方法的执行被“挂起”，控制权返回给 Main 方法。 关键点：此时，执行 Main 的线程（比如主线程）没有被阻塞！它可以去处理其他事情（在控制台应用中可能只是空闲，但在 UI 或 Web 应用中可以处理其他请求或 UI 事件）。 当网络请求完成，GetStringAsync 返回的 Task 变为“已完成”状态，并携带了网页内容。 系统调度 GetWebContentAsync 方法中 await 之后的代码继续执行（即 return content;）。 GetWebContentAsync 方法返回一个已完成的 Task 给 Main。 Main 方法中 await 操作完成，content 变量被赋值，继续执行后续代码。 关键概念深入 线程与异步 误解：“异步 = 多线程”。 真相：异步 I/O 操作（如 HttpClient.GetStringAsync, FileStream.ReadAsync）通常不需要额外的线程来等待 I/O 完成。操作系统会处理底层的 I/O 请求，当数据准备好时，通过回调通知 .NET 运行时。.NET 运行时（通过 ThreadPool）负责调度这些回调。 线程池 (ThreadPool)：await 之后的代码（continuation）默认会在 ThreadPool 的某个线程上执行。这可能导致上下文切换。 ConfigureAwait(false)： 在类库中，为了性能和避免死锁，建议在 await 后使用 .ConfigureAwait(false)。 它告诉运行时：后续的 continuation 不需要回到原始的 SynchronizationContext（比如 UI 线程）。 在 UI 应用或 ASP.NET 的请求上下文中，如果不使用 ConfigureAwait(false)，continuation 会尝试回到原始上下文执行，这可能引起死锁（如果同步等待异步方法）。 // 在类库中推荐写法 string content = await client.GetStringAsync(url).ConfigureAwait(false); 2. 异常处理 异常在异步方法中通过 Task 的 Exception 属性传播。 使用 try-catch 块包裹 await 表达式，可以捕获异步方法中抛出的异常。 csharp static async Task<string> GetWebContentAsync(string url) { try { using var client = new HttpClient(); return await client.GetStringAsync(url); } catch (HttpRequestException ex) { Console.WriteLine($\"HTTP 请求失败: {ex.Message}\"); throw; // 可以选择重新抛出或处理 } catch (TaskCanceledException ex) { Console.WriteLine($\"请求超时: {ex.Message}\"); throw; } } 3. 并发执行多个异步操作 顺序执行：使用 await 一个接一个地调用。 csharp var content1 = await GetWebContentAsync(url1); var content2 = await GetWebContentAsync(url2); // 必须等第一个完成后才开始 并发执行：先启动所有任务，再 await 它们。这样多个 I/O 操作可以同时进行。 csharp // 启动所有任务 (不等待) var task1 = GetWebContentAsync(url1); var task2 = GetWebContentAsync(url2); var task3 = GetWebContentAsync(url3); // 等待所有任务完成 var results = await Task.WhenAll(task1, task2, task3); // results 是一个 string[] 数组 // 或者分别 await var content1 = await task1; var content2 = await task2; var content3 = await task3; Task.WhenAny：等待第一个完成的任务。 csharp var task1 = GetWebContentAsync(url1); var task2 = GetWebContentAsync(url2); var firstCompletedTask = await Task.WhenAny(task1, task2); var result = await firstCompletedTask; // 获取第一个完成的任务的结果 4. 取消异步操作 (CancellationToken) 长时间运行的操作应该支持取消。 csharp static async Task<string> GetWebContentAsync(string url, CancellationToken cancellationToken) { using var client = new HttpClient(); // 将 CancellationToken 传递给支持取消的异步方法 var response = await client.GetAsync(url, cancellationToken); response.EnsureSuccessStatusCode(); var content = await response.Content.ReadAsStringAsync(cancellationToken); return content; } // 调用 var cts = new CancellationTokenSource(); // 可以在某个条件满足时调用 cts.Cancel() 来取消操作 cts.CancelAfter(TimeSpan.FromSeconds(10)); // 10 秒后自动取消 try { string content = await GetWebContentAsync(\"https://slow-website.com\", cts.Token); } catch (OperationCanceledException) { Console.WriteLine(\"操作被取消。\"); } 最佳实践与注意事项 避免 async void：除非是事件处理程序，否则始终返回 Task 或 Task 。async void 无法被 await，异常处理困难。 不要阻塞异步代码：避免在异步方法中使用 .Result 或 .Wait()。这极易导致死锁，尤其是在有 SynchronizationContext 的环境中（如 UI 或 ASP.NET）。 错误做法： public string GetData() { return GetWebContentAsync(\"...\").Result; // 危险！可能导致死锁 } 使用 ConfigureAwait(false)：在编写类库时，为了性能和避免潜在的死锁，await 后应使用 .ConfigureAwait(false)。 正确处理异常：使用 try-catch 包裹 await。 支持取消：为长时间运行的操作提供 CancellationToken 参数。 理解返回类型：明确你的异步方法是返回 Task 还是 Task 。 并发与并行：Task.WhenAll 实现的是并发（concurrency），多个操作重叠执行，但不一定在多个 CPU 核心上并行（parallelism）运行。真正的并行计算通常使用 Parallel 类或 PLINQ。 总结 C# 的 async/await 提供了一种优雅、高效的方式来处理异步操作，特别是 I/O 密集型任务。它通过释放线程来等待 I/O 完成，极大地提高了应用程序的可伸缩性和响应性。理解其背后的 Task 模型、状态机原理以及 SynchronizationContext 的作用，是避免陷阱（如死锁）和编写高质量异步代码的关键。 掌握异步编程是成为一名合格的现代 C# 开发者的必备技能。"
  },
  "index.html": {
    "href": "index.html",
    "title": "个人学习笔记 | CZQDocs",
    "summary": "个人学习笔记 Refer to Markdown for how to write markdown files."
  },
  "软件架构和设计/插件系统.html": {
    "href": "软件架构和设计/插件系统.html",
    "title": "| CZQDocs",
    "summary": "您现在描述的情况触及了现代软件架构中一个非常核心且常见的需求：模块化 (Modularity) 和 按需加载 (On-Demand Loading)。 让我们梳理一下现状和目标： 当前架构 (问题)： 您有多个 WPF 类库（例如 ModuleA.dll, ModuleB.dll, ModuleC.dll），每个代表一个功能模块。 您有一个主 WPF .exe 宿主应用。 宿主应用直接引用了所有这些模块的 .dll 文件。 结果：所有模块在编译时就被“硬编码”进宿主应用。您无法实现： 按功能授权：根据用户的许可证，只启用某些模块。 动态更新：替换或更新单个模块而无需重新部署整个应用。 延迟加载：只在用户需要时才加载某个模块，减少启动时间。 目标架构 (理想)： 宿主应用是轻量级的，只知道如何“发现”和“加载”模块。 功能模块以 .dll 文件的形式存在于一个特定的文件夹（如 Modules/）。 宿主应用在启动时扫描这个文件夹，动态加载 .dll。 宿主应用根据用户的授权信息，决定加载哪些模块。 每个模块可以独立开发、测试、部署和授权。 解决方案：使用插件架构 (Plugin Architecture) 您需要将您的模块从“直接引用的类库”转变为“动态加载的插件”。这可以通过 反射 (Reflection) 和 依赖注入 (DI) 的结合来实现。 核心思想 定义公共契约 (Contracts)：创建一个独立的类库（如 MyApp.Core 或 MyApp.Contracts），其中只包含模块与宿主通信所需的接口和共享模型。 模块实现契约：每个功能模块 (ModuleA, ModuleB) 都引用 Contracts 项目，并实现其中的接口。 宿主发现并加载：宿主应用引用 Contracts 项目，但不直接引用任何 ModuleX.dll。它通过反射从 Modules/ 文件夹加载 .dll，查找实现了特定接口的类型，并创建实例。 集成 DI：在宿主应用的 DI 容器中，为每个加载的模块注册其服务。 详细实现步骤 步骤 1：创建 Contracts 项目 新建一个名为 MyApp.Contracts 的 Class Library 项目。 在其中定义模块与宿主交互的接口。 csharp // 文件: IModule.cs (在 MyApp.Contracts 项目中) /// /// 所有功能模块必须实现的接口。 /// public interface IModule { /// /// 模块的唯一标识符。 /// string Id { get; } /// /// 模块的显示名称。 /// string Name { get; } /// /// 模块的描述。 /// string Description { get; } /// /// 模块的版本。 /// string Version { get; } /// /// 获取此模块提供的菜单项。 /// /// IEnumerable GetMenuItems(); /// /// 此方法由宿主调用，用于注册该模块的服务到 DI 容器。 /// /// The service collection from the host. void RegisterServices(IServiceCollection services); } // 文件: IMenuItem.cs (在 MyApp.Contracts 项目中) /// /// 代表一个菜单项。 /// public interface IMenuItem { string Text { get; } ICommand Command { get; } // 可以添加 Icon, Shortcut 等属性 } 步骤 2：重构功能模块 修改 ModuleA 项目，使其引用 MyApp.Contracts 而不是直接被宿主引用。 csharp // 文件: ModuleA.cs (在 ModuleA 项目中) using MyApp.Contracts; using Microsoft.Extensions.DependencyInjection; public class ModuleA : IModule { public string Id => \"ModuleA\"; public string Name => \"报价管理\"; public string Description => \"处理报价相关的功能。\"; public string Version => \"1.0.0\"; public IEnumerable GetMenuItems() { // 假设您有一个 Command 实现 var command = new RelayCommand(async () => { // 这里可以通过 DI 获取服务 var serviceProvider = ServiceLocator.ServiceProvider; // 或通过其他方式 var viewModel = serviceProvider?.GetService (); var window = new ModuleAWindow { DataContext = viewModel }; window.ShowDialog(); }); return new[] { new MenuItemImpl(\"选取报价表\", command) }; } public void RegisterServices(IServiceCollection services) { // 在这里，您向宿主的 DI 容器注册本模块所需的所有服务 services.AddSingleton<ICadSelectionService, RealCadSelectionService>(); services.AddTransient (); // ... 注册其他服务 } } // 简单的菜单项实现 public class MenuItemImpl : IMenuItem { public string Text { get; } public ICommand Command { get; } public MenuItemImpl(string text, ICommand command) { Text = text; Command = command; } } 步骤 3：重构宿主应用 (WPF .exe) 修改项目引用： 宿主应用 (MyApp.Host) 引用 MyApp.Contracts。 宿主应用 不再直接引用 ModuleA.dll, ModuleB.dll 等。 创建模块加载器： csharp // 文件: ModuleLoader.cs (在宿主应用中) using MyApp.Contracts; using System.Reflection; public class ModuleLoader { private readonly string _modulesPath; public ModuleLoader(string modulesPath = \"Modules\") { _modulesPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, modulesPath); } /// /// 从模块文件夹加载所有实现了 IModule 接口的模块。 /// /// 已加载的模块列表。 public List LoadModules() { var modules = new List (); if (!Directory.Exists(_modulesPath)) { Directory.CreateDirectory(_modulesPath); return modules; } var dllFiles = Directory.GetFiles(_modulesPath, \".dll\"); foreach (var dllFile in dllFiles) { try { // 加载程序集 var assembly = Assembly.LoadFrom(dllFile); // 查找实现了 IModule 接口的公共类型 var moduleTypes = assembly.GetTypes() .Where(t => typeof(IModule).IsAssignableFrom(t) && !t.IsInterface && !t.IsAbstract); foreach (var type in moduleTypes) { // 创建实例 var moduleInstance = (IModule)Activator.CreateInstance(type)!; modules.Add(moduleInstance); } } catch (Exception ex) { // 记录加载失败的模块 Console.WriteLine($\"Failed to load module from {dllFile}: {ex.Message}\"); } } return modules; } } 在宿主应用中集成模块加载和 DI： csharp // 文件: App.xaml.cs (在宿主应用中) using MyApp.Contracts; using Microsoft.Extensions.DependencyInjection; public partial class App : Application { private static ServiceProvider? _serviceProvider; protected override async void OnStartup(StartupEventArgs e) { base.OnStartup(e); var services = new ServiceCollection(); // 1. 注册宿主应用自己的服务 services.AddSingleton<IMainWindow, MainWindow>(); // 2. 加载模块 var moduleLoader = new ModuleLoader(); var allModules = moduleLoader.LoadModules(); // 3. 【关键】根据授权筛选模块 var authorizedModules = FilterModulesByLicense(allModules); // 您需要实现这个方法 // 4. 【关键】让每个授权模块注册自己的服务 foreach (var module in authorizedModules) { module.RegisterServices(services); // 模块将服务添加到宿主的 ServiceCollection } // 5. 构建服务提供者 _serviceProvider = services.BuildServiceProvider(); // 6. 创建主窗口，并将授权的模块列表传递给它（例如通过 ViewModel） var mainWindow = _serviceProvider.GetRequiredService (); var mainViewModel = (MainViewModel)mainWindow.DataContext; mainViewModel.Initialize(authorizedModules); // 让 ViewModel 构建菜单 mainWindow.Show(); } private List FilterModulesByLicense(List allModules) { // TODO: 实现您的授权逻辑 // 例如，读取 license 文件，检查用户是否有权限使用某个模块的 Id // return allModules.Where(m => IsUserAuthorized(m.Id)).ToList(); return allModules; // 暂时返回所有模块 } public static T GetService () where T : class { return _serviceProvider?.GetService () ?? throw new InvalidOperationException($\"Service of type {typeof(T)} not available.\"); } } 步骤 4：部署 编译宿主应用 (MyApp.Host.exe)。 将 ModuleA.dll, ModuleB.dll 等不被直接引用的模块 DLL 文件放入宿主应用目录下的 Modules/ 文件夹中。 运行 MyApp.Host.exe，它将自动发现、加载、根据授权筛选并集成这些模块。 总结 通过这种基于 Contracts + 反射 + DI 的插件架构，您成功实现了： 松耦合：宿主与模块之间通过接口通信。 按需加载：只有被放入 Modules/ 文件夹的 DLL 才会被考虑。 按功能授权：FilterModulesByLicense 方法可以根据任何逻辑（许可证文件、数据库、云服务等）决定启用哪些模块。 独立部署：您可以单独更新 ModuleA.dll 而无需重新编译或部署整个宿主应用。 可扩展性：添加新功能只需开发一个新的模块 DLL 并放入文件夹即可。 这正是大型软件（如 Visual Studio, AutoCAD, Revit）实现插件系统的核心原理。"
  },
  "软件架构和设计/显式依赖项原则.html": {
    "href": "软件架构和设计/显式依赖项原则.html",
    "title": "| CZQDocs",
    "summary": "显式依赖项原则（Explicit Dependencies Principle） “类所需要的所有外部协作对象，都必须通过公开、可观测的方式（通常是构造函数）显式地告诉调用者；禁止在类内部偷偷摸摸地 new、单例、ServiceLocator 等隐式获取。” 只要违反这一点，代码立刻变得难以单元测试、难以替换实现、难以理清依赖关系。下面从 “为什么、长什么样、怎么写、怎么测、常见坑” 五个角度，结合 C# 代码彻底讲透。 一、为什么——隐式依赖的灾难 public class PriceService { private readonly HttpClient _http; // 调用者完全不知道 private readonly ILog _log; // 调用者完全不知道 public PriceService() { _http = new HttpClient(); // 直接 new _log = LogManager.GetLogger<PriceService>(); // 静态单例 } public async Task<decimal> GetPrice(int productId) { _log.Info(\"fetching price\"); var json = await _http.GetStringAsync( $\"http://api.shop.com/prices/{productId}\"); return decimal.Parse(json); } } 问题 测试时必须真的发 HTTP 请求、真的写日志文件——单元测试变集成测试。 想换成 TestServer 或 FakeLogger 做不到，因为创建权在类内部。 阅读 API 时，构造函数没有任何线索，只能“打开源码”才能知道它究竟要啥。 二、长什么样——显式依赖 把依赖全部提到构造函数（或者方法参数，下文再谈），并在接口层面抽象： public interface IPriceGateway { Task<decimal> GetPrice(int productId); } public interface IAppLogger { void Info(string message); } public sealed class PriceService { private readonly IPriceGateway _gateway; private readonly IAppLogger _log; // 所有依赖一目了然 public PriceService(IPriceGateway gateway, IAppLogger log) { _gateway = gateway ?? throw new ArgumentNullException(nameof(gateway)); _log = log ?? throw new ArgumentNullException(nameof(log)); } public async Task<decimal> GetPrice(int productId) { _log.Info($\"Fetching price for {productProductId}\"); return await _gateway.GetPrice(productId); } } 好处 调用者（或 DI 容器）一眼看清：要给我一个 IPriceGateway 和 IAppLogger。 单元测试可以扔 FakePriceGateway、FakeLogger 进去，毫秒级测试。 符合 SOLID 之 DIP（依赖倒置）：高层 PriceService 不依赖低层 HttpClient/Log4Net，而是依赖抽象。 三、怎么写——三种合法注入方式 构造函数注入（最推荐，生命周期与类实例一致） public PriceService(IPriceGateway g, IAppLogger l) { … } 方法注入（依赖只在单个方法用到，或者需要运行时动态传） public async Task<decimal> GetPrice( int productId, CancellationToken ct = default) // 框架传入 属性/字段赋值（仅限“可选依赖”，必须有默认值保护） public IAppLogger Logger { get; set; } = NullLogger.Instance; 四、怎么测——单元测试示范 [Fact] public void Should_return_fake_price() { // Arrange var fakeGateway = new Mock<IPriceGateway>(); fakeGateway.Setup(x => x.GetPrice(1)).ReturnsAsync(99.9m); var fakeLog = new Mock<IAppLogger>(); var svc = new PriceService(fakeGateway.Object, fakeLog.Object); // Act var price = svc.GetPrice(1).GetAwaiter().GetResult(); // Assert Assert.Equal(99.9m, price); } 全程无 HTTP、无日志文件、100 ms 内跑完。 五、常见坑与问答 “构造函数参数太多” → 把相关依赖打包成 IOptions<PriceServiceOptions> 或门面接口，再或者拆分职责。 “我用的是 .NET 6 最小 API，怎么显式？” → 一样构造函数注入： builder.Services.AddScoped<IPriceGateway, HttpPriceGateway>(); builder.Services.AddScoped<IAppLogger, SerilogAdapter>(); app.MapGet(\"/price/{id}\", (int id, PriceService svc) => svc.GetPrice(id)); “静态日志很爽，为什么不行？” → 静态 = 隐式 = 全局状态，测试之间互相污染，且无法替换为 FakeLogger。 “ServiceLocator 好像也能解耦？” → var log = ServiceLocator.Resolve<ILogger>() 依旧把依赖藏进方法体，违反“显式”。 真正可观测的依赖必须出现在类型公开契约里（构造/方法参数）。 六、一句话总结 在 C# 中落地“显式依赖项原则”就是： “能放进构造函数，就别藏到方法体；能抽象成接口，就别直接 new 实现；能让调用者一眼看懂，就别让他翻源码。”"
  }
}