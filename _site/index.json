{
  "docs/ASP-NET-Core/FromBody.html": {
    "href": "docs/ASP-NET-Core/FromBody.html",
    "title": "[FromBody] | MyCSharpDocs",
    "summary": "[FromBody] 模型绑定的 推理规则（Inference Rules） 和 使用限制，这是开发者在设计 Web API 时非常容易踩坑的地方。 下面我将为您 详细、清晰地讲解 这些规则背后的原理和实际影响。 \uD83D\uDD0D 背景：什么是 [FromBody]？ [FromBody] 是一个模型绑定特性，用于告诉 ASP.NET Core： “从 HTTP 请求体（Request Body）中读取数据，并反序列化为指定类型。” 通常用于 POST、PUT 请求，传输 JSON 数据。 json { \"name\": \"Laptop\", \"price\": 999 } ⚠️ 核心原则：每个请求体只能读取一次 HTTP 请求体是一个 流（Stream），只能被读取一次。因此，ASP.NET Core 不允许从请求体绑定多个参数，除非你明确指定方式。 \uD83D\uDCDA [FromBody] 的推理规则详解 ASP.NET Core 会尝试“推断”哪些参数应该从请求体绑定，但这种推理有严格规则。 ✅ 规则 1：简单类型不会自动推断为 [FromBody] ❌ 错误示例： [HttpPost] public IActionResult Create([FromBody] int id) // OK { // ... } ❌ 以下写法不会自动推断： csharp [HttpPost] public IActionResult Create(int id) // ❌ id 不会从 Body 绑定！ { // id 值为 0 } \uD83D\uDD39 原因： int、string、bool 等是 简单类型（primitive types） 框架默认从 查询字符串、路由、表单 绑定简单类型 不会自动从请求体读取简单类型 ✅ 正确做法： [HttpPost] public IActionResult Create([FromBody] int id) { // 必须显式使用 [FromBody] } \uD83D\uDCA1 请求示例： http POST /api/values Content-Type: application/json 42 ⚠️ 注意：发送原始值（如 42）需要启用 AllowSynchronousIO 或使用特殊配置，通常不推荐。更常见的是传对象。 ✅ 规则 2：复杂类型（类、记录等）会自动推断为 [FromBody] ✅ 正确示例： public class Product { public string Name { get; set; } } [HttpPost] public IActionResult Create(Product product) // ✅ 自动推断为 [FromBody] { // product 会从 JSON 请求体中绑定 } \uD83D\uDD39 原因： Product 是 复杂类型（POCO） ASP.NET Core 默认推断：复杂类型参数来自请求体 相当于隐式加了 [FromBody] \uD83D\uDCA1 请求示例： http POST /api/products Content-Type: application/json { \"name\": \"Laptop\" } \uD83D\uDEAB 多参数从 Body 绑定的限制 ❌ 问题：一个请求体，不能绑定多个参数 HTTP 请求体只能被读取一次。因此，不能同时从 Body 绑定两个或多个参数。 ❌ 情况 1：两个复杂类型（无 [FromBody]） csharp [HttpPost] public IActionResult Action1(Product product, Order order) \uD83D\uDD34 结果：❌ 异常！ 错误信息： InvalidOperationException: Cannot bind multiple parameters to the request body. ❌ 为什么？ Product 和 Order 都是复杂类型 框架尝试推断两者都来自 [FromBody] 但只能有一个参数来自 Body 冲突，抛出异常 ❌ 情况 2：一个 [FromBody]，一个复杂类型 [HttpPost] public IActionResult Action2(Product product, [FromBody] Order order) \uD83D\uDD34 结果：❌ 异常！ 错误信息： InvalidOperationException: A method cannot have multiple parameters which are bound from the request body. ❌ 为什么？ order 显式标记为 [FromBody] product 是复杂类型 → 自动推断为 [FromBody] 仍然是 两个参数试图从 Body 绑定 冲突，抛出异常 ❌ 情况 3：两个都显式 [FromBody] [HttpPost] public IActionResult Action3([FromBody] Product product, [FromBody] Order order) \uD83D\uDD34 结果：❌ 同样异常！ 即使你写了两个 [FromBody]，框架仍然不允许。 ❌ 为什么？ 语法上看似“明确”，但底层仍然违反“只能读取一次 Body”的规则 ASP.NET Core 在模型绑定阶段就阻止这种设计 ✅ 正确解决方案：使用包装类（Wrapper Class） 如果你想传多个对象，必须将它们封装在一个类中。 ✅ 正确做法： public class CreateRequest { public Product Product { get; set; } public Order Order { get; set; } } [HttpPost] public IActionResult Create([FromBody] CreateRequest request) { var product = request.Product; var order = request.Order; // 处理逻辑 } \uD83D\uDCA1 请求示例： json { \"product\": { \"name\": \"Laptop\" }, \"order\": { \"quantity\": 2 } } ✅ 其他合法组合（混合来源） 你可以从 不同来源 绑定多个参数，只要 只有一个来自 Body。 ✅ 示例 1：Body + Query csharp [HttpPost] public IActionResult Create( [FromBody] Product product, [FromQuery] string source) { // product 来自 Body // source 来自 ?source=web } 请求：POST /api/products?source=web ✅ 示例 2：Body + Route csharp [HttpPost(\"{userId}\")] public IActionResult Create( [FromBody] Product product, [FromRoute] int userId) { // product 来自 Body // userId 来自路径 } 请求：POST /api/products/123 总结表：哪些写法合法？ 方法签名 是否合法 原因 Create(Product p) ✅ 合法 复杂类型自动推断 [FromBody] Create([FromBody] int id) ✅ 合法 简单类型需显式标注 Create(int id) ❌ 无效 简单类型不会自动从 Body 绑定 Create(Product p, Order o) ❌ 异常 两个复杂类型 → 两个推断 [FromBody] Create(Product p, [FromBody] Order o) ❌ 异常 一个推断 + 一个显式 → 仍是两个 Create([FromBody] p, [FromBody] o) ❌ 异常 显式两个也不行 Create([FromBody] Request req) ✅ 合法 只有一个 Body 参数（包装类） \uD83D\uDCDA 微软官方文档参考 模型绑定文档： https://docs.microsoft.com/zh-cn/aspnet/core/mvc/models/model-binding FromBody 文档部分： 搜索 “[FromBody]” 或 “请求体绑定” ✅ 最佳实践建议 简单类型必须显式使用 [FromBody] 避免多个 Body 参数 使用包装类（DTO）封装多个对象 显式标注 [FromBody] 提高可读性（即使复杂类型可推断） csharp [HttpPost] public IActionResult Create([FromBody] Product product) // 推荐显式 { // ... } 总结 ✅ 您的理解完全正确！ 简单类型（如 int、string）不会自动推断为 [FromBody]，必须显式标注。 复杂类型（如 Product）会自动推断为 [FromBody]。 不能有多个参数来自请求体，否则抛出异常。 正确做法：使用 包装类（DTO） 将多个对象合并为一个。 这正是 ASP.NET Core 为了保证性能和一致性所做的设计约束。"
  },
  "docs/ASP-NET-Core/FromForm.html": {
    "href": "docs/ASP-NET-Core/FromForm.html",
    "title": "您提到的“框架默认从 查询字符串、路由、表单 绑定简单类型”中的 “表单”，指的是 HTTP 请求中的 表单数据（Form Data），通常在 POST 或 PUT 请求中通过 HTML 表单或 application/x-www-form-urlencoded 格式提交。 | MyCSharpDocs",
    "summary": "您提到的“框架默认从 查询字符串、路由、表单 绑定简单类型”中的 “表单”，指的是 HTTP 请求中的 表单数据（Form Data），通常在 POST 或 PUT 请求中通过 HTML 表单或 application/x-www-form-urlencoded 格式提交。 下面我将为您 详细讲解 ASP.NET Core 中“表单类型”的绑定机制，包括其格式、使用方式、与模型绑定的关系，以及实际示例。 什么是“表单类型”？ 在 HTTP 请求中，“表单数据”是指以 键值对（key-value pairs） 形式发送的数据，常见于： HTML 提交 使用 POST 方法提交登录、注册等数据 移动端或前端通过 FormData 对象发送数据 常见的表单 Content-Type： 类型 说明 application/x-www-form-urlencoded 默认的表单编码格式，如：name=john&age=25 multipart/form-data 用于上传文件 + 表单数据，如： text/plain 不常用，原始文本 application/json 不是表单格式，是 JSON 格式 ✅ ASP.NET Core 默认从 application/x-www-form-urlencoded 和 multipart/form-data 中绑定表单数据。 \uD83E\uDDE9 模型绑定如何处理“表单”数据？ ASP.NET Core 的模型绑定系统会自动从表单中提取数据，并绑定到控制器或 Razor Page 的参数或属性上。 绑定优先级（默认顺序）： [FromRoute] → 路由参数（如 /users/123） [FromQuery] → 查询字符串（如 ?name=john） [FromForm] → 表单数据（如 name=john 在 POST Body 中） [FromBody] → JSON/XML 等请求体数据 [FromHeader] → 请求头 ⚠️ 注意：简单类型（如 int、string）默认不会从 [FromBody] 绑定，但会从 [FromForm] 绑定。 ✅ 示例 1：HTML 表单提交（x-www-form-urlencoded） \uD83D\uDCC4 HTML 表单： html 提交 \uD83D\uDCE1 发送的请求： http POST /users/create Content-Type: application/x-www-form-urlencoded name=John&age=30 \uD83D\uDDA5 ASP.NET Core 控制器： [HttpPost(\"create\")] public IActionResult Create(string name, int age) { // name = \"John\" // age = 30 // 框架自动从表单数据绑定 return Ok(new { name, age }); } ✅ 无需任何 [From...] 特性，框架会自动从表单中绑定 name 和 age。 ✅ 示例 2：使用 [FromForm] 显式声明 虽然可以自动推断，但推荐显式使用 [FromForm] 提高可读性： [HttpPost(\"create\")] public IActionResult Create([FromForm] string name, [FromForm] int age) { return Ok(new { name, age }); } ✅ 示例 3：绑定到模型类（复杂类型） public class User { public string Name { get; set; } public int Age { get; set; } } [HttpPost(\"create\")] public IActionResult Create([FromForm] User user) { // user.Name = \"John\" // user.Age = 30 return Ok(user); } ✅ 框架会自动将表单字段 name 和 age 映射到 User 对象的属性。 ✅ 示例 4：文件上传（multipart/form-data） 当表单包含文件时，使用 multipart/form-data。 \uD83D\uDCC4 HTML： html 上传 \uD83D\uDDA5 控制器： [HttpPost(\"upload\")] public async Task<IActionResult> Upload( [FromForm] string name, [FromForm] IFormFile avatar) { if (avatar != null && avatar.Length > 0) { var filePath = Path.Combine(\"uploads\", avatar.FileName); using var stream = new FileStream(filePath, FileMode.Create); await avatar.CopyToAsync(stream); } return Ok(new { name, fileName = avatar.FileName }); } ✅ IFormFile 专门用于接收上传的文件。 ❗ 重要：表单绑定与 JSON 绑定的区别 特性 表单数据（[FromForm]） JSON 数据（[FromBody]） Content-Type application/x-www-form-urlencoded 或 multipart/form-data application/json 数据格式 key=value&key2=value2 { \"key\": \"value\" } 简单类型绑定 ✅ 支持（默认） ❌ 不支持（需显式 [FromBody]） 文件上传 ✅ 支持（multipart） ❌ 不支持 多参数绑定 ✅ 支持（多个简单类型） ❌ 只能一个 [FromBody] 参数 推荐场景 HTML 表单、传统 POST RESTful API、前后端分离 ✅ 如何强制使用 [FromForm]？ 如果你的 API 同时支持 JSON 和 表单，但你想明确只从表单绑定，必须显式使用 [FromForm]： [HttpPost] public IActionResult Create([FromForm] User user) // 只接受表单 { // 如果 Content-Type 是 application/json，绑定会失败 } \uD83D\uDCDA 微软官方文档参考 模型绑定 - FromForm https://docs.microsoft.com/zh-cn/aspnet/core/mvc/models/model-binding#fromform-attribute 上传文件 https://docs.microsoft.com/zh-cn/aspnet/core/mvc/models/file-uploads ✅ 总结 问题 回答 “表单类型”是什么？ 指 application/x-www-form-urlencoded 或 multipart/form-data 格式的请求体 简单类型能从表单绑定吗？ ✅ 能！ string、int 等会自动从表单绑定 需要 [FromForm] 吗？ 可选，但推荐显式使用以提高可读性 能上传文件吗？ ✅ 能，使用 multipart/form-data + IFormFile 和 JSON 绑定冲突吗？ 是，一个请求只能有一种格式，框架根据 Content-Type 选择绑定源 \uD83D\uDCCC 记住： 当你看到 name=john&age=25 在请求体中，这就是“表单类型”，ASP.NET Core 默认会从这里绑定简单类型和复杂类型。"
  },
  "docs/ASP-NET-Core/模型绑定.html": {
    "href": "docs/ASP-NET-Core/模型绑定.html",
    "title": "模型绑定 | MyCSharpDocs",
    "summary": "模型绑定 [FromQuery] 是 ASP.NET Core 中的一个 参数绑定属性（Attribute），它的作用是明确告诉模型绑定系统：这个参数的值应该从 HTTP 请求的查询字符串（Query String）中获取。 ✅ 简单定义 [FromQuery] 指示框架从 URL 的查询字符串部分（即 ? 后面的部分）绑定参数值。 假设你有这样一个 API： [HttpGet(\"search\")] public IActionResult SearchPets([FromQuery] string type, [FromQuery] int page = 1) { // 业务逻辑 return Ok($\"Searching {type} on page {page}\"); } 访问 URL： GET /search?type=dog&page=3 结果： type = \"dog\" page = 3 ✅ 参数成功从查询字符串中绑定。 ✅ FromQuery 的核心作用 作用 说明 \uD83D\uDD39 明确数据来源 告诉框架：“这个参数的值来自查询字符串”，避免歧义 \uD83D\uDD39 提高代码可读性 其他人一眼就知道参数是从 ?xxx=yyy 来的 \uD83D\uDD39 支持复杂类型绑定 可用于绑定数组、集合、自定义对象等 \uD83D\uDD39 可与其他来源区分 区别于 [FromRoute]、[FromBody]、[FromHeader] 等 ✅ 什么时候需要 FromQuery？ ✅ 情况 1：可选参数或筛选条件（最常见） [HttpGet] public IActionResult GetPets([FromQuery] string species, [FromQuery] bool isVaccinated) { // GET /pets?species=cat&isVaccinated=true } 适合用于： 搜索 过滤 分页 排序 ✅ 情况 2：参数名与路由参数冲突或不清晰 [HttpGet(\"{id}\")] public IActionResult GetPet(int id, [FromQuery] int id) // ❌ 错误！冲突 虽然不会这样写，但明确标注来源可以避免混淆。 ✅ 情况 3：绑定数组或集合 [HttpGet(\"batch\")] public IActionResult GetPets([FromQuery] int[] ids) { // GET /batch?ids=1&ids=2&ids=3 // 或 /batch?ids=1,2,3（取决于配置） } 输出：ids = [1, 2, 3] ✅ 必须用 [FromQuery] 明确指定来源。 ✅ 情况 4：绑定复杂对象（查询条件对象） public class PetSearchQuery { public string Type { get; set; } public int? AgeMin { get; set; } public string Breed { get; set; } } [HttpGet(\"search\")] public IActionResult Search([FromQuery] PetSearchQuery query) { // GET /search?type=dog&ageMin=2&breed=labrador // query.Type = \"dog\", query.AgeMin = 2, query.Breed = \"labrador\" } ✅ 这是构建高级搜索 API 的常用方式。 ❓ 不写 [FromQuery] 可以吗？ 在大多数情况下，可以！ ASP.NET Core 会自动尝试从查询字符串绑定简单类型参数（如 string, int, bool 等）。 比如： [HttpGet] public IActionResult GetPets(string type, int page) 访问 /pets?type=cat&page=2 → 也能正常工作。 但是！推荐写 [FromQuery] 的理由： 理由 说明 ✅ 显式优于隐式 代码意图更清晰，符合 Clean Code 原则 ✅ 团队协作友好 新人一看就知道参数来源 ✅ 避免未来问题 如果参数名和路由参数同名，可能出错 ✅ 支持工具识别 Swagger、API 文档生成工具能更好识别 ✅ 对比其他绑定源 属性 来源 示例 [FromQuery] 查询字符串 ?name=john [FromRoute] 路由参数 /pets/123 → {id} [FromBody] 请求体（JSON） POST JSON 数据 [FromHeader] 请求头 Authorization: Bearer xxx [FromForm] 表单数据 application/x-www-form-urlencoded ✅ 总结：[FromQuery] 的作用 明确指定某个参数的值来自 URL 的查询字符串部分（?key=value）。 ✔️ 使用场景： 搜索、过滤、分页 接收多个可选参数 绑定数组或集合 提高代码可读性和维护性 \uD83D\uDCCC 建议： 即使不写也能工作，但建议始终使用 [FromQuery]，尤其是在生产项目中，这是一种良好的 API 设计习惯。 如果你想看更多关于模型绑定的技巧（比如自定义查询参数名、数组绑定格式等），我也可以继续补充！ \uD83D\uDE0A 是的，您的理解完全正确！ \uD83C\uDFAF 我们来详细分析这个例子，确认您的判断。 ✅ 您的代码 [HttpGet(\"{id}\")] public ActionResult<Pet> GetById(int id, bool dogsOnly) ✅ 您的请求 URL https://contoso.com/api/pets/2?DogsOnly=true \uD83D\uDD0D 模型绑定如何工作？ ASP.NET Core 的模型绑定系统会根据 参数名 和 来源优先级 自动尝试从多个来源绑定数据，包括： 路由数据（Route） → {id} 查询字符串（Query） → ?DogsOnly=true 请求体（Body） 请求头（Header） 表单数据（Form） 当没有显式使用 [From...] 特性时，框架会按优先级自动查找。 ✅ 参数绑定结果 参数 类型 值 来源 判断依据 id int 2 ✅ [FromRoute] 参数名 id 与路由模板 {id} 匹配，从路径 /2 绑定 dogsOnly bool true ✅ [FromQuery] 参数名 dogsOnly 与查询参数 DogsOnly=true 匹配（忽略大小写 + 驼峰/帕斯卡命名自动映射） \uD83D\uDD0D 命名匹配说明： dogsOnly (C# 驼峰命名) 与 DogsOnly (URL 帕斯卡命名) 被 ASP.NET Core 自动匹配，因为模型绑定默认不区分大小写，并支持常见命名约定。 ✅ 验证：2 是 [FromRoute]，DogsOnly 是 [FromQuery] 您的说法 是否正确 说明 2 是 [FromRoute] ✅ 正确 id 来自路由 {id} DogsOnly 是 [FromQuery] ✅ 正确 dogsOnly 来自查询字符串 ?DogsOnly=true \uD83D\uDCA1 更清晰的写法（推荐） 虽然框架能自动绑定，但为了提高代码可读性和维护性，建议显式使用 [From...] 特性： [HttpGet(\"{id}\")] public ActionResult<Pet> GetById( [FromRoute] int id, [FromQuery] bool dogsOnly) { // ... } 这样其他开发者一眼就能看出每个参数的来源，避免歧义。 ⚠️ 注意事项 大小写不敏感匹配： dogsOnly 能匹配 DogsOnly、dogsonly、DOGS_ONLY 等，但建议保持命名一致。 布尔值绑定： 查询字符串中的 true/false 能正确绑定到 bool 类型。 可选参数： 如果请求是 /api/pets/2（没有 ?DogsOnly=...），dogsOnly 将使用默认值 false（bool 的默认值）。 如果你想指定默认值： csharp bool dogsOnly = false ✅ 总结 是的，您完全正确！ id = 2 来自 路由 → 相当于 [FromRoute] dogsOnly = true 来自 查询字符串 → 相当于 [FromQuery] 这是 ASP.NET Core 模型绑定的默认行为，它智能地从不同来源绑定参数，无需显式标注（但建议标注以提高可读性）。 \uD83D\uDCCC 官方文档参考： https://docs.microsoft.com/zh-cn/aspnet/core/mvc/models/model-binding"
  },
  "docs/ASP-NET-Core/模型验证.html": {
    "href": "docs/ASP-NET-Core/模型验证.html",
    "title": "介绍 | MyCSharpDocs",
    "summary": "介绍 关于 ModelState.IsValid 以及它在 ASP.NET Core MVC 中如何与数据注释（如 [Required]、[EmailAddress]）配合进行模型验证，微软官方文档提供了非常详细的说明。 ✅ 官方文档地址（推荐）： \uD83D\uDD17 ASP.NET Core 中的模型验证 URL: https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/validation \uD83D\uDCDA 该页面涵盖的核心内容包括： 主题 说明 \uD83D\uDD39 验证属性（如 [Required], [EmailAddress]） 如何使用数据注释进行声明式验证。 \uD83D\uDD39 ModelState.IsValid 如何在控制器中使用它判断模型是否有效。 \uD83D\uDD39 验证错误处理 当验证失败时如何返回视图或返回错误 JSON。 \uD83D\uDD39 客户端验证 如何启用基于 jQuery 的客户端验证（无刷新校验）。 \uD83D\uDD39 自定义验证 创建自定义验证属性或实现 IValidatableObject。 \uD83D\uDD39 复杂类型验证 验证嵌套对象、集合等。 \uD83E\uDDEA 示例代码（来自文档） [HttpPost] public IActionResult Create(Product product) { if (ModelState.IsValid) { // 模型验证通过，保存数据 \\_context.Products.Add(product); \\_context.SaveChanges(); return RedirectToAction(\"Index\"); } // 验证失败，返回视图并显示错误 return View(product); } 你可以在上述文档中找到这个模式的完整解释。 \uD83D\uDD17 其他相关官方链接（可选阅读） 模型绑定概述： https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/model-binding 标记帮助程序中的验证显示（asp-validation-for）： https://learn.microsoft.com/zh-cn/aspnet/core/mvc/views/working-with-forms ✅ 建议 你可以将这个页面（https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/validation）作为 ASP.NET Core 模型验证的权威参考指南，内容全面且持续更新，适用于 ASP.NET Core 3.1 到最新的 .NET 8 版本。 如果你使用的是英文阅读，也可以切换为英文版： \uD83C\uDF10 https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation"
  },
  "docs/EF-Core/创建和配置模型.html": {
    "href": "docs/EF-Core/创建和配置模型.html",
    "title": "创建和配置模型 | MyCSharpDocs",
    "summary": "创建和配置模型 在 EF Core 中，数据注释（Data Annotations） 和 Fluent API 在很多功能上确实可以相互替代，它们都用于对模型进行配置，以覆盖默认的约定。然而，两者在使用方式、灵活性和功能范围上存在一些关键区别。 相同点：可替代性 对于许多常见的配置需求，你既可以用数据注释，也可以用 Fluent API 来实现。例如： 配置目标 数据注释示例 Fluent API 示例 using System.ComponentModel.DataAnnotations; using System.ComponentModel.DataAnnotations.Schema; using Microsoft.EntityFrameworkCore; // 实体类定义 public class Blog { // 主键 [Key] public int Id { get; set; } // 必填字段，最大长度 200 [Required] [MaxLength(200)] public string Url { get; set; } // 导航属性：一对多关系中的“一”端 public ICollection<Post> Posts { get; set; } } public class Post { [Key] public int Id { get; set; } // 外键属性 [ForeignKey(\"BlogId\")] public int BlogId { get; set; } // 导航属性：一对多关系中的“多”端 public Blog Blog { get; set; } } // DbContext 配置 public class BloggingContext : DbContext { public DbSet<Blog> Blogs { get; set; } public DbSet<Post> Posts { get; set; } protected override void OnModelCreating(ModelBuilder modelBuilder) { // 表名映射 modelBuilder.Entity<Blog>().ToTable(\"Blogs\"); // 主键配置 modelBuilder.Entity<Blog>().HasKey(b => b.Id); modelBuilder.Entity<Post>().HasKey(p => p.Id); // 字符串长度/最大长度 modelBuilder.Entity<Blog>().Property(b => b.Url).HasMaxLength(200); // 必填字段 modelBuilder.Entity<Blog>().Property(b => b.Url).IsRequired(); // 关系配置（一对多） modelBuilder.Entity<Post>() .HasOne(p => p.Blog) // Post 有一个 Blog .WithMany(b => b.Posts) // Blog 有多个 Posts .HasForeignKey(p => p.BlogId); // 外键是 Post.BlogId } } 说明： [Key]：指定主键。 [Required]：表示该字段不能为空（对应数据库中的 NOT NULL）。 [MaxLength] / [StringLength]：限制字符串最大长度。 [Table(\"Blogs\")]：将 Blog 实体映射到名为 \"Blogs\" 的数据库表。 [ForeignKey(\"BlogId\")]：显式指定外键属性。 Fluent API：在 OnModelCreating 中使用 modelBuilder 进行更灵活的配置，优先级高于数据注解。 不同点：优势与限制 尽管功能有重叠，但两者在实际使用中各有优劣： ✅ 数据注释（Data Annotations） 优点： 简洁直观，直接写在实体类上，便于快速查看。 适合简单的、与业务逻辑紧密相关的验证规则（如 [Required], [EmailAddress]）。 缺点： 将 EF Core 的依赖引入了实体类，违反了“关注点分离”原则。 功能有限，无法完成一些高级或复杂配置。 不支持所有 Fluent API 的功能。 ⚠️ 注意：某些属性（如 [Column(Order = ...)]）在 EF Core 中已被移除或不支持顺序定义。 ✅ Fluent API 优点： 更强大、更灵活，支持几乎所有模型配置选项。 可以配置数据注释无法完成的内容，例如： 复合主键 索引创建（.HasIndex()） 值转换器（Value Converters） 查询过滤器（Query Filters） 复杂的关系导航配置 属性映射到 JSON 列等 保持实体类“纯净”，不依赖 EF Core 命名空间。 集中管理，在 OnModelCreating 中统一配置，便于维护。 缺点： 写法相对繁琐，代码量较多。 需要跳转到 DbContext 类才能查看完整配置。 推荐实践 大多数现代 EF Core 开发中推荐： ✅ 优先使用 Fluent API 进行模型配置，尤其是在大型项目或需要精细控制时。 \uD83D\uDFE1 数据注释可用于轻量级项目或结合 ASP.NET Core MVC 验证（如 [Required] 同时用于 UI 验证和数据库约束）。 \uD83D\uDD01 混合使用也是常见做法：用数据注释处理简单验证，Fluent API 处理复杂映射。 总结 是的，数据注释和 Fluent API 在部分功能上可以相互替代，比如设置主键、长度、必填等。 但 Fluent API 更强大、更灵活，能做数据注释做不到的事，因此在需要高级配置或追求代码清晰结构时，应优先选用 Fluent API。"
  },
  "docs/GitBash常用命令.html": {
    "href": "docs/GitBash常用命令.html",
    "title": "| MyCSharpDocs",
    "summary": "查找占用 8080 端口的进程 PID netstat -ano | grep :8080 关闭 $ powershell -command \"Stop-Process -Id 12092 -Force\""
  },
  "docs/Markdown.html": {
    "href": "docs/Markdown.html",
    "title": "A First Level Header | MyCSharpDocs",
    "summary": "A First Level Header A Second Level Header Now is the time for all good men to come to the aid of their country. This is just a regular paragraph. The quick brown fox jumped over the lazy dog's back. Header 3 This is a blockquote. This is the second paragraph in the blockquote. This is an H2 in a blockquote Some of these words are emphasized. Some of these words are emphasized also. Use two asterisks for strong emphasis. Or, if you prefer, use two underscores instead. Candy. Gum. Booze. Candy. Gum. Booze. Candy. Gum. Booze. Red Green Blue A list item. With multiple paragraphs. Another item in the list. This is an example link. I get 10 times more traffic from Google than from Yahoo or MSN. I start my morning with a cup of coffee and The New York Times. I strongly recommend against using any <blink> tags. I wish SmartyPants used named entities like &mdash; instead of decimal-encoded entities like &#8212;. int a=1;"
  },
  "docs/Nunit/功能.html": {
    "href": "docs/Nunit/功能.html",
    "title": "| MyCSharpDocs",
    "summary": "Nunit 功能介绍 NUnit 是一个流行的开源单元测试框架，专为 .NET 平台设计。它提供了一套丰富的功能，帮助开发者编写、组织和运行单元测试，从而提高代码质量和可靠性。以下是 NUnit 的一些主要功能： 丰富的断言库 NUnit 提供了多种断言方法，允许开发者验证代码行为是否符合预期。例如，Assert.AreEqual、Assert.IsTrue、Assert.Throws 等，覆盖了各种常见的测试场景。 [Test] public void TestAddition() { int result = Calculator.Add(2, 3); Assert.AreEqual(5, result); } 灵活的测试组织 NUnit 支持通过属性（Attributes）来组织测试用例。开发者可以使用 [TestFixture] 来定义测试类，使用 [Test] 来标记测试方法，还可以使用 [SetUp] 和 [TearDown] 来进行测试前后的初始化和清理工作。 [SetUp]作用：在测试方法执行之前执行，通常用于初始化测试环境。 [TearDown] 作用：在测试方法执行之后执行，通常用于清理测试环境。 [TestFixture] public class CalculatorTests { private Calculator calculator; [SetUp] public void Setup() { calculator = new Calculator(); } [Test] public void TestAddition() { int result = calculator.Add(2, 3); Assert.AreEqual(5, result); } [TearDown] public void Teardown() { // 清理资源 } } 参数化测试 NUnit 支持参数化测试，允许开发者使用不同的输入数据运行同一个测试方法。可以使用 [TestCase] 属性来定义多个测试用例。 [Test] [TestCase(2, 3, 5)] [TestCase(-1, 1, 0)] [TestCase(0, 0, 0)] public void TestAddition(int a, int b, int expected) { int result = calculator.Add(a, b); Assert.AreEqual(expected, result); } 并行测试执行 NUnit 支持并行执行测试用例，能够显著减少测试运行时间。开发者可以通过配置属性来启用并行测试。 [TestFixture] [Parallelizable(ParallelScope.All)] public class CalculatorTests { // 测试方法 } 测试结果报告 NUnit 提供了多种格式的测试结果报告，方便开发者查看测试结果和分析失败原因。可以生成 XML、HTML 等格式的报告。 nunit3-console.exe MyTests.dll --result=TestResult.xml;format=nunit2 集成支持 NUnit 可以与多种持续集成工具（如 Jenkins、Azure DevOps、GitHub Actions 等）集成，方便自动化测试流程。 - name: Run NUnit Tests run: | dotnet test MyTests.csproj --logger \"trx;LogFileName=test_results.trx\" 扩展性 NUnit 提供了丰富的扩展点，允许开发者创建自定义的断言、属性和测试运行器，以满足特定的测试需求。 public class CustomAssert { public static void IsPositive(int value) { Assert.IsTrue(value > 0, \"Value should be positive\"); } } Assert的断言方法 在 NUnit 新的约束模型中，Assert 类提供了多种断言方法用于验证测试条件。以下是常用的断言方法分类和说明： Assert.Multiple Assert.Multiple NUnit 提供了一个名为 Assert.Multiple 的方法，允许在单个测试方法中运行多个断言。其作原理是，在测试方法中，使用 Assert.Multiple 方法包裹多个断言，然后使用 Assert.Multiple.End 方法结束。区别于单个断言，多个断言可以一起运行，如果其中某个断言失败，则整个测试方法会失败。 基本断言 Assert.That(actual, Is.EqualTo(expected)) - 验证两个值是否相等 Assert.That(actual, Is.Not.EqualTo(expected)) - 验证两个值是否不相等 Assert.That(actual, Is.SameAs(expected)) - 验证两个对象是否引用同一个实例 Assert.That(actual, Is.Not.SameAs(expected)) - 验证两个对象是否引用不同实例 Assert.That(object, Is.Null) - 验证对象是否为 null Assert.That(object, Is.Not.Null) - 验证对象是否不为 null Assert.That(condition, Is.True) - 验证条件是否为 true Assert.That(condition, Is.False) - 验证条件是否为 false 数值比较断言 Assert.That(value, Is.GreaterThan(expected)) - 验证值是否大于期望值 Assert.That(value, Is.GreaterThanOrEqualTo(expected)) - 验证值是否大于等于期望值 Assert.That(value, Is.LessThan(expected)) - 验证值是否小于期望值 Assert.That(value, Is.LessThanOrEqualTo(expected)) - 验证值是否小于等于期望值 Assert.That(value, Is.InRange(min, max)) - 验证值是否在指定范围内 字符串断言 Assert.That(actual, Does.Contain(expected)) - 验证字符串是否包含指定子串 Assert.That(actual, Does.StartWith(expected)) - 验证字符串是否以指定前缀开始 Assert.That(actual, Does.EndWith(expected)) - 验证字符串是否以指定后缀结束 Assert.That(actual, Is.EqualTo(expected).IgnoreCase) - 验证字符串是否相等（忽略大小写） Assert.That(actual, Does.Not.Contain(unexpected)) - 验证字符串是否不包含指定子串 集合断言 Assert.That(collection, Is.EquivalentTo(expected)) - 验证两个集合是否包含相同元素 Assert.That(collection, Contains.Item(element)) - 验证集合是否包含指定元素 Assert.That(collection, Does.Not.Contain(element)) - 验证集合是否不包含指定元素 Assert.That(collection, Is.Empty) - 验证集合是否为空 Assert.That(collection, Is.Not.Empty) - 验证集合是否不为空 Assert.That(collection, Has.Count.EqualTo(expected)) - 验证集合元素数量 文件断言 Assert.That(file, Does.Exist) - 验证文件是否存在 Assert.That(file, Does.Not.Exist) - 验证文件是否不存在 异常断言 Assert.That(code, Throws.TypeOf<ExceptionType>()) - 验证代码是否抛出指定类型的异常 Assert.That(code, Throws.Nothing) - 验证代码是否不抛出异常 Assert.That(code, Throws.Exception.With.Message.Contains(expected)) - 验证异常消息 逻辑组合断言 Assert.That(actual, Is.Not.EqualTo(unexpected)) - 逻辑非 Assert.That(actual, Is.GreaterThan(min).And.LessThan(max)) - 逻辑与 Assert.That(actual, Is.LessThan(min).Or.GreaterThan(max)) - 逻辑或 这些断言方法使用 NUnit 的约束模型，提供了更自然的语法和更好的错误消息，帮助开发者编写更具表达力的单元测试。 这些断言方法可以帮助开发者编写全面的单元测试，验证各种条件和场景。 总结 NUnit 是一个功能强大且灵活的单元测试框架，提供了丰富的功能来支持各种测试需求。通过使用 NUnit，开发者可以更轻松地编写高质量的测试用例，从而提升代码的可靠性和维护性。"
  },
  "docs/字符串/基本操作.html": {
    "href": "docs/字符串/基本操作.html",
    "title": "| MyCSharpDocs",
    "summary": "下面是对这三种特性及其组合的全面介绍： C# 字符串处理三剑客：@、$ 和 \"\"\" 逐字字符串 (Verbatim Strings) - @ 语法：以 @ 符号开头，后跟双引号包围的字符串。 string path = @\"C:\\Users\\John\\Documents\\file.txt\"; string multiLine = @\"第一行 第二行 第三行\"; 功能： 忽略转义序列：字符串中的反斜杠 \\ 被视为普通字符，不需要转义。这在处理文件路径、正则表达式时非常方便。 支持多行：可以直接换行，换行符会成为字符串的一部分。 限制： 双引号需要转义：如果字符串内部需要包含双引号 \"，必须用两个双引号 \"\" 来表示。 string quote = @\"She said, \"\"Hello!\"\"\"; 格式受限：虽然支持多行，但格式（如缩进）会原样保留，有时不够灵活。 内插字符串 (Interpolated Strings) - $ 语法：以 $ 符号开头，后跟双引号包围的字符串，字符串中使用 {} 包围表达式。 string name = \"Alice\"; int age = 30; string greeting = $\"Hello, {name}! You are {age} years old.\"; // 结果: \"Hello, Alice! You are 30 years old.\" 功能： 嵌入表达式：可以直接在字符串中嵌入变量、属性、方法调用甚至复杂的表达式。 格式化：支持格式说明符。 double price = 123.456; string formatted = $\"Price: {price:C2}\"; // 货币格式，保留两位小数 优势：比 string.Format 或 + 拼接更直观、更易读。 、 原始字符串字面量 (Raw String Literals) - \"\"\" (C# 11+) 如前所述，使用三个双引号 \"\"\" 定界，提供最强大的多行和无转义体验。 组合使用：@、$ 和 \"\"\" 的协同效应 这三种特性可以按特定顺序组合，发挥最大威力。 组合 1: $ + @ (内插 + 逐字) 这是 C# 11 之前的经典组合，用于在逐字字符串中进行内插。 语法：\\(@\"...\" (注意顺序：\\) 在 @ 前) 示例： string directory = \"MyProject\"; string filePath = $@\"C:\\Projects\\{directory}\\config.json\"; // 结果: \"C:\\Projects\\MyProject\\config.json\" string name = \"Bob\"; string sql = $@\" SELECT FROM Users WHERE Name = '{name}' AND Status = 'Active'; \"; 注意：双引号仍需用 \"\" 转义。 组合 2: $ + \"\"\" (内插 + 原始) - 推荐！ C# 11 引入原始字符串后，这是处理复杂内插文本的最佳方式。 语法：\\(\"\"\"...\"\"\" (注意顺序：\\) 在 \"\"\" 前) 优势： 无需转义双引号和反斜杠。 支持多行。 支持内插。 支持修剪。 示例： string userName = \"Alice\"; int minAge = 18; string complexQuery = $\"\"\" SELECT u.Name, u.Email, o.OrderTotal FROM Users u LEFT JOIN Orders o ON u.Id = o.UserId WHERE u.Name LIKE '%{userName}%' AND u.Age >= {minAge} AND u.Status IN ('Active', 'Verified') ORDER BY o.OrderTotal DESC; \"\"\"; // JSON 内插 string status = \"Online\"; string userJson = $\"\"\" {{ \"name\": \"Charlie\", \"status\": \"{status}\", \"lastSeen\": \"{DateTime.UtcNow:O}\" }} \"\"\"; 注意： 修剪：原始字符串会自动移除首尾空白字符。 组合 3: $ + @ + \"\"\" 虽然语法上允许 $@\"\"\"...\"\"\"，但 @ 在原始字符串中是冗余的，因为原始字符串本身就具备逐字特性。直接使用 $\"\"\"...\"\"\" 即可。 对比总结表 特性 语法 多行 无需转义 \\ 无需转义 \" 内插 修剪 推荐场景 :--- :--- :--- :--- :--- :--- :--- :--- 普通字符串 \"...\" ❌ (需 \\n) ❌ ❌ ❌ ❌ 简单单行文本 逐字字符串 @\"...\" ✅ ✅ ❌ (\"\") ❌ ❌ 文件路径、简单多行 内插字符串 $\"...\" ❌ (需 \\n) ❌ ❌ ✅ ❌ 简单内插 逐字内插 $@\"...\" ✅ ✅ ❌ (\"\") ✅ ❌ C# 11 前的复杂内插 原始字符串 \"\"\"...\"\"\" ✅ ✅ ✅ ❌ ✅ 复杂多行文本 (无内插) 原始内插 $\"\"\"...\"\"\" ✅ ✅ ✅ ✅ ✅ C# 11+ 的首选方式 最佳实践建议 C# 11 及以上项目： 对于任何复杂的、多行的、包含引号或反斜杠的字符串（尤其是 JSON、SQL、HTML、正则表达式），优先使用 $\"\"\"...\"\"\"。 它结合了所有优点，代码最清晰。 旧版 C# 项目： 使用 $@\"...\" 作为替代方案。 记住双引号需要用 \"\" 转义。 简单场景： 单行简单文本用 \"...\"。 单行路径用 @\"...\"。 避免混合 @ 和 \"\"\"： $@\"\"\"...\"\"\" 虽然合法，但 @ 是多余的，直接用 $\"\"\"...\"\"\" 更简洁。 总结：$\"\"\"...\"\"\" 是现代 C# 中处理复杂字符串的终极武器。它让你可以像写纯文本一样编写字符串，同时享受内插和格式化的便利，是提升代码可读性和开发效率的利器。 好的，这是关于 C# 原始字符串字面量（Raw String Literals）的详细介绍。 C# 原始字符串字面量 (Raw String Literals) 全面介绍 从 C# 11 开始，C# 引入了原始字符串字面量 (Raw String Literals)。这是一个强大的新特性，旨在解决传统字符串在处理多行文本、包含大量引号或转义字符时的繁琐和易错问题。 什么是原始字符串字面量？ 原始字符串字面量允许你以最接近其最终形式的方式来定义字符串。它使用三个双引号 \"\"\" 作为定界符，字符串的内容被原封不动地包含在这些定界符之间。 核心特点： 多行支持：可以自然地跨越多行。 无需转义：字符串内部的引号 \"、反斜杠 \\、换行符等都不需要使用反斜杠进行转义。 保留格式：字符串的格式（包括缩进和空格）会被精确地保留。 2. 基本语法 string myString = \"\"\" 包含字符串内容的文本 可以跨越多行 \"\"\"; 开始定界符：\"\"\" (三个双引号)。 结束定界符：\"\"\" (三个双引号)，必须独占一行，并且其前面不能有任何空格或制表符（除非使用修剪功能，见下文）。 内容：开始和结束定界符之间的所有字符，包括换行符和空格，都会成为字符串的一部分。 3. 主要优势与应用场景 ✅ 优势 1：简化多行字符串 无需使用 + 拼接或 \\n 换行符。 // C# 11 之前 string poem = \"春风又绿江南岸，\\n\" + \"明月何时照我还？\\n\" + \"举头望明月，\\n\" + \"低头思故乡。\"; // C# 11 使用原始字符串 string poem = \"\"\" 春风又绿江南岸， 明月何时照我还？ 举头望明月， 低头思故乡。 \"\"\"; ✅ 优势 2：无需转义引号 在 JSON、SQL 或包含引号的文本中，再也不用写 \" 了。 // C# 11 之前 - 需要转义引号 string json = \"{\\\"name\\\": \\\"John\\\", \\\"age\\\": 30, \\\"city\\\": \\\"New York\\\"}\"; // C# 11 使用原始字符串 - 引号无需转义 string json = \"\"\"{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}\"\"\"; // 更复杂的 JSON 示例 string complexJson = \"\"\" { \"users\": [ { \"id\": 1, \"name\": \"Alice\", \"preferences\": { \"theme\": \"dark\", \"notifications\": true } } ] } \"\"\"; ✅ 优势 3：简化正则表达式 正则表达式中反斜杠 \\ 非常常见，传统字符串需要写成 \\。 // C# 11 之前 - 每个反斜杠都需要转义 string regexPattern = \"^\\\\d{3}-\\\\d{2}-\\\\d{4}$\"; // 匹配 Social Security Number // C# 11 使用原始字符串 - 反斜杠无需转义 string regexPattern = \"\"\"^\\d{3}-\\d{2}-\\d{4}$\"\"\"; ✅ 优势 4：编写清晰的 SQL 查询 string query = \"\"\" SELECT u.Name, o.OrderDate, o.Total FROM Users u JOIN Orders o ON u.Id = o.UserId WHERE u.Status = 'Active' AND o.OrderDate >= '2023-01-01' ORDER BY o.OrderDate DESC; \"\"\"; 高级功能：修剪 (Trimming) 和控制结束定界符位置 原始字符串字面量支持一个非常实用的功能：通过在结束定界符 \"\"\" 前添加空格或制表符来修剪字符串开头的空白。 规则：编译器会找到所有行（包括结束定界符所在行）开头的公共空白前缀，然后将其从每行中移除。 // 示例 1：修剪左侧空白 string text = \"\"\" 这行有 4 个空格的缩进。 这行有 8 个空格的缩进。 \"\"\"; // 结果字符串： // \"这行有 4 个空格的缩进。\\n 这行有 8 个空格的缩进。\\n\" // 示例 2：将结束定界符与内容对齐（常用） string aligned = \"\"\" SELECT FROM Users WHERE Active = 1 ORDER BY Name; \"\"\"; // 结果字符串： // \"这行有 4 个空格的缩进。\\n 这行有 8 个空格的缩进。\\n\" // 示例 2：将结束定界符与内容对齐（常用） string aligned = \"\"\" SELECT FROM Users WHERE Active = 1 ORDER BY Name; \"\"\"; // 结果字符串： // \"SELECT FROM Users\\nWHERE Active = 1\\nORDER BY Name;\\n\" // （左侧的 16 个空格被修剪掉了） // 示例 3：混合空格和制表符（不推荐，行为可能复杂） // 最好统一使用空格或制表符。 5. 插值 (Interpolation) 支持 原始字符串字面量完全支持字符串插值 $。 string name = \"Alice\"; int age = 30; string message = $\"\"\" Hello, my name is {name}. I am {age} years old. \"\"\"; // 结果: \"Hello, my name is Alice.\\nI am 30 years old.\\n\" 注意：插值表达式 {} 内部仍然遵循正常的 C# 语法，如果需要在插值表达式中使用 \"\"\"，可能需要额外的处理。 6. 注意事项与最佳实践 C# 11 及以上：确保你的项目目标框架支持 C# 11 (.NET 7 或更高版本，或配置了 C# 11)。 结束定界符：结束的 \"\"\" 必须独占一行。如果它和其他字符在同一行，编译器会报错。 修剪行为：理解修剪规则，合理利用它来保持代码美观而不影响字符串内容。 性能：与普通字符串字面量一样，原始字符串字面量也是在编译时确定的，没有运行时性能开销。 可读性：对于简单的单行字符串，传统字符串可能更简洁。原始字符串最适合复杂的多行、高转义需求的场景。 7. 总结 C# 的原始字符串字面量 (\"\"\"...\"\"\") 是一个革命性的特性，它： 极大地提升了处理 JSON、SQL、正则表达式、模板等多行或高转义文本的代码可读性和可维护性。 消除了繁琐的引号和反斜杠转义。 简化了多行字符串的编写。 它是现代 C# 开发中处理复杂字符串文本的首选工具。一旦你开始使用它，就很难再回到传统的字符串拼接和转义方式了。"
  },
  "docs/字符串/比较.html": {
    "href": "docs/字符串/比较.html",
    "title": "| MyCSharpDocs",
    "summary": "首选 StringComparison 枚举 这是最重要、最核心的实践。在调用任何涉及字符串比较的方法时（如 string.Equals, string.Compare, string.StartsWith, string.Contains, string.IndexOf 等），应使用接受 StringComparison 枚举作为参数的重载。 为什么？ 避免歧义：默认的字符串比较行为（通常是区分大小写的序号比较）可能不符合你的业务逻辑。 提高性能：某些比较类型（如 Ordinal）比文化感知比较更快。 增强可读性：代码明确表达了你的意图。 防止错误：尤其是在处理用户输入或跨区域环境时，不正确的比较可能导致安全漏洞或逻辑错误。 常用 StringComparison 成员： 枚举值 含义 推荐场景 :--- :--- :--- Ordinal 区分大小写的序号比较（基于字符的 Unicode 码点）。 首选！ 用于技术性比较，如文件名、URL、GUID、XML 标签、哈希值、字典键等。性能最高。 OrdinalIgnoreCase 不区分大小写的序号比较。 当需要忽略大小写进行技术性比较时（如比较 HTTP 头名称 \"Content-Type\" 和 \"content-type\"）。性能高。 CurrentCulture 基于当前线程的文化设置进行区分大小写的语言学比较。 当需要根据用户的本地化规则对用户可见的字符串进行排序或显示时。 CurrentCultureIgnoreCase 基于当前线程的文化设置进行不区分大小写的语言学比较。 同上，但忽略大小写。 InvariantCulture 基于固定不变的文化（invariant culture）进行区分大小写的语言学比较。 当需要一种与区域无关、稳定一致的比较结果时（例如，在持久化数据或网络协议中）。 InvariantCultureIgnoreCase 基于固定不变的文化进行不区分大小写的语言学比较。 同上，但忽略大小写。 默认选择：Ordinal 或 OrdinalIgnoreCase 微软强烈建议： 对于大多数编程场景，尤其是那些不面向最终用户的、基于技术标识符的比较，请使用 Ordinal 或 OrdinalIgnoreCase。 原因： 性能：序号比较是最快的，因为它直接比较字符的二进制值。 稳定性：结果不会因用户的区域设置而改变。 安全性：避免了因文化差异导致的意外行为。 示例： // ✅ 推荐：使用 StringComparison 明确指定 bool isEqual = string.Equals(str1, str2, StringComparison.Ordinal); bool startsWith = fileName.StartsWith(\"log\\_\", StringComparison.OrdinalIgnoreCase); int index = text.IndexOf(\"ERROR\", StringComparison.OrdinalIgnoreCase); // ❌ 不推荐：依赖默认行为（通常是 Ordinal，但不明确） bool isEqual = str1 == str2; bool startsWith = fileName.StartsWith(\"log\\_\"); // 可能不是你想要的！ 文化感知比较 (CurrentCulture) 的适用场景 仅在以下情况使用 CurrentCulture 或 CurrentCultureIgnoreCase： 比较或排序面向最终用户的文本。 结果将显示给用户，并且需要符合用户的语言习惯。 例如：联系人列表按姓名排序、文档标题搜索等。 // 示例：对用户姓名进行排序 Array.Sort(names, StringComparer.CurrentCulture); 避免使用不带 StringComparison 参数的重载 许多字符串方法有多个重载。应优先选择接受 StringComparison 参数的那个。 // ❌ 避免 if (input.ToLower() == \"yes\") { ... } // ToLower 分配内存，且行为不明确 // ✅ 推荐 if (string.Equals(input, \"yes\", StringComparison.OrdinalIgnoreCase)) { ... } // ❌ 避免 if (path.EndsWith(\".txt\")) { ... } // ✅ 推荐 if (path.EndsWith(\".txt\", StringComparison.OrdinalIgnoreCase)) { ... } 使用 StringComparer 类进行集合操作 当创建基于字符串的集合（如 Dictionary<string, T> 或 HashSet ）时，使用 StringComparer 来指定比较方式。 // 创建一个不区分大小写的字典 var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase) { { \"Key1\", \"Value1\" }, { \"KEY2\", \"Value2\" } }; // 这样可以通过 \"key1\" 或 \"KEY1\" 来访问 Console.WriteLine(dict[\"key1\"]); // 输出 \"Value1\" 6. 注意 == 操作符的行为 string 类型重载了 == 操作符，它执行的是区分大小写的序号比较（相当于 StringComparison.Ordinal）。 可以安全使用 == 进行简单的、区分大小写的相等判断。 但如果有忽略大小写的需求，必须使用 Equals 方法并指定 StringComparison.OrdinalIgnoreCase。 string a = \"Hello\"; string b = \"HELLO\"; Console.WriteLine(a == b); // False (Ordinal) Console.WriteLine(string.Equals(a, b, StringComparison.OrdinalIgnoreCase)); // True 7. 跨平台一致性考虑 在 .NET Framework 和 .NET Core/.NET 5+ 之间，或在不同操作系统上，文化感知比较的结果可能略有差异。如果需要绝对一致的结果，优先使用 Ordinal、OrdinalIgnoreCase 或 InvariantCulture。 总结：微软推荐的检查清单 明确指定：在所有字符串比较操作中，使用 StringComparison 枚举。 默认序号：除非有特定的语言学需求，否则优先选择 StringComparison.Ordinal 或 StringComparison.OrdinalIgnoreCase。 用户界面用文化：仅在向用户显示排序或比较结果时，使用 CurrentCulture。 集合用 StringComparer：为字符串集合指定合适的比较器。 避免旧式方法：不要依赖 ToLower()/ToUpper() 进行比较，这既低效又可能出错。 遵循这些实践，可以确保你的字符串比较代码是高效、正确、安全且可维护的。"
  },
  "docs/异步/ConfigureAwait.html": {
    "href": "docs/异步/ConfigureAwait.html",
    "title": ".NET 中 ConfigureAwait 的最佳实践指南。 | MyCSharpDocs",
    "summary": ".NET 中 ConfigureAwait 的最佳实践指南。 ConfigureAwait 是一个在异步编程中至关重要但又常常被误解或误用的方法。正确使用它可以避免死锁、提升性能，并确保代码的可移植性。 .NET 中 ConfigureAwait(false) 的最佳实践 核心概念：什么是 ConfigureAwait？ 当你 await 一个 Task 时，默认行为（即调用 ConfigureAwait(true) 或不调用）是： 在异步操作完成后，尝试捕获当前的 SynchronizationContext。 如果捕获到了上下文（例如 UI 线程的上下文），则回调（continuation）会在同一个上下文中执行。 如果没有捕获到上下文（例如在控制台应用或 ASP.NET Core 中），则回调会在线程池线程上执行。 ConfigureAwait(false) 的作用就是明确告诉运行时：不要捕获当前的上下文，回调可以在任何线程池线程上执行。 2. 为什么需要 ConfigureAwait(false)？—— 主要风险与收益 风险：UI 应用中的死锁 场景：在 WinForms/WPF/UWP 等 UI 应用中，主线程（UI 线程）有一个特殊的 SynchronizationContext，它负责将工作排队回 UI 线程。 问题：如果在 UI 线程上同步阻塞一个 async 方法（例如错误地使用 .Result 或 .Wait()），而该方法内部 await 了一个需要回到 UI 线程的任务，就会发生死锁。 UI 线程在等待任务完成。 任务完成后需要回到 UI 线程执行回调。 但 UI 线程正被阻塞，无法处理回调。 → 死锁。 解决：在库代码中使用 ConfigureAwait(false)，可以避免回调尝试回到 UI 线程，从而打破死锁循环。 收益：性能提升 捕获和恢复 SynchronizationContext 是有开销的。 在不需要特定上下文的场景下（如大多数非 UI 的逻辑处理），使用 ConfigureAwait(false) 可以避免不必要的上下文切换开销，让回调直接在完成工作的线程上继续执行，提高吞吐量。 3. 最佳实践：何时使用 ConfigureAwait(false)？ 以下是业界广泛接受的最佳实践： ✅ 应该使用 ConfigureAwait(false) 的场景 类库 (Library) 代码中的每一个 await： 这是最重要的规则。如果你编写的是一个通用类库（NuGet 包、共享组件等），你不知道你的代码将在何种上下文中被调用（可能是 ASP.NET Framework, WinForms, WPF, 控制台，还是 ASP.NET Core）。 为了安全性和性能，库代码中的每一个 await 都应使用 ConfigureAwait(false)。 目的： 防止死锁：避免因调用者在 UI 线程上同步阻塞而导致死锁。 提升性能：避免不必要的上下文调度。 保持中立性：不干扰调用者的上下文。 // MyLibrary.cs - 类库代码 public async Task<string> GetDataAsync() { // 即使是在 ASP.NET Core 中，也建议在库中使用 false var response = await httpClient.GetStringAsync(url).ConfigureAwait(false); var processed = await ProcessDataAsync(response).ConfigureAwait(false); return processed; } ASP.NET (Framework) 应用中的“后台”逻辑： 在传统的 ASP.NET (非 Core) 中，存在 AspNetSynchronizationContext，它会将 await 后的回调排回请求上下文队列，这可能影响吞吐量。 在非 UI 更新的业务逻辑层、数据访问层中，使用 ConfigureAwait(false) 可以释放 IIS 工作线程，提高服务器并发能力。 注意：在需要访问 HttpContext.Current 等请求特定状态的地方，可能仍需上下文，需谨慎评估。 ❌ 不应该使用 ConfigureAwait(false) 的场景 UI 应用 (WinForms, WPF, UWP, Blazor Server) 的事件处理程序或 ViewModel 中： 在这些场景中，你通常需要在 await 后更新 UI 控件。 UI 控件只能由创建它们的线程（通常是 UI 线程）访问。 使用 ConfigureAwait(true)（默认行为）可以确保回调回到 UI 线程，让你能安全地更新 UI。 // MainWindow.xaml.cs - WPF 应用 private async void Button_Click(object sender, RoutedEventArgs e) { // 默认行为会回到 UI 线程 var data = await myService.GetDataAsync(); // 假设库内部已用 ConfigureAwait(false) // 这行代码安全地在 UI 线程执行 textBox.Text = data; } 需要访问特定上下文状态的代码： 例如，在 ASP.NET Framework 中，某些操作可能依赖 HttpContext.Current，而它与 AspNetSynchronizationContext 绑定。使用 false 可能导致后续代码无法访问上下文。 已经处于无上下文环境的应用： ASP.NET Core：从设计上就没有 AspNetSynchronizationContext，await 后默认就在线程池线程上继续。因此，在 ASP.NET Core 应用中，ConfigureAwait(false) 不会带来性能提升，因为本来就不会捕获上下文。 控制台应用：通常也没有 SynchronizationContext。 结论：在这些应用中，使用 ConfigureAwait(false) 不是必需的，但也不有害。为了代码一致性或未来可移植性，一些团队仍会选择使用。 实践建议与工具 对库开发者：养成习惯，在写库时，所有 await 都加 .ConfigureAwait(false)。可以借助代码分析工具（如 Microsoft.VisualStudio.Threading.Analyzers）来检查遗漏。 对应用开发者： 如果你在写 UI 应用，关注那些不涉及 UI 更新的 await，考虑是否需要 false（但通常整个方法逻辑都与 UI 相关，所以很少用）。 如果你在写 ASP.NET Core 应用，知道 ConfigureAwait(false) 不是必须的，可以根据团队规范决定是否使用。 永远不要在公共 API 的返回值上使用 ConfigureAwait： ConfigureAwait 返回的是一个 ConfiguredTaskAwaitable，而不是 Task。这会破坏方法签名，让调用者无法正常使用 await 或 ContinueWith 等。ConfigureAwait 应该在 await 表达式内部使用。 5. 总结 场景 是否使用 ConfigureAwait(false) 理由 :--- :--- :--- 通用类库 (Library) ✅ 强烈推荐 防止死锁，提升性能，保持上下文中立 UI 应用 (WPF/WinForms) 的 UI 逻辑 ❌ 避免 需要回到 UI 线程更新控件 ASP.NET Framework 的后台逻辑 ✅ 推荐 提高服务器吞吐量 ASP.NET Core 应用 ⚠️ 可选/无影响 默认无上下文，使用与否无性能差异 控制台应用 ⚠️ 可选/无影响 通常无上下文 核心原则： “库用 false，应用看情况。” 类库为了安全和性能，应普遍使用 ConfigureAwait(false)；而应用程序则根据其类型和具体需求来决定。"
  },
  "docs/异步/ValueTask.html": {
    "href": "docs/异步/ValueTask.html",
    "title": ".NET 中 ValueTask 的全面指南。 | MyCSharpDocs",
    "summary": ".NET 中 ValueTask 的全面指南。 ValueTask 全面指南：超越 Task 的高性能异步选择 在 .NET 的异步编程世界里，Task 和 Task 是长期以来的基石。然而，随着对性能要求的日益提高，特别是在高吞吐量、低延迟的场景下（如 Web 服务器、微服务、游戏服务器），Task 的内存分配开销逐渐成为瓶颈。为了解决这个问题，.NET 引入了 ValueTask 和 ValueTask ，作为 Task 的高性能补充。 本指南将深入探讨 ValueTask 的设计哲学、工作原理、优势、陷阱以及最佳实践。 为什么 (Why) 需要 ValueTask？—— Task 的痛点 Task 是一个引用类型（class）。每次创建一个未完成的 Task 对象（例如，通过 Task.Run 或异步方法中遇到 await 且操作未立即完成时），都会在托管堆 (heap) 上分配内存。 对于频繁执行、快速完成的异步操作，这种分配会带来显著的性能问题： 内存压力：大量的短期 Task 对象会迅速填满内存。 垃圾回收 (GC) 压力：这些短期对象会频繁触发 GC，尤其是 Gen0 垃圾回收，导致 CPU 时间被消耗在内存管理上，而不是业务逻辑上。 性能开销：内存分配和 GC 都是昂贵的操作。 ValueTask 的设计目标就是消除或减少这种高频、短时异步操作的内存分配。 2. 是什么 (What) —— ValueTask 的核心概念 ValueTask 和 ValueTask 是结构体 (struct)，因此是值类型。它们本身存储在栈上（或内联在调用者中），不会在堆上产生分配。 但 ValueTask 并不是凭空产生结果的。它内部通过一个巧妙的设计来实现零分配或低分配： 成功且同步完成的场景： 如果异步操作可以立即、同步地完成（例如，从内存缓存中读取数据，且数据存在），ValueTask 可以直接将结果（或一个表示成功的标记）内联存储在结构体内部。 这种情况下，完全不需要堆分配。 需要异步等待的场景： 如果操作不能立即完成（例如，需要从网络或磁盘读取数据），ValueTask 会包装一个真实的 Task 对象。 这个 Task 对象仍然会在堆上分配，但这是不可避免的，因为需要一个对象来协调异步操作的生命周期。 ValueTask 作为一个轻量级的“外壳”，持有对这个 Task 的引用。 关键点：ValueTask 本身是一个值类型外壳，它根据操作的完成方式，要么直接持有结果（零分配），要么引用一个 Task（一次分配，但这是必须的）。 3. 何时 (When) 使用 ValueTask？—— 最佳实践与场景 ValueTask 并非 Task 的通用替代品。它的使用有明确的适用场景和限制。 应该使用 ValueTask 的场景： 高频调用的 I/O 操作：尤其是那些有很大概率同步完成的操作。 示例：Stream.ReadAsync、Stream.WriteAsync。如果数据已经在缓冲区中，读取可以立即完成，返回一个零分配的 ValueTask 。如果数据不在缓冲区，需要等待 I/O 完成，则返回一个包装了 Task 的 ValueTask 。 自定义异步原语：当你在编写一个可能快速完成的异步方法时。 示例：一个异步缓存查找方法。如果缓存命中，可以立即返回结果，非常适合 ValueTask 。 性能关键路径：在对性能要求极高，且经过分析确认 Task 分配是瓶颈的代码中。 ❌ 不应该使用 ValueTask 的场景： 返回 ValueTask 的方法体中包含了 await： 这是最常见的陷阱！如果你在 async 方法中使用 await，编译器会强制创建一个状态机，这个状态机本身就是一个引用类型，会产生堆分配。此时使用 ValueTask 不会带来任何性能收益，反而增加了复杂性。 ValueTask 的优势在于避免创建 Task 对象，但如果状态机本身就在堆上，省一个 Task 的意义不大。 规则：只有当你能同步返回结果或直接返回一个已存在的 Task 时，ValueTask 才有意义。对于典型的 async/await 方法，坚持使用 Task。 需要多次 await 同一个返回值： ValueTask 不是设计来被多次 await 的。await 一个 ValueTask 会消耗它（内部状态可能改变）。多次 await 可能导致未定义行为或异常。 如果你需要多次检查或等待同一个操作，必须使用 Task，因为 Task 是可以安全地被多次 await 的。 传递给 Task.WhenAll 或 Task.WhenAny： 这些方法期望 Task 对象。虽然有 ValueTask 的重载，但通常不如直接使用 Task 高效或直观。如果需要组合多个操作，考虑是否值得为单个操作使用 ValueTask。 作为方法参数： 将 ValueTask 作为参数传递会迫使它被装箱（因为方法参数是引用），这违背了使用值类型的初衷。应优先使用 Task 作为参数。 ValueTask 的陷阱与注意事项 不可变性：ValueTask 在 await 后不应再被使用。 装箱风险：任何需要将 ValueTask 当作 object 或接口（如 IValueTaskSource）处理的场景都可能导致装箱，产生堆分配。 调试复杂性：由于 ValueTask 可能代表两种不同的内部状态（内联结果或引用 Task），调试时可能不如 Task 直观。 API 设计：公开的 API 是否返回 ValueTask 需要仔细权衡。它向调用者传达了“此方法可能快速完成”的信号，但也增加了调用者的使用复杂性。 5. 总结 Task 是默认选择：对于绝大多数异步方法，特别是包含 await 的 async 方法，始终使用 Task。它简单、安全、语义清晰。 ValueTask 是性能优化工具：它是一个高级工具，用于在特定场景下（高频、可能同步完成的 I/O 操作）减少内存分配和 GC 压力。 核心原则：ValueTask 的价值在于避免不必要的堆分配。如果使用它反而引入了状态机分配或使用上的复杂性，那么它就失去了意义。 简单记忆： “用 Task 写代码，用 ValueTask 优化 I/O。” 在决定使用 ValueTask 之前，务必进行性能分析，确认 Task 分配确实是瓶颈，并且你的使用方式符合最佳实践，避免陷入陷阱。"
  },
  "docs/异步/概念.html": {
    "href": "docs/异步/概念.html",
    "title": "| MyCSharpDocs",
    "summary": "使用 async 和 await 进行异步编程 好的，我们来详细讲解 C# 中的异步编程。这是现代 C# 开发中一个至关重要且强大的特性，它能显著提升应用程序的响应性和可扩展性。 为什么需要异步编程？ 在传统的同步编程模型中，当一个方法执行一个耗时操作（如文件 I/O、网络请求、数据库查询、调用外部 API 等）时，调用线程会一直阻塞，直到该操作完成。 对于桌面应用 (WPF/WinForms)：如果在 UI 线程上执行耗时的同步操作，整个界面会“冻结”，用户无法进行任何交互，体验极差。 对于 Web 应用 (ASP.NET)：服务器处理每个请求通常使用一个线程。如果线程被阻塞在 I/O 操作上，它就无法处理其他请求，导致服务器资源浪费，吞吐量下降。 异步编程的核心目标就是：在等待耗时操作（尤其是 I/O 操作）完成时，不阻塞当前线程，让线程可以去执行其他任务，从而提高资源利用率和程序响应性。 C# 异步编程的核心：async 和 await C# 提供了非常简洁的语法来实现异步编程：async 和 await 关键字。它们是基于 任务 (Task) 模型构建的。 async 关键字 作用：用于修饰一个方法、lambda 表达式或匿名方法，表明该方法是异步的。 位置：放在返回类型之前。 返回类型： Task：用于没有返回值的异步方法（类似于 void）。 Task ：用于有返回值的异步方法，T 是返回值的类型。 ValueTask / ValueTask ：在某些高性能场景下替代 Task，以减少堆分配。 void：仅用于事件处理程序。返回 void 的异步方法很难被调用者跟踪其完成状态和异常，应尽量避免。 注意：async 本身不会使方法异步执行。它只是启用了 await 关键字，并改变了方法的编译方式。 2. await 关键字 作用：等待一个 Task 或 Task 完成。当遇到 await 时，如果任务尚未完成，控制权会立即返回给调用者，不会阻塞线程。一旦任务完成，方法的执行会从 await 之后的代码恢复。 位置：只能在标记为 async 的方法内部使用。 原理：await 实际上是一个“语法糖”。编译器会将 async 方法转换成一个状态机 (State Machine)。当 await 遇到未完成的任务时，状态机会保存当前的上下文（局部变量、执行位置等），然后注册一个回调（continuation），当任务完成后，这个回调会被调度执行，恢复方法的执行。 基本语法示例 using System; using System.Net.Http; using System.Threading.Tasks; class Program { // Main 方法也可以是异步的 (C# 7.1+) static async Task Main(string[] args) { Console.WriteLine(\"开始获取网页内容...\"); // 调用异步方法并等待其完成 string content = await GetWebContentAsync(\"https://www.example.com\"); Console.WriteLine($\"获取到的内容长度: {content.Length}\"); Console.WriteLine(\"程序结束。\"); } // 异步方法：返回 Task<string> static async Task<string> GetWebContentAsync(string url) { // HttpClient 用于发送 HTTP 请求 using var client = new HttpClient(); // await 关键字等待 GetStringAsync 完成 // GetStringAsync 是一个真正的异步 I/O 操作 string content = await client.GetStringAsync(url); // 当 GetStringAsync 完成后，执行会恢复到这里 return content; } } 执行流程分析： Main 开始执行，打印 \"开始获取网页内容...\"。 执行 await GetWebContentAsync(...)，进入 GetWebContentAsync 方法。 在 GetWebContentAsync 中，创建 HttpClient。 执行 await client.GetStringAsync(url)。GetStringAsync 发起一个网络请求，并立即返回一个 Task （表示未来的结果）。 因为 Task 尚未完成，await 操作导致 GetWebContentAsync 方法的执行被“挂起”，控制权返回给 Main 方法。 关键点：此时，执行 Main 的线程（比如主线程）没有被阻塞！它可以去处理其他事情（在控制台应用中可能只是空闲，但在 UI 或 Web 应用中可以处理其他请求或 UI 事件）。 当网络请求完成，GetStringAsync 返回的 Task 变为“已完成”状态，并携带了网页内容。 系统调度 GetWebContentAsync 方法中 await 之后的代码继续执行（即 return content;）。 GetWebContentAsync 方法返回一个已完成的 Task 给 Main。 Main 方法中 await 操作完成，content 变量被赋值，继续执行后续代码。 关键概念深入 线程与异步 误解：“异步 = 多线程”。 真相：异步 I/O 操作（如 HttpClient.GetStringAsync, FileStream.ReadAsync）通常不需要额外的线程来等待 I/O 完成。操作系统会处理底层的 I/O 请求，当数据准备好时，通过回调通知 .NET 运行时。.NET 运行时（通过 ThreadPool）负责调度这些回调。 线程池 (ThreadPool)：await 之后的代码（continuation）默认会在 ThreadPool 的某个线程上执行。这可能导致上下文切换。 ConfigureAwait(false)： 在类库中，为了性能和避免死锁，建议在 await 后使用 .ConfigureAwait(false)。 它告诉运行时：后续的 continuation 不需要回到原始的 SynchronizationContext（比如 UI 线程）。 在 UI 应用或 ASP.NET 的请求上下文中，如果不使用 ConfigureAwait(false)，continuation 会尝试回到原始上下文执行，这可能引起死锁（如果同步等待异步方法）。 // 在类库中推荐写法 string content = await client.GetStringAsync(url).ConfigureAwait(false); 2. 异常处理 异常在异步方法中通过 Task 的 Exception 属性传播。 使用 try-catch 块包裹 await 表达式，可以捕获异步方法中抛出的异常。 csharp static async Task<string> GetWebContentAsync(string url) { try { using var client = new HttpClient(); return await client.GetStringAsync(url); } catch (HttpRequestException ex) { Console.WriteLine($\"HTTP 请求失败: {ex.Message}\"); throw; // 可以选择重新抛出或处理 } catch (TaskCanceledException ex) { Console.WriteLine($\"请求超时: {ex.Message}\"); throw; } } 3. 并发执行多个异步操作 顺序执行：使用 await 一个接一个地调用。 csharp var content1 = await GetWebContentAsync(url1); var content2 = await GetWebContentAsync(url2); // 必须等第一个完成后才开始 并发执行：先启动所有任务，再 await 它们。这样多个 I/O 操作可以同时进行。 csharp // 启动所有任务 (不等待) var task1 = GetWebContentAsync(url1); var task2 = GetWebContentAsync(url2); var task3 = GetWebContentAsync(url3); // 等待所有任务完成 var results = await Task.WhenAll(task1, task2, task3); // results 是一个 string[] 数组 // 或者分别 await var content1 = await task1; var content2 = await task2; var content3 = await task3; Task.WhenAny：等待第一个完成的任务。 csharp var task1 = GetWebContentAsync(url1); var task2 = GetWebContentAsync(url2); var firstCompletedTask = await Task.WhenAny(task1, task2); var result = await firstCompletedTask; // 获取第一个完成的任务的结果 4. 取消异步操作 (CancellationToken) 长时间运行的操作应该支持取消。 csharp static async Task<string> GetWebContentAsync(string url, CancellationToken cancellationToken) { using var client = new HttpClient(); // 将 CancellationToken 传递给支持取消的异步方法 var response = await client.GetAsync(url, cancellationToken); response.EnsureSuccessStatusCode(); var content = await response.Content.ReadAsStringAsync(cancellationToken); return content; } // 调用 var cts = new CancellationTokenSource(); // 可以在某个条件满足时调用 cts.Cancel() 来取消操作 cts.CancelAfter(TimeSpan.FromSeconds(10)); // 10 秒后自动取消 try { string content = await GetWebContentAsync(\"https://slow-website.com\", cts.Token); } catch (OperationCanceledException) { Console.WriteLine(\"操作被取消。\"); } 最佳实践与注意事项 避免 async void：除非是事件处理程序，否则始终返回 Task 或 Task 。async void 无法被 await，异常处理困难。 不要阻塞异步代码：避免在异步方法中使用 .Result 或 .Wait()。这极易导致死锁，尤其是在有 SynchronizationContext 的环境中（如 UI 或 ASP.NET）。 错误做法： public string GetData() { return GetWebContentAsync(\"...\").Result; // 危险！可能导致死锁 } 使用 ConfigureAwait(false)：在编写类库时，为了性能和避免潜在的死锁，await 后应使用 .ConfigureAwait(false)。 正确处理异常：使用 try-catch 包裹 await。 支持取消：为长时间运行的操作提供 CancellationToken 参数。 理解返回类型：明确你的异步方法是返回 Task 还是 Task 。 并发与并行：Task.WhenAll 实现的是并发（concurrency），多个操作重叠执行，但不一定在多个 CPU 核心上并行（parallelism）运行。真正的并行计算通常使用 Parallel 类或 PLINQ。 总结 C# 的 async/await 提供了一种优雅、高效的方式来处理异步操作，特别是 I/O 密集型任务。它通过释放线程来等待 I/O 完成，极大地提高了应用程序的可伸缩性和响应性。理解其背后的 Task 模型、状态机原理以及 SynchronizationContext 的作用，是避免陷阱（如死锁）和编写高质量异步代码的关键。 掌握异步编程是成为一名合格的现代 C# 开发者的必备技能。"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE. | MyCSharpDocs",
    "summary": "This is the HOMEPAGE. Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image."
  }
}