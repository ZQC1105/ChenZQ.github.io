## 显式依赖项原则（Explicit Dependencies Principle）

“类所需要的所有外部协作对象，都必须通过公开、可观测的方式（通常是构造函数）显式地告诉调用者；禁止在类内部偷偷摸摸地 new、单例、ServiceLocator 等隐式获取。”

只要违反这一点，代码立刻变得难以单元测试、难以替换实现、难以理清依赖关系。下面从 “为什么、长什么样、怎么写、怎么测、常见坑” 五个角度，结合 C# 代码彻底讲透。

---

一、为什么——隐式依赖的灾难

```csharp
public class PriceService
{
    private readonly HttpClient _http;   // 调用者完全不知道
    private readonly ILog _log;          // 调用者完全不知道

    public PriceService()
    {
        _http = new HttpClient();                    // 直接 new
        _log  = LogManager.GetLogger<PriceService>(); // 静态单例
    }

    public async Task<decimal> GetPrice(int productId)
    {
        _log.Info("fetching price");
        var json = await _http.GetStringAsync(
                       $"http://api.shop.com/prices/{productId}");
        return decimal.Parse(json);
    }
}
```

问题  
1. 测试时必须真的发 HTTP 请求、真的写日志文件——单元测试变集成测试。  
2. 想换成 `TestServer` 或 `FakeLogger` 做不到，因为创建权在类内部。  
3. 阅读 API 时，构造函数没有任何线索，只能“打开源码”才能知道它究竟要啥。

---

二、长什么样——显式依赖
把依赖全部提到构造函数（或者方法参数，下文再谈），并在接口层面抽象：

```csharp
public interface IPriceGateway
{
    Task<decimal> GetPrice(int productId);
}

public interface IAppLogger
{
    void Info(string message);
}

public sealed class PriceService
{
    private readonly IPriceGateway _gateway;
    private readonly IAppLogger    _log;

    // 所有依赖一目了然
    public PriceService(IPriceGateway gateway, IAppLogger log)
    {
        _gateway = gateway ?? throw new ArgumentNullException(nameof(gateway));
        _log     = log     ?? throw new ArgumentNullException(nameof(log));
    }

    public async Task<decimal> GetPrice(int productId)
    {
        _log.Info($"Fetching price for {productProductId}");
        return await _gateway.GetPrice(productId);
    }
}
```

好处  
1. 调用者（或 DI 容器）一眼看清：要给我一个 `IPriceGateway` 和 `IAppLogger`。  
2. 单元测试可以扔 `FakePriceGateway`、`FakeLogger` 进去，毫秒级测试。  
3. 符合 SOLID 之 DIP（依赖倒置）：高层 `PriceService` 不依赖低层 `HttpClient/Log4Net`，而是依赖抽象。


三、怎么写——三种合法注入方式
1. 构造函数注入（最推荐，生命周期与类实例一致）
   
```csharp
   public PriceService(IPriceGateway g, IAppLogger l) { … }
```

2. 方法注入（依赖只在单个方法用到，或者需要运行时动态传）
   
```csharp
   public async Task<decimal> GetPrice(
               int productId, 
               CancellationToken ct = default)   // 框架传入
```

3. 属性/字段赋值（仅限“可选依赖”，必须有默认值保护）
   
```csharp
   public IAppLogger Logger { get; set; } = NullLogger.Instance;
```

---

四、怎么测——单元测试示范

```csharp
[Fact]
public void Should_return_fake_price()
{
    // Arrange
    var fakeGateway = new Mock<IPriceGateway>();
    fakeGateway.Setup(x => x.GetPrice(1)).ReturnsAsync(99.9m);
    var fakeLog = new Mock<IAppLogger>();

    var svc = new PriceService(fakeGateway.Object, fakeLog.Object);

    // Act
    var price = svc.GetPrice(1).GetAwaiter().GetResult();

    // Assert
    Assert.Equal(99.9m, price);
}
```

全程无 HTTP、无日志文件、100 ms 内跑完。

---

五、常见坑与问答
1. “构造函数参数太多”

   → 把相关依赖打包成 `IOptions<PriceServiceOptions>` 或门面接口，再或者拆分职责。

2. “我用的是 .NET 6 最小 API，怎么显式？”

   → 一样构造函数注入：
   
```csharp
   builder.Services.AddScoped<IPriceGateway, HttpPriceGateway>();
   builder.Services.AddScoped<IAppLogger, SerilogAdapter>();
   app.MapGet("/price/{id}", (int id, PriceService svc) => svc.GetPrice(id));
```

3. “静态日志很爽，为什么不行？”

   → 静态 = 隐式 = 全局状态，测试之间互相污染，且无法替换为 `FakeLogger`。

4. “ServiceLocator 好像也能解耦？”

   → `var log = ServiceLocator.Resolve<ILogger>()` 依旧把依赖藏进方法体，违反“显式”。

   真正可观测的依赖必须出现在类型公开契约里（构造/方法参数）。

---

六、一句话总结
在 C# 中落地“显式依赖项原则”就是：

“能放进构造函数，就别藏到方法体；能抽象成接口，就别直接 new 实现；能让调用者一眼看懂，就别让他翻源码。”