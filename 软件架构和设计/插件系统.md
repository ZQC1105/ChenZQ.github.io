您现在描述的情况触及了现代软件架构中一个非常核心且常见的需求：模块化 (Modularity) 和 按需加载 (On-Demand Loading)。

让我们梳理一下现状和目标：

当前架构 (问题)：
您有多个 WPF 类库（例如 ModuleA.dll, ModuleB.dll, ModuleC.dll），每个代表一个功能模块。
您有一个主 WPF .exe 宿主应用。
宿主应用直接引用了所有这些模块的 .dll 文件。
结果：所有模块在编译时就被“硬编码”进宿主应用。您无法实现：
按功能授权：根据用户的许可证，只启用某些模块。
动态更新：替换或更新单个模块而无需重新部署整个应用。
延迟加载：只在用户需要时才加载某个模块，减少启动时间。

目标架构 (理想)：
宿主应用是轻量级的，只知道如何“发现”和“加载”模块。
功能模块以 .dll 文件的形式存在于一个特定的文件夹（如 Modules/）。
宿主应用在启动时扫描这个文件夹，动态加载 .dll。
宿主应用根据用户的授权信息，决定加载哪些模块。
每个模块可以独立开发、测试、部署和授权。

解决方案：使用插件架构 (Plugin Architecture)

您需要将您的模块从“直接引用的类库”转变为“动态加载的插件”。这可以通过 反射 (Reflection) 和 依赖注入 (DI) 的结合来实现。
核心思想

1. 定义公共契约 (Contracts)：创建一个独立的类库（如 MyApp.Core 或 MyApp.Contracts），其中只包含模块与宿主通信所需的接口和共享模型。
2. 模块实现契约：每个功能模块 (ModuleA, ModuleB) 都引用 Contracts 项目，并实现其中的接口。
3. 宿主发现并加载：宿主应用引用 Contracts 项目，但不直接引用任何 ModuleX.dll。它通过反射从 Modules/ 文件夹加载 .dll，查找实现了特定接口的类型，并创建实例。
4. 集成 DI：在宿主应用的 DI 容器中，为每个加载的模块注册其服务。

详细实现步骤
步骤 1：创建 Contracts 项目

1. 新建一个名为 MyApp.Contracts 的 Class Library 项目。
2. 在其中定义模块与宿主交互的接口。

csharp
// 文件: IModule.cs (在 MyApp.Contracts 项目中)
/// <summary>
/// 所有功能模块必须实现的接口。
/// </summary>
public interface IModule
{
/// <summary>
/// 模块的唯一标识符。
/// </summary>
string Id { get; }

/// <summary>
/// 模块的显示名称。
/// </summary>
string Name { get; }

/// <summary>
/// 模块的描述。
/// </summary>
string Description { get; }

/// <summary>
/// 模块的版本。
/// </summary>
string Version { get; }

/// <summary>
/// 获取此模块提供的菜单项。
/// </summary>
/// <returns></returns>
IEnumerable<IMenuItem> GetMenuItems();

/// <summary>
/// 此方法由宿主调用，用于注册该模块的服务到 DI 容器。
/// </summary>
/// <param name="services">The service collection from the host.</param>
void RegisterServices(IServiceCollection services);
}

// 文件: IMenuItem.cs (在 MyApp.Contracts 项目中)
/// <summary>
/// 代表一个菜单项。
/// </summary>
public interface IMenuItem
{
string Text { get; }
ICommand Command { get; }
// 可以添加 Icon, Shortcut 等属性
}
步骤 2：重构功能模块

修改 ModuleA 项目，使其引用 MyApp.Contracts 而不是直接被宿主引用。

csharp
// 文件: ModuleA.cs (在 ModuleA 项目中)
using MyApp.Contracts;
using Microsoft.Extensions.DependencyInjection;

public class ModuleA : IModule
{
public string Id => "ModuleA";
public string Name => "报价管理";
public string Description => "处理报价相关的功能。";
public string Version => "1.0.0";

public IEnumerable<IMenuItem> GetMenuItems()
{
// 假设您有一个 Command 实现
var command = new RelayCommand(async () =>
{
// 这里可以通过 DI 获取服务
var serviceProvider = ServiceLocator.ServiceProvider; // 或通过其他方式
var viewModel = serviceProvider?.GetService<YourViewModel>();
var window = new ModuleAWindow { DataContext = viewModel };
window.ShowDialog();
});

return new[] { new MenuItemImpl("选取报价表", command) };
}

public void RegisterServices(IServiceCollection services)
{
// 在这里，您向宿主的 DI 容器注册本模块所需的所有服务
services.AddSingleton<ICadSelectionService, RealCadSelectionService>();
services.AddTransient<YourViewModel>();
// ... 注册其他服务
}
}

// 简单的菜单项实现
public class MenuItemImpl : IMenuItem
{
public string Text { get; }
public ICommand Command { get; }

public MenuItemImpl(string text, ICommand command)
{
Text = text;
Command = command;
}
}
步骤 3：重构宿主应用 (WPF .exe)

1. 修改项目引用：
宿主应用 (MyApp.Host) 引用 MyApp.Contracts。
宿主应用 不再直接引用 ModuleA.dll, ModuleB.dll 等。

2. 创建模块加载器：

csharp
// 文件: ModuleLoader.cs (在宿主应用中)
using MyApp.Contracts;
using System.Reflection;

public class ModuleLoader
{
private readonly string _modulesPath;

public ModuleLoader(string modulesPath = "Modules")
{
_modulesPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, modulesPath);
}

/// <summary>
/// 从模块文件夹加载所有实现了 IModule 接口的模块。
/// </summary>
/// <returns>已加载的模块列表。</returns>
public List<IModule> LoadModules()
{
var modules = new List<IModule>();

if (!Directory.Exists(_modulesPath))
{
Directory.CreateDirectory(_modulesPath);
return modules;
}

var dllFiles = Directory.GetFiles(_modulesPath, ".dll");
foreach (var dllFile in dllFiles)
{
try
{
// 加载程序集
var assembly = Assembly.LoadFrom(dllFile);

// 查找实现了 IModule 接口的公共类型
var moduleTypes = assembly.GetTypes()
.Where(t => typeof(IModule).IsAssignableFrom(t) && !t.IsInterface && !t.IsAbstract);

foreach (var type in moduleTypes)
{
// 创建实例
var moduleInstance = (IModule)Activator.CreateInstance(type)!;
modules.Add(moduleInstance);
}
}
catch (Exception ex)
{
// 记录加载失败的模块
Console.WriteLine($"Failed to load module from {dllFile}: {ex.Message}");
}
}

return modules;
}
}

3. 在宿主应用中集成模块加载和 DI：

csharp
// 文件: App.xaml.cs (在宿主应用中)

using MyApp.Contracts;
using Microsoft.Extensions.DependencyInjection;

public partial class App : Application
{
private static ServiceProvider? _serviceProvider;

protected override async void OnStartup(StartupEventArgs e)
{
base.OnStartup(e);

var services = new ServiceCollection();

// 1. 注册宿主应用自己的服务
services.AddSingleton<IMainWindow, MainWindow>();

// 2. 加载模块
var moduleLoader = new ModuleLoader();
var allModules = moduleLoader.LoadModules();

// 3. 【关键】根据授权筛选模块
var authorizedModules = FilterModulesByLicense(allModules); // 您需要实现这个方法

// 4. 【关键】让每个授权模块注册自己的服务
foreach (var module in authorizedModules)
{
module.RegisterServices(services); // 模块将服务添加到宿主的 ServiceCollection
}

// 5. 构建服务提供者
_serviceProvider = services.BuildServiceProvider();

// 6. 创建主窗口，并将授权的模块列表传递给它（例如通过 ViewModel）
var mainWindow = _serviceProvider.GetRequiredService<IMainWindow>();
var mainViewModel = (MainViewModel)mainWindow.DataContext;
mainViewModel.Initialize(authorizedModules); // 让 ViewModel 构建菜单

mainWindow.Show();
}

private List<IModule> FilterModulesByLicense(List<IModule> allModules)
{
// TODO: 实现您的授权逻辑
// 例如，读取 license 文件，检查用户是否有权限使用某个模块的 Id
// return allModules.Where(m => IsUserAuthorized(m.Id)).ToList();
return allModules; // 暂时返回所有模块
}

public static T GetService<T>() where T : class
{
return _serviceProvider?.GetService<T>()
?? throw new InvalidOperationException($"Service of type {typeof(T)} not available.");
}
}
步骤 4：部署

编译宿主应用 (MyApp.Host.exe)。
将 ModuleA.dll, ModuleB.dll 等不被直接引用的模块 DLL 文件放入宿主应用目录下的 Modules/ 文件夹中。
运行 MyApp.Host.exe，它将自动发现、加载、根据授权筛选并集成这些模块。

总结

通过这种基于 Contracts + 反射 + DI 的插件架构，您成功实现了：

松耦合：宿主与模块之间通过接口通信。
按需加载：只有被放入 Modules/ 文件夹的 DLL 才会被考虑。
按功能授权：FilterModulesByLicense 方法可以根据任何逻辑（许可证文件、数据库、云服务等）决定启用哪些模块。
独立部署：您可以单独更新 ModuleA.dll 而无需重新编译或部署整个宿主应用。
可扩展性：添加新功能只需开发一个新的模块 DLL 并放入文件夹即可。

这正是大型软件（如 Visual Studio, AutoCAD, Revit）实现插件系统的核心原理。
