下面给出一份**完整、可编译、直接跑**的示例，把：

1. 不可变 record（产品）  
2. 建造者（Builder）  
3. 指挥者（Director，可选）  
4. 调用端  

全部串在一起，演示**“建造者设计模式”**在现代 C# 中的落地。

---

### ✅ 完整代码（.NET 6+ 控制台项目）

```csharp
using System;
using System.Net;

#region 1. 产品：不可变 record
public enum Code { Ok, Error }

public interface IZmMessage { }

/// <summary>
/// 产品（Product）——不可变数据
/// </summary>
public record ZmMessage(
    Code Code,
    string Message,
    HttpStatusCode StatusCode
) : IZmMessage;
#endregion

#region 2. 建造者（Builder）
public sealed class ZmMessageBuilder
{
    private Code _code = Code.Ok;
    private string _message = string.Empty;
    private HttpStatusCode _statusCode = HttpStatusCode.OK;

    public ZmMessageBuilder WithCode(Code code)
    {
        _code = code;
        return this;
    }

    public ZmMessageBuilder WithMessage(string message)
    {
        _message = message ?? throw new ArgumentNullException(nameof(message));
        return this;
    }

    public ZmMessageBuilder WithStatusCode(HttpStatusCode statusCode)
    {
        _statusCode = statusCode;
        return this;
    }

    /// <summary>
    /// 组装出最终不可变对象
    /// </summary>
    public ZmMessage Build() => new(_code, _message, _statusCode);

    // 隐式转换：Builder 直接当成 ZmMessage 用
    public static implicit operator ZmMessage(ZmMessageBuilder b) => b.Build();
}
#endregion

#region 3. 指挥者（Director）——封装常用“建造流程”
public static class ZmMessageDirector
{
    public static ZmMessage BadRequest(string message) =>
        new ZmMessageBuilder()
            .WithCode(Code.Error)
            .WithMessage(message)
            .WithStatusCode(HttpStatusCode.BadRequest)
            .Build();

    public static ZmMessage Ok(string message) =>
        new ZmMessageBuilder()
            .WithCode(Code.Ok)
            .WithMessage(message)
            .WithStatusCode(HttpStatusCode.OK)
            .Build();
}
#endregion

#region 4. 客户端调用
internal class Program
{
    private static void Main()
    {
        // 4.1 完全自定义建造
        var msg1 = new ZmMessageBuilder()
            .WithCode(Code.Error)
            .WithMessage("Invalid token")
            .WithStatusCode(HttpStatusCode.Unauthorized)
            .Build();
        Console.WriteLine($"【自定义】{msg1}");

        // 4.2 隐式转换
        ZmMessage msg2 = new ZmMessageBuilder()
            .WithMessage("Server error")
            .WithStatusCode(HttpStatusCode.InternalServerError);
        Console.WriteLine($"【隐式转换】{msg2}");

        // 4.3 使用 Director 快速拿“模板”
        var msg3 = ZmMessageDirector.BadRequest("Id is required");
        Console.WriteLine($"【Director】{msg3}");
    }
}
#endregion
```

---

### ✅ 运行结果示例

```
【自定义】ZmMessage { Code = Error, Message = Invalid token, StatusCode = Unauthorized }
【隐式转换】ZmMessage { Code = Ok, Message = Server error, StatusCode = InternalServerError }
【Director】ZmMessage { Code = Error, Message = Id is required, StatusCode = BadRequest }
```

---

### ✅ 模式角色对照表

| 角色       | 代码中的体现                     |
|------------|----------------------------------|
| 产品       | `ZmMessage`（不可变 record）     |
| 建造者     | `ZmMessageBuilder`               |
| 指挥者     | `ZmMessageDirector`（可选）      |
| 客户端     | `Program.Main()`                 |

这样，**“复杂对象的创建过程”**被完整地封装在 Builder 与 Director 中，客户端代码始终保持简洁、可读、易扩展。