没错，**`[ApiController]` 会自动把模型验证失败变成 400 响应**，你**再也不用**写：

```csharp
if (!ModelState.IsValid)
{
    return BadRequest(ModelState);
}
```

框架替你做的两件事：

1. 在模型绑定 + 验证完成后，**立即检查** `ModelState.IsValid`；
2. 一旦失败，**直接返回 400**，并把 `ModelState` 的键值错误列表作为 JSON 放进响应体。

示例：

```csharp
[ApiController]
[Route("api/[controller]")]
public class UserController : ControllerBase
{
    [HttpPost]
    public IActionResult Create(UserDto dto)   // 无需手动检查 ModelState
    {
        // 到这一行时，dto 肯定已通过验证
        return Ok(dto);
    }
}

public class UserDto
{
    [Required] public string Name { get; set; }
    [Range(1, 150)] public int Age { get; set; }
}
```

请求体：

```json
{ "age": 0 }
```

响应：

```
HTTP/1.1 400 Bad Request
Content-Type: application/problem+json; charset=utf-8

{
  "type": "https://tools.ietf.org/html/rfc9110#section-15.5.1",
  "title": "One or more validation errors occurred.",
  "status": 400,
  "errors": {
    "Name": ["The Name field is required."],
    "Age": ["The field Age must be between 1 and 150."]
  }
}
```

---

### ⚠️ 注意几点

1. 只对 `[ApiController]` 控制器生效；普通 MVC 控制器仍需手动 `BadRequest()`。
2. 默认返回 **ProblemDetails** 格式（RFC 7807）。  
   若想自定义，可注册 `InvalidModelStateResponseFactory`：

   ```csharp
   services.AddControllers()
           .ConfigureApiBehaviorOptions(opt =>
           {
               opt.InvalidModelStateResponseFactory = ctx =>
               {
                   var errors = ctx.ModelState
                                   .Where(e => e.Value.Errors.Count > 0)
                                   .ToDictionary(
                                        k => k.Key,
                                        v => v.Value.Errors.Select(x => x.ErrorMessage).ToArray());
                   return new BadRequestObjectResult(new { Code = 400, Errors = errors });
               };
           });
   ```

3. 如果 Action 的参数显式标记了 `[FromRoute]`/`[FromQuery]`/`[FromBody]`，验证规则一样生效。

---

### ✅ 结论

只要贴上 `[ApiController]`，就把 `if (!ModelState.IsValid) return BadRequest(...)` 删掉；  
框架保证：验证失败 **绝不**会进入你的 Action，而是**直接 400**。