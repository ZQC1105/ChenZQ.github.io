## [官方文档地址](https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-8.0#service-lifetimes)
ASP.NET Core 依赖注入（DI）核心就三句话：  
**“注册→注入→生命周期”**。  

---

### 1. 三步曲
1. **注册**（`Program.cs`）  
   ```csharp
   builder.Services.AddSingleton<ISingleton, SingletonImpl>();
   builder.Services.AddScoped<IScoped, ScopedImpl>();
   builder.Services.AddTransient<ITransient, TransientImpl>();
   ```

2. **注入**（构造函数最干净）  
   ```csharp
   [ApiController]
   [Route("[controller]")]
   public class DemoController : ControllerBase
   {
       private readonly IScoped _scoped;
       public DemoController(IScoped scoped) => _scoped = scoped;
   }
   ```

3. **生命周期**（背表）

| 生命周期      | 容器方法       | 同一请求内 | 跨请求     | 线程安全 | 典型场景                            |
| ------------- | -------------- | ---------- | ---------- | -------- | ----------------------------------- |
| **Transient** | `AddTransient` | 每次新建   | 每次都新建 | ❌ 无需   | 轻量级、无状态服务；`SqlConnection` |
| **Scoped**    | `AddScoped`    | 单例       | 每请求新建 | ✅ 推荐   | EF `DbContext`、当前请求缓存        |
| **Singleton** | `AddSingleton` | 单例       | 单例       | ✅ 必须   | 全局配置、缓存、日志工厂            |

---

### 2. 常见坑速记
- **Scoped 别注入成 Singleton** → 会踩“ captive dependency”坑：单例里存着已释放的 Scoped 实例，第二次请求用时报 `ObjectDisposedException`。  
- **Singleton 里千万别用 `DbContext`** → 它默认是 Scoped，生命周期不匹配。  
- **不要在 `ConfigureServices` 里手动 `new` 并单例保存**，否则容器管不到释放。  

---

### 3. 高级速查
- **工厂注册**：  
  ```csharp
  builder.Services.AddSingleton<IFoo>(sp => new Foo(sp.GetRequiredService<ILogger<Foo>>()));
  ```
- **尝试解析**：  
  ```csharp
  var bar = HttpContext.RequestServices.GetService<IBar>(); // 不推荐在业务代码里用
  ```
- **作用域手工创建**：  
  ```csharp
  using var scope = app.Services.CreateScope();
  var svc = scope.ServiceProvider.GetRequiredService<IMyScopedService>();
  ```

---

### 4. 一张图背完
```
Transient → 用一次扔一次  
Scoped    → 一次请求一个  
Singleton → 整个进程一个
```
顺序别背反，**从短到长**：`Transient < Scoped < Singleton`。

---

### 5. 一句话总结
**“短寿命往长寿命里注入会翻车，注册顺序与生命周期对应好，构造函数注入最干净。”**