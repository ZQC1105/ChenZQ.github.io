### 一、问题本质  
- **托管服务**（`BackgroundService`/`IHostedService`）被注册为 **Singleton**。  
- 业务组件（`DbContext`、Repository 等）通常注册为 **Scoped**。  
- **Singleton 不能直接注入 Scoped**，否则会引发 `InvalidOperationException` 或后续 ObjectDisposed 异常。  

### 二、解决思路  
1. 不在构造函数里直接注入 Scoped 组件。  
2. 注入 **IServiceScopeFactory**（Singleton，负责手动开作用域）。  
3. 每次后台循环或批处理开始时：  
   ```csharp
   using var scope = _scopeFactory.CreateScope();
   var repo = scope.ServiceProvider.GetRequiredService<IUserRepository>();
   // …执行业务…
   ```  
4. `using` 结束自动释放作用域，DbContext/连接随作用域一起回收。  

### 三、代码骨架  
```csharp
public class InactiveUserNotifierService : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger<InactiveUserNotifierService> _logger;

    public InactiveUserNotifierService(
        IServiceScopeFactory scopeFactory,
        ILogger<InactiveUserNotifierService> logger)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _scopeFactory.CreateScope();
                var repo = scope.ServiceProvider.GetRequiredService<IUserRepository>();
                var users = await repo.GetInactiveUsersAsync();
                foreach (var u in users)
                {
                    _logger.LogInformation($"Notify {u.Email}");
                    await repo.MarkAsNotifiedAsync(u);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in background loop");
            }
            await Task.Delay(TimeSpan.FromHours(1), stoppingToken);
        }
    }
}
```
注册：  
```csharp
builder.Services.AddDbContext<AppDbContext>(…);
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddHostedService<InactiveUserNotifierService>();
```

### 四、常见陷阱  
- ❌ 把 `DbContext`/`IUserRepository` 直接注入构造函数。  
- ❌ 作用域范围开得过大或忘记释放 → 内存/连接泄漏。  
- ❌ 忽视 `CancellationToken`，导致应用关闭时任务仍阻塞。  
- ❌ 在循环里用同步方法阻塞线程 → 降低应用吞吐。  

### 五、何时考虑更高级方案  
- 需要 **Cron 表达式**、集群持久化、失败重试 → 用 **Quartz.NET/Hangfire**。  
- 只是轻量级周期性任务 → 原生托管服务 + `IServiceScopeFactory` 足够。  

**牢记**：  
**Singleton 里想要 Scoped，就开作用域；开完即用即关，资源安全又干净。**