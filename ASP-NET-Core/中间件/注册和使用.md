## [ASP.NET Core 中间件](https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0)
ASP .NET Core 里命名很直白：

| 前缀 | 全称 | 所处阶段 | 作用对象 | 典型示例 |
|---|---|---|---|---|
| **Add** | `AddXxx` | **应用启动阶段**（`Program.cs` 上半段） | **DI 容器**（`IServiceCollection`） | `AddAuthentication`<br>`AddAuthorization`<br>`AddControllers` |
| **Use** | `UseXxx` | **请求管道阶段**（`Program.cs` 下半段） | **HTTP 请求管道**（`IApplicationBuilder`） | `UseAuthentication`<br>`UseAuthorization`<br>`UseRouting` |

一句话记忆：  
**Add = 注册服务（告诉框架“我有这些工具”）**  
**Use = 加入管道（告诉框架“每个请求都按这个顺序走这些工具”）**

> 中间件本身是一个**服务**（用 `Add` 注册），但让它**参与请求处理**必须再 `Use` 出来。
>
> 把“写好的中间件”插进管道，只有两步：**注册类→插入顺序**。  
下面给出 3 种常见写法的“最小可运行”代码，复制即可验证。

--------------------------------------------------
一、内联匿名（临时用，不建类）
```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// 直接插一行
app.Use(async (ctx, next) =>
{
    Console.WriteLine("[Before] Request " + ctx.Request.Path);
    await next();                // 交给后续
    Console.WriteLine("[After]  Response " + ctx.Response.StatusCode);
});

app.MapGet("/", () => "Hello");
app.Run();
```

--------------------------------------------------
二、类中间件（最常用，可 DI）
1. 建类  
```csharp
public class RequestCultureMiddleware
{
    private readonly RequestDelegate _next;
    public RequestCultureMiddleware(RequestDelegate next) => _next = next;

    public async Task InvokeAsync(HttpContext ctx)
    {
        var culture = ctx.Request.Query["culture"].ToString();
        if (!string.IsNullOrEmpty(culture))
        {
            CultureInfo.CurrentCulture = new CultureInfo(culture);
            CultureInfo.CurrentUICulture = new CultureInfo(culture);
        }

        await _next(ctx);   // 必须调用，否则管道断开
    }
}
```

2. 写扩展方法（非必须，但好看）  
```csharp
public static class RequestCultureMiddlewareExtensions
{
    public static IApplicationBuilder UseRequestCulture(this IApplicationBuilder app)
        => app.UseMiddleware<RequestCultureMiddleware>();
}
```

3. 在 Program.cs 插入  
```csharp
var app = builder.Build();
app.UseRequestCulture();   // 顺序按需要放
app.MapGet("/", () => $"Current culture: {CultureInfo.CurrentCulture.Name}");
app.Run();
```

--------------------------------------------------
三、工厂中间件（需要 Scoped 依赖时）
当中间件内部要注入 **Scoped** 服务（如 EF DbContext），实现 `IMiddleware` 接口，让 ASP.NET 按“每次请求 new 一个”。

1. 建类  
```csharp
public class DbAuditMiddleware : IMiddleware
{
    private readonly AppDbContext _db;
    public DbAuditMiddleware(AppDbContext db) => _db = db;

    public async Task InvokeAsync(HttpContext ctx, RequestDelegate next)
    {
        _db.AuditLogs.Add(new AuditLog { Path = ctx.Request.Path, Time = DateTime.UtcNow });
        await _db.SaveChangesAsync();
        await next(ctx);
    }
}
```

2. 注册到 DI（关键）  
```csharp
builder.Services.AddDbContext<AppDbContext>(opt => opt.UseSqlite("Data Source=audit.db"));
builder.Services.AddTransient<DbAuditMiddleware>(); // 必须 AddTransient<IMiddleware>
```

3. 使用  
```csharp
app.UseMiddleware<DbAuditMiddleware>();
```

--------------------------------------------------
四、验证是否生效
1. 启动后访问任意地址，观察：  
   - 控制台打印 → 匿名中间件生效  
   - 带 `?culture=fr-FR` 返回法语格式 → 类中间件生效  
   - 数据库出现 AuditLogs 表记录 → 工厂中间件生效  

--------------------------------------------------
五、一句话总结
**“写完类 → 注册到 DI（如果需要）→ 在 Program.cs 用 `app.UseMiddleware<T>()` 或自定义扩展方法插进去”**——顺序对了就跑起来。

## 为什么 `app.UseRequestCulture();` 的顺序要“按需要放”

ASP.NET Core 的请求管道是一条**单向生产线**：  
**前一个中间件处理完的结果，是后一个中间件的输入**。  
插错位置 = 拿不到数据 / 被短路 / 逻辑失效。

---

### 1. 在 `UseRouting()` 前后——决定能不能拿到路由数据

| 顺序                                   | 效果                                                              |
| -------------------------------------- | ----------------------------------------------------------------- |
| `UseRequestCulture()` → `UseRouting()` | 路由未解析，`ctx.GetRouteData()` 拿不到 `{controller}/{action}`。 |
| `UseRouting()` → `UseRequestCulture()` | 路由已解析，可按 `RouteValues["controller"]` 做语言切换。         |

---

### 2. 在 `UseAuthentication()` / `UseAuthorization()` 前后——决定有没有用户身份

| 顺序   | 效果                                                        |
| ------ | ----------------------------------------------------------- |
| 鉴权前 | `ctx.User` 为空，无法按“登录用户”切换 Culture。             |
| 鉴权后 | 可读取 `ctx.User.FindFirst("culture")` 实现“个人偏好语言”。 |

---

### 3. 在 `UseEndpoints()` 或 `MapControllers()` 前后——决定是否被短路

| 顺序                                       | 效果                                                      |
| ------------------------------------------ | --------------------------------------------------------- |
| `UseRequestCulture()` → `MapControllers()` | 总会经过文化中间件。                                      |
| `MapControllers()` → `UseRequestCulture()` | 请求已被 MVC 短路，**文化中间件永远不会执行**，代码白写。 |

---

### 4. 在 `UseStaticFiles()` 前后——决定是否对静态文件生效

| 顺序       | 效果                                            |
| ---------- | ----------------------------------------------- |
| 静态文件前 | 对 `.html`、`.jpg` 等也切换 Culture，可能浪费。 |
| 静态文件后 | 仅对 MVC/API 请求生效，性能更高。               |

---

### 5. 实战示例：支持“登录用户 Claims 语言 > QueryString 语言”

正确顺序：
```csharp
app.UseRouting();          // 1. 解析路由
app.UseAuthentication();   // 2. 建立用户身份
app.UseRequestCulture();   // 3. 此时 ctx.User 已可用
app.UseAuthorization();
app.MapControllers();
```

若把 `UseRequestCulture()` 放到 `UseAuthentication()` 之前，  
`ctx.User` 永远为空，**登录用户的个人语言偏好永久失效**。

---

### 一句话总结
> **中间件只能看见“前面”已发生的事，也只能影响“后面”未发生的事。**  
所以 `UseRequestCulture()` 插在哪，**取决于你要不要路由、用户、是否避开静态文件、是否避开短路**——这就叫“顺序按需要放”。