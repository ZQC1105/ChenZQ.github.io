ASP.NET Core 中间件（Middleware）就是**“一段串联成管道的代码”**，负责**“先处理请求，再调用下一个，最后处理响应”**。  
背一句话：**“管道=顺序执行的一堆委托，中间件=委托的实现”**。

---

### 1. 最简定义
```csharp
// 签名：Func<HttpContext, Func<Task>, Task>
// 伪代码
public async Task InvokeAsync(HttpContext context, RequestDelegate next)
{
    // 1. 请求阶段（Before）
    DoSomething(context);

    // 2. 把请求交给下一个中间件
    await next(context);

    // 3. 响应阶段（After）
    DoSomethingElse(context);
}
```

---

### 2. 三种写法速记

| 写法                                                        | 场景                         | 记忆口诀           |
| ----------------------------------------------------------- | ---------------------------- | ------------------ |
| **内联匿名** `app.Use(...)`                                 | 一次性、简单                 | “一行搞定”         |
| **类封装** `CustomMiddleware` + `app.UseMiddleware<T>()`    | 可复用、可 DI                | “类就是乐高”       |
| **工厂中间件** `IMiddleware` + `services.AddTransient<T>()` | 需要**按请求生命周期**的依赖 | “要作用域？用工厂” |

---

### 3. 常用内置中间件速查（按经典顺序）

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

if (app.Environment.IsDevelopment())
    app.UseDeveloperExceptionPage();   // 1. 报错页

app.UseRouting();                      // 2. 路由匹配
app.UseAuthentication();               // 3. 鉴权
app.UseAuthorization();                // 4. 授权

app.MapControllers();                  // 5. 终点（MVC/Minimal API）

app.Run();
```

---

### 4. 顺序口诀
**“异常→静态→路由→鉴权→授权→终点”**  
顺序错，功能全废：  
- 把 `UseAuthorization` 放在 `UseAuthentication` 前面 → 授权时还没认证，直接 403。  
- 把 `UseRouting` 放最后 → 路由永远匹配不到。

---

### 5. 自定义中间件模板（复制即可用）

```csharp
public class TimingMiddleware
{
    private readonly RequestDelegate _next;
    public TimingMiddleware(RequestDelegate next) => _next = next;

    public async Task InvokeAsync(HttpContext ctx)
    {
        var sw = Stopwatch.StartNew();
        await _next(ctx);
        sw.Stop();
        ctx.Response.Headers["X-Elapsed-ms"] = sw.ElapsedMilliseconds.ToString();
    }
}

// 注册扩展
public static class TimingMiddlewareExtensions
{
    public static IApplicationBuilder UseTiming(this IApplicationBuilder app)
        => app.UseMiddleware<TimingMiddleware>();
}

// Program.cs
app.UseTiming();   // 随便插到合适位置
```

---

### 6. 一张图记住生命周期
```
Request → Middleware1 → Middleware2 → ... → Endpoint → ... → Middleware2 → Middleware1 → Response
```
**“先进后出”** 的俄罗斯套娃。

---

### 7. 小结（背 3 句）
1. 中间件 = 管道里的“洋葱圈”，顺序决定生死。  
2. 写法则三：内联、类、工厂；选哪个看复用和依赖。  
3. 内置顺序：异常→静态→路由→鉴权→授权→终点，错了全崩。