[路由事件概述](https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/events/routed-events-overview)
# WPF 路由事件（Routed Events）核心指南

**核心概念**：路由事件能在元素树中多个监听器上调用处理程序，而不仅限于事件源。这是 WPF 事件系统与标准 CLR 事件的根本区别。

---

## 一、什么是路由事件？

**功能角度**：可在元素树多个节点触发处理程序的事件类型  
**实现角度**：由 `RoutedEvent` 实例支持并向 WPF 事件系统注册的事件

**典型场景**：`Button.Click` 事件从按钮冒泡到父容器，父容器可统一处理所有子按钮的点击

```xml
<StackPanel Button.Click="UnifiedHandler">
    <Button>Yes</Button>
    <Button>No</Button>
    <Button>Cancel</Button>
</StackPanel>
```

---

## 二、三种路由策略

| 策略              | 路径            | 典型应用                 | 命名约定                            |
| :---------------- | :-------------- | :----------------------- | :---------------------------------- |
| **冒泡 (Bubble)** | 源元素 → 根元素 | 大多数输入/状态事件      | 直接命名 (`Click`)                  |
| **隧道 (Tunnel)** | 根元素 → 源元素 | 输入事件的"预览"阶段     | `Preview` 前缀 (`PreviewMouseDown`) |
| **直接 (Direct)** | 仅源元素        | 类似 WinForms 的简单事件 | 无特殊前缀                          |

**隧道+冒泡配对**：WPF 输入事件通常成对出现（如 `PreviewMouseDown` + `MouseDown`），先隧道后冒泡

---

## 三、为什么需要路由事件？

1. **控件组合与封装**：允许在 `Button` 内放 `Image` 等复杂内容，点击事件仍能正确响应
2. **单一处理点**：父容器可统一处理所有子元素事件，无需为每个子元素注册
3. **类处理程序**：支持在静态构造函数中注册类级处理程序，优先于实例处理程序执行
4. **样式与模板支持**：`EventSetter` 和 `EventTrigger` 只能用于路由事件
5. **无反射引用**：通过 `RoutedEvent` 字段标识符，避免运行时反射

---

## 四、实现自定义路由事件

```csharp
// 1. 注册路由事件
public static readonly RoutedEvent TapEvent = EventManager.RegisterRoutedEvent(
    name: "Tap",
    routingStrategy: RoutingStrategy.Bubble,
    handlerType: typeof(RoutedEventHandler),
    ownerType: typeof(CustomButton)
);

// 2. CLR 事件包装器
public event RoutedEventHandler Tap
{
    add => AddHandler(TapEvent, value);
    remove => RemoveHandler(TapEvent, value);
}

// 3. 触发事件
protected virtual void OnTap()
{
    RaiseEvent(new RoutedEventArgs(TapEvent, this));
}
```

---

## 五、关键机制

### 1. Handled 机制

- `RoutedEventArgs.Handled = true` 会阻止事件路由继续传播
- 后续监听器默认不再调用处理程序
- **例外**：通过 `AddHandler(event, handler, handledEventsToo: true)` 可接收已标记为处理的事件

**建议**：完成事件处理后应设置 `Handled = true`，避免意外副作用

### 2. 类处理程序

**注册方式**：
```csharp
static CustomButton()
{
    EventManager.RegisterClassHandler(
        typeof(CustomButton), 
        TapEvent, 
        new RoutedEventHandler(OnTapClassHandler)
    );
}
```

**特点**：
- 在实例处理程序之前执行
- 可强制实施实例无法禁止的类行为
- 常用于控件内部拦截子元素事件

### 3. 附加事件

语法：`<owner type>.<event name>`  
示例：`StackPanel` 未实现 `Click`，但可通过 `Button.Click="Handler"` 附加处理

```xml
<StackPanel Button.Click="Button_Click">
    <Button>Click me</Button>
</StackPanel>
```

**本质**：附加事件也是路由事件，可在任意元素上引发

---

## 六、WPF 输入事件特性

**隧道+冒泡配对**事件处理顺序：
1. `PreviewMouseDown` 根元素（隧道）
2. `PreviewMouseDown` 中间元素（隧道）
3. `PreviewMouseDown` 源元素（隧道）
4. `MouseDown` 源元素（冒泡）
5. `MouseDown` 中间元素（冒泡）
6. `MouseDown` 根元素（冒泡）

**关键对象**：
- `Source`：最初引发事件的对象（始终不变）
- `sender`：调用处理程序的对象（随路由变化）

**最佳实践**：在 `Preview` 隧道阶段拦截子组件事件，替换为顶层控件事件

---

## 七、在样式中的应用

### EventSetter
```xml
<Style TargetType="Button">
    <EventSetter Event="Click" Handler="ApplyButtonStyle"/>
</Style>
```

### EventTrigger
```xml
<EventTrigger RoutedEvent="Mouse.MouseEnter">
    <BeginStoryboard>
        <Storyboard>
            <DoubleAnimation Storyboard.TargetProperty="Opacity" To="0.5"/>
        </Storyboard>
    </BeginStoryboard>
</EventTrigger>
```

**限制**：仅适用于路由事件

---

## 八、快速决策表

| 需求                         | 方案                                      |
| :--------------------------- | :---------------------------------------- |
| 需要事件在元素树传播         | 使用路由事件                              |
| 需要父容器统一处理子元素事件 | 使用冒泡策略                              |
| 需要拦截子元素事件           | 使用隧道策略（Preview）                   |
| 需要样式/动画响应事件        | 必须是路由事件                            |
| 需要类级强制行为             | 注册类处理程序                            |
| 需要接收已处理的事件         | `AddHandler(..., handledEventsToo: true)` |

---

## 总结

路由事件是 WPF 事件系统的核心，通过元素树传播机制、Handled 协议和类处理支持，实现了控件组合、事件聚合和灵活响应。掌握路由事件是深入理解 WPF 编程模型的关键。