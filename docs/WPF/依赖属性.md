# WPF 依赖属性（DependencyProperty）

**核心要点**：依赖属性是 WPF 的属性管理系统，存储在全局哈希表中而非对象字段里，为实现数据绑定、动画、样式等高级功能提供基础。

---

## 一、什么是依赖属性？

依赖属性（DP）是 WPF 特有的属性系统，值由 WPF 属性系统统一管理，可依赖多种外部输入（绑定、动画、样式等）动态计算得出。

**与标准属性的本质区别**：  
标准属性值存储在对象实例的私有字段中；依赖属性值存储在 `DependencyObject` 的高效哈希表里，支持多源求值。

---

## 二、为什么需要依赖属性？

1. **内存优化**：控件（如 Button）有上百个属性，依赖属性通过共享默认值、仅存储非默认值，极大减少内存占用
2. **功能基础**：支撑数据绑定、样式、模板、动画、属性继承、元数据重写等核心特性

---

## 三、如何创建依赖属性

三个步骤（必须在 `DependencyObject` 派生类中）：

```csharp
public class MyCustomControl : Control
{
    // 1. 声明和注册
    public static readonly DependencyProperty MyCustomPropertyProperty =
        DependencyProperty.Register(
            "MyCustomProperty",              // 属性名（必须与字段名一致，后缀"Property"）
            typeof(string),                  // 属性类型
            typeof(MyCustomControl),         // 所属类型
            new FrameworkPropertyMetadata(   // 元数据
                "DefaultValue",              // 默认值
                FrameworkPropertyMetadataOptions.AffectsRender, // 变化时重绘
                OnMyCustomPropertyChanged    // 变化回调（可选）
            ),
            ValidateMyCustomValue            // 验证回调（可选）
        );

    // 2. .NET属性包装器（方便代码使用，XAML不走这里）
    public string MyCustomProperty
    {
        get => (string)GetValue(MyCustomPropertyProperty);
        set => SetValue(MyCustomPropertyProperty, value);
    }

    // 3. 验证回调
    private static bool ValidateMyCustomValue(object value)
    {
        string str = value as string;
        return !string.IsNullOrEmpty(str) && str.Length <= 50;
    }

    // 变化回调
    private static void OnMyCustomPropertyChanged(
        DependencyObject d, 
        DependencyPropertyChangedEventArgs e)
    {
        var control = d as MyCustomControl;
        // 处理逻辑，e.OldValue/e.NewValue 包含旧值新值
    }
}
```

 **⚠️ 重要**  ：XAML 和绑定直接调用 `GetValue/SetValue`，包装器仅为代码使用提供便利。

---

## 四、核心特性

### 1. 属性值优先级（从高到低）

| 优先级 | 来源                                      |
| :----- | :---------------------------------------- |
| 1      | **本地值**（SetValue() 或 XAML 直接设置） |
| 2      | 样式触发器（Style Triggers）              |
| 3      | 模板触发器（Template Triggers）           |
| 4      | 样式 Setter（Style Setters）              |
| 5      | 主题样式 Setter（Theme Style Setters）    |
| 6      | **继承**（父元素传递的值）                |
| 7      | **默认值**（注册时指定）                  |

**注意**：数据绑定结果是表达式，求值后按来源进入相应优先级；`SetCurrentValue()` 设置的值不被视为"本地值"。

### 2. 属性值继承

子元素自动继承父元素的属性值（如 `FontSize`, `Foreground`）。

```xml
<StackPanel FontSize="20">
    <TextBlock Text="自动继承20pt" />  <!-- 无需重复设置 -->
</StackPanel>
```

**实现**：注册时设置 `FrameworkPropertyMetadataOptions.Inherits = true`。

### 3. 变化通知

元数据中指定 `PropertyChangedCallback`，属性值最终改变时自动触发。

### 4. 强制值（Coercion）

在 `PropertyChangedCallback` 中调用 `CoerceValue()`，将非法值强制到合法范围（如负数宽度强制为0）。

### 5. 验证（Validation）

`ValidateValueCallback` 在赋值前验证，失败则抛出异常阻止设置。

---

## 五、依赖属性 vs 标准属性

| 特性           | **依赖属性**                   | **标准属性**                        |
| :------------- | :----------------------------- | :---------------------------------- |
| **内存存储**   | 集中哈希表                     | 每个实例一个字段                    |
| **内存效率**   | **高**（只存非默认值）         | 低                                  |
| **数据绑定**   | **完全支持**                   | 仅支持 `OneWayToSource`             |
| **动画**       | **支持**                       | 不支持                              |
| **样式/模板**  | **支持**                       | 不支持                              |
| **变化通知**   | **内置高效**                   | 需手动实现 `INotifyPropertyChanged` |
| **创建复杂度** | 较高（需注册）                 | 简单（自动属性）                    |
| **性能**       | 获取设置稍慢，但系统整体性能优 | 获取设置快，但功能受限              |

---

## 六、何时使用

✅ **必须使用**  
- 创建自定义控件（Custom Control）需支持样式、模板、绑定时
- 需要属性值继承
- 需与动画、触发器交互

❌ **不应使用**  
- 普通数据模型类（ViewModel）→ 应使用 `INotifyPropertyChanged`
- 私有或内部简单属性

---

## 七、依赖属性如何支撑WPF核心功能

### 1. 数据绑定
- **机制**：绑定目标必须是依赖属性，绑定引擎通过 `SetValue()` 更新值
- **原理**：`BindingExpression` 监听源变化，调用 `SetValue()` 触发UI更新

### 2. 样式
- **机制**：`Style` 的 `Setter` 指定依赖属性，应用时调用 `SetValue()`
- **原理**：依赖属性系统按优先级管理样式值与本地值冲突

### 3. 模板
- **机制**：`ControlTemplate` 中的 `ContentPresenter` 通过 `TemplateBinding` 绑定宿主控件的依赖属性
- **原理**：属性变化通知自动更新模板内呈现

### 4. 动画
- **机制**：动画目标必须是依赖属性
- **原理**：动画值插入优先级体系，运行时覆盖本地值，通过定时器不断 `SetValue()` 驱动UI变化

### 5. 属性值继承
- **机制**：注册时设置 `Inherits = true`
- **原理**：属性系统在未找到本地值时，沿逻辑树向上遍历查找父元素值

### 6. 元数据重写
- **机制**：子类用 `OverrideMetadata()` 修改继承的依赖属性行为
- **用途**：更改默认值、注册新的 `PropertyChangedCallback`、添加 `CoerceValueCallback`

### 7. 验证、回调和强制
- **验证**：`ValidateValueCallback` 阻止非法值
- **回调**：`PropertyChangedCallback` 响应变化
- **强制**：`CoerceValueCallback` 在值确定前干预，实现属性间依赖（如 `Width` 不小于 `MinWidth`）

---

## 总结

依赖属性是 WPF 响应式、声明式UI的基石。其中心化存储与多源求值机制，实现了高效通知、灵活值管理和强大扩展性。

**关键要点**：
- 静态 `DependencyProperty` 实例 + `.NET包装器`
- 值由系统按优先级动态计算
- 是实现高级UI功能的必要条件

掌握依赖属性是深入理解 WPF 框架的关键一步。