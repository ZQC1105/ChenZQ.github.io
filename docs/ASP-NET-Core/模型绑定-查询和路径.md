
# [模型绑定](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/model-binding?view=aspnetcore-9.0)

## [FromQuery]
在 ASP.NET Core 中，模型绑定（Model Binding）是一个核心功能，它能自动将 HTTP 请求中的数据（如查询字符串、路由数据、表单字段、JSON 正文等）映射到控制器操作方法的参数或复杂对象的属性上。

[FromQuery] 和 [FromRoute] 是两个用于明确指定模型绑定来源的特性（Attributes），它们属于“源参数绑定器”（Source Parameter Binders）。使用它们可以精确控制参数从请求的哪个部分获取数据。

一、[FromQuery]
1. 作用
[FromQuery] 特性指示模型绑定器从 HTTP 请求的查询字符串（Query String） 中提取数据来绑定参数。
2. 语法

[FromQuery] T parameterName
3. 使用场景
适用于 GET 请求中传递筛选、分页、排序等参数。
4. 示例

假设有一个获取用户列表的 API，支持分页：

```csharp
[HttpGet("users")]
public IActionResult GetUsers([FromQuery] int page = 1, [FromQuery] int pageSize = 10)
{
// 处理逻辑
return Ok(new { Page = page, PageSize = pageSize });
}
当访问 URL：

GET /users?page=2&pageSize=20
page 参数会绑定为 2
pageSize 参数会绑定为 20

如果省略参数，则使用默认值（如 page=1, pageSize=10）。
```
5. 绑定复杂对象（较少见）
你也可以用 [FromQuery] 绑定一个包含多个属性的 POCO 类型：

```csharp
public class UserQueryParams
{
public int? Page { get; set; } = 1;
public int? PageSize { get; set; } = 10;
public string? SortBy { get; set; }
public bool Descending { get; set; }
}

[HttpGet("users")]
public IActionResult GetUsers([FromQuery] UserQueryParams queryParams)
{
// queryParams 自动从 query string 填充
return Ok(queryParams);
}

请求：

/users?page=3&pageSize=15&sortBy=name&descending=true

将正确填充 queryParams 对象。
⚠️ 注意：复杂对象从查询字符串绑定时，不支持嵌套对象或集合的深度绑定（如 filter[name]=john），需要自定义模型绑定器。
```
## [FromRoute]
1. 作用
[FromRoute] 特性指示模型绑定器从 路由模板中定义的路由数据（Route Data） 提取值来绑定参数。
2. 语法

[FromRoute] T parameterName
3. 使用场景
适用于 RESTful 风格的 URL，例如根据 ID 获取资源。
4. 示例

```csharp
[HttpGet("users/{id:int}")]
public IActionResult GetUserById([FromRoute] int id)
{
// 从路由中提取 id
return Ok(new { Id = id });
}
当访问：

GET /users/123
id 参数会被绑定为 123
5. 路由参数名称匹配
ASP.NET Core 默认通过 参数名匹配 来绑定路由数据。例如：

[HttpGet("orders/{orderId}/items/{itemId}")]
public IActionResult GetItem(
[FromRoute] int orderId,
[FromRoute] int itemId)
{
return Ok(new { OrderId = orderId, ItemId = itemId });
}

访问 /orders/5/items/10 将正确绑定 orderId=5, itemId=10。
✅ 提示：即使参数顺序不同，只要名字匹配路由占位符即可。
6. 显式指定路由键名（可选）
你可以显式指定从哪个路由键取值：


[FromRoute(Name = "id")] int userId

这在参数名与路由占位符不一致时很有用：


[HttpGet("{id}")]
public IActionResult GetUser([FromRoute(Name = "id")] int userId)
{
return Ok(new { UserId = userId });
}
```
## 对比总结

特性 [FromQuery] [FromRoute]
------ --------------- --------------
数据来源 查询字符串（URL 中 ? 后的部分） 路由模板中的占位符（如 {id}）
典型用途 分页、过滤、搜索参数 RESTful 资源定位（如 /users/123）
示例 URL /users?page=2&size=10 /users/123
是否必需 否（可设默认值） 通常必需（除非有默认值或可空类型）
支持复杂对象 有限支持（扁平结构） 不推荐用于复杂对象
## 最佳实践建议

1. 显式使用 [FromQuery] 和 [FromRoute] 提高可读性
即使框架能自动推断，显式标注能让代码意图更清晰。
csharp
// 推荐写法
public IActionResult Search([FromQuery] string q, [FromRoute] int tenantId)

2. 避免歧义
如果参数名同时出现在路由和查询字符串中，使用 [FromQuery] 或 [FromRoute] 可避免混淆。

3. 结合 [ApiController] 使用
在标记了 [ApiController] 的控制器中，对于复杂类型参数，默认从正文绑定（Body），简单类型默认从查询或路由绑定，因此明确标注更安全。

4. 验证输入
结合数据注解（如 [Required], [Range]）进行验证：
csharp
public IActionResult GetUsers([FromQuery][Range(1, 1000)] int page = 1)

## 常见问题

Q: 不加 [FromQuery] 或 [FromRoute] 会怎样？

A: ASP.NET Core 会尝试根据参数类型和位置自动推断来源：
简单类型（int, string, Guid 等）：尝试从路由、查询字符串、表单字段等按优先级绑定。
复杂类型：默认从 Body 绑定（尤其是 [ApiController] 下）。

但自动推断可能导致意外行为，推荐显式指定来源以增强可维护性和可预测性。

总结
[FromQuery]：从 URL 查询字符串绑定数据，适合传递非关键性的筛选参数。
[FromRoute]：从 URL 路径的路由段中绑定数据，适合标识资源的唯一路径。

两者都是控制模型绑定行为的重要工具，在构建清晰、可维护的 Web API 时应合理使用。
