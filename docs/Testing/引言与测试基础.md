# 引言与测试基础

## 为什么需要测试数据访问层？

数据是现代应用的核心。Entity Framework Core（EF Core）作为 .NET 主流的对象关系映射（ORM）框架，负责处理实体映射、查询翻译、事务管理等复杂任务，也因此成为最易出错且最难调试的环节之一。

未经充分测试的数据访问层可能导致：
- **数据不一致**：并发处理不当或业务逻辑错误引发数据损坏
- **性能瓶颈**：低效的 LINQ 查询被翻译成性能糟糕的 SQL
- **隐蔽 Bug**：空值处理、外键约束等边界问题仅在特定场景暴露
- **重构恐惧**：缺乏测试保护，开发者不敢修改现有代码

有效的测试策略能帮助我们：

1. **验证正确性**：确保 CRUD 操作、复杂查询与业务规则按预期执行
2. **提升可维护性**：清晰的测试用例即文档，支持安全重构
3. **加速反馈循环**：本地快速运行，无需部署即可发现问题
4. **增强发布信心**：自动化测试套件提供可靠的质量保障

---

## 1.2 单元测试 vs. 集成测试

理解二者的区别是设计有效测试策略的基础。

### 单元测试

**定义**：针对软件最小可测试单元（通常是方法或类）的测试，核心思想是**隔离**。

**目标**：验证单个组件的内部逻辑，**不依赖外部系统**（如数据库、网络）。

**特点**：
- ⚡ **速度快**：毫秒级完成
- 🎛️ **可控性强**：通过 Mock/Stub 精确模拟依赖行为
- 📊 **覆盖率高**：易于覆盖分支路径与异常情况
- 🔌 **依赖注入**：要求代码具备良好的 DI 设计，便于替换依赖

**在 EF Core 中的应用**：测试使用 `DbContext` 的服务类时，用模拟的 `DbContext` 替代真实数据库连接，验证是否调用了正确的 `Add`、`Update`、`SaveChanges` 等方法，**不实际执行 SQL**。

---

### 集成测试

**定义**：测试**多个组件协同工作**，特别是与**外部系统**（如数据库）的交互。

**目标**：验证组件间接口及与真实外部资源的集成。

**特点**：
- 🐌 **速度较慢**：涉及 I/O 操作，执行时间为百毫秒至秒级
- 🎯 **真实性高**：使用真实或内存数据库，执行实际 SQL 与事务
- 🐛 **发现集成问题**：捕捉单元测试无法发现的问题：
  - LINQ 是否能正确翻译为有效 SQL？
  - 数据库约束（主键、外键、唯一索引）是否生效？
  - 事务提交与回滚是否符合预期？
  - 是否存在性能陷阱（如 N+1 查询）？
- 🗃️ **状态管理**：需仔细管理测试数据，确保独立性与可重复性

---

### 核心区别对比

| 维度         | 单元测试           | 集成测试                     |
| :----------- | :----------------- | :--------------------------- |
| **测试范围** | 单个方法/类        | 多组件 + 外部系统            |
| **执行速度** | 毫秒级             | 百毫秒至秒级                 |
| **依赖处理** | Mock/Stub 隔离     | 真实依赖（如内存数据库）     |
| **覆盖重点** | 内部逻辑、边界条件 | 组件协作、持久化、SQL 行为   |
| **可维护性** | 高（强隔离）       | 中（需管理测试数据）         |
| **问题类型** | 逻辑错误           | 集成错误、配置错误、性能瓶颈 |

---

## 最佳实践建议

- **以单元测试为主**：覆盖核心业务逻辑，实现快速反馈与高覆盖率
- **辅以集成测试**：覆盖关键数据路径、复杂查询与事务行为
- **遵循测试金字塔**：
  - **底层**：大量快速的单元测试（约 70%）
  - **中层**：适量的集成测试（约 20%）
  - **顶层**：少量端到端/UI 测试（约 10%，视项目而定）

> ✅ **测试比例并非绝对**，应根据项目特点灵活调整，但原则不变——越接近代码的测试越快速、越频繁。