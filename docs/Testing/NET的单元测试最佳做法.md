## [.NET 的单元测试最佳做法](https://learn.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-best-practices)

一、单元测试的优点
1. 节省时间：相比耗时的功能测试，单元测试可毫秒级自动运行。
2. 防止回归：代码变更后能快速验证现有功能是否被破坏。
3. 可执行文档：清晰的测试用例能说明代码在不同输入下的预期行为。
4. 促进解耦：难以测试的代码通常意味着耦合度过高，写测试会自然推动代码解耦。
二、良好单元测试的特征 (FIRST 原则)
快速 (Fast)：测试应快速执行。
独立 (Independent)：测试应能独立运行，不依赖外部环境（如数据库、文件系统）。
可重复 (Repeatable)：在相同条件下，测试结果应始终一致。
自我验证 (Self-Validating)：测试应自动判断通过或失败，无需人工检查。
适时 (Timely)：编写测试不应耗费过多不必要的时间。
三、关键概念辨析
Fake (伪对象)：存根（Stub）和模拟（Mock）的统称。
Stub (存根)：为测试提供可控的依赖项替代品，用于“安排”（Arrange）阶段，不用于断言。
Mock (模拟)：一种特殊的伪对象，其交互（如方法是否被调用）是测试断言（Assert）的一部分。
关键区别：如果在 Assert 阶段检查了该对象的状态或行为，它就是 Mock；否则，它就是 Stub。正确使用术语能避免团队误解。
四、核心最佳做法

1. 遵循命名规范
测试名称应清晰表达三要素：被测方法、测试场景、预期结果。
例如：Add_EmptyString_ReturnsZero 比 Test_Single 更具描述性。

2. 使用“排列-操作-断言” (Arrange-Act-Assert) 模式
Arrange (安排)：创建并配置对象和依赖项。
Act (操作)：调用被测方法。
Assert (断言)：验证结果是否符合预期。
此模式提升测试的可读性和结构清晰度。

3. 编写最简通过测试
使用最简单、最小的数据来验证行为。例如，测试单个数字相加，用 "0" 比用 "42" 更能体现“最简”原则，减少不必要的复杂性。

4. 避免“魔法字符串” (Magic Strings)
避免在测试中直接硬编码意义不明的值。应将其定义为有明确含义的常量。
例如：将 "1001" 定义为 const string MAXIMUM_RESULT = "1001";。

5. 避免在测试中编写逻辑
测试代码中应尽量避免 if, for, while 等逻辑控制语句，以防止测试本身出现 Bug。
如果需要测试多种情况，应使用参数化测试（如 xUnit 的 [Theory] 和 [InlineData]），而不是在单个测试中用循环。

6. 使用帮助程序方法，而非 Setup/Teardown
优先使用自定义的帮助方法来创建测试对象，而不是依赖测试框架的全局 Setup 方法。这能提高测试的可读性，避免不必要的共享状态和过度/不足的初始化。

7. 避免单个测试包含多个 Act 操作
一个测试应只关注一个行为。如果一个测试中有多个 Act，应将其拆分为多个独立测试或使用参数化测试。这能确保测试失败时能精确定位问题。

8. 通过公共方法测试私有方法
通常不需要为 private 方法编写直接的单元测试。应通过测试调用它的公共方法来间接验证其行为，因为私有方法的实现细节可能变化，而公共方法的行为才是最终的契约。

9. 使用“接缝” (Seams) 处理静态依赖
当代码依赖静态调用（如 DateTime.Now）时，难以进行控制和测试。解决方案是引入“接缝”，即通过依赖注入将静态调用封装在接口中，然后在测试时用 Stub/Mock 替换，从而完全控制其返回值。

总结
该文档强调，优秀的单元测试不仅是验证代码正确性的工具，更是高质量的、可维护的活文档。关键在于写出可读性强、独立、稳定且专注的测试。遵循上述最佳实践，可以构建一个可靠的测试套件，从而增强代码质量、提升开发效率并有效防止回归。
