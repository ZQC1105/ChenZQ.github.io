1. 首选 StringComparison 枚举

这是最重要、最核心的实践。在调用任何涉及字符串比较的方法时（如 string.Equals, string.Compare, string.StartsWith, string.Contains, string.IndexOf 等），应使用接受 StringComparison 枚举作为参数的重载。

为什么？
避免歧义：默认的字符串比较行为（通常是区分大小写的序号比较）可能不符合你的业务逻辑。
提高性能：某些比较类型（如 Ordinal）比文化感知比较更快。
增强可读性：代码明确表达了你的意图。
防止错误：尤其是在处理用户输入或跨区域环境时，不正确的比较可能导致安全漏洞或逻辑错误。

常用 StringComparison 成员：

枚举值 含义 推荐场景
:--- :--- :---
Ordinal 区分大小写的序号比较（基于字符的 Unicode 码点）。 首选！ 用于技术性比较，如文件名、URL、GUID、XML 标签、哈希值、字典键等。性能最高。
OrdinalIgnoreCase 不区分大小写的序号比较。 当需要忽略大小写进行技术性比较时（如比较 HTTP 头名称 "Content-Type" 和 "content-type"）。性能高。
CurrentCulture 基于当前线程的文化设置进行区分大小写的语言学比较。 当需要根据用户的本地化规则对用户可见的字符串进行排序或显示时。
CurrentCultureIgnoreCase 基于当前线程的文化设置进行不区分大小写的语言学比较。 同上，但忽略大小写。
InvariantCulture 基于固定不变的文化（invariant culture）进行区分大小写的语言学比较。 当需要一种与区域无关、稳定一致的比较结果时（例如，在持久化数据或网络协议中）。
InvariantCultureIgnoreCase 基于固定不变的文化进行不区分大小写的语言学比较。 同上，但忽略大小写。 2. 默认选择：Ordinal 或 OrdinalIgnoreCase

微软强烈建议：
对于大多数编程场景，尤其是那些不面向最终用户的、基于技术标识符的比较，请使用 Ordinal 或 OrdinalIgnoreCase。

原因：
性能：序号比较是最快的，因为它直接比较字符的二进制值。
稳定性：结果不会因用户的区域设置而改变。
安全性：避免了因文化差异导致的意外行为。

示例：
```csharp
// ✅ 推荐：使用 StringComparison 明确指定
bool isEqual = string.Equals(str1, str2, StringComparison.Ordinal);
bool startsWith = fileName.StartsWith("log\_", StringComparison.OrdinalIgnoreCase);
int index = text.IndexOf("ERROR", StringComparison.OrdinalIgnoreCase);

// ❌ 不推荐：依赖默认行为（通常是 Ordinal，但不明确）
bool isEqual = str1 == str2;
bool startsWith = fileName.StartsWith("log\_"); // 可能不是你想要的！
```

3. 文化感知比较 (CurrentCulture) 的适用场景

仅在以下情况使用 CurrentCulture 或 CurrentCultureIgnoreCase：
比较或排序面向最终用户的文本。
结果将显示给用户，并且需要符合用户的语言习惯。
例如：联系人列表按姓名排序、文档标题搜索等。

```csharp
// 示例：对用户姓名进行排序
Array.Sort(names, StringComparer.CurrentCulture); 
```

4. 避免使用不带 StringComparison 参数的重载

许多字符串方法有多个重载。应优先选择接受 StringComparison 参数的那个。

```csharp
// ❌ 避免
if (input.ToLower() == "yes") { ... } // ToLower 分配内存，且行为不明确

// ✅ 推荐
if (string.Equals(input, "yes", StringComparison.OrdinalIgnoreCase)) { ... }

// ❌ 避免
if (path.EndsWith(".txt")) { ... }

// ✅ 推荐
if (path.EndsWith(".txt", StringComparison.OrdinalIgnoreCase)) { ... } 
```

5. 使用 StringComparer 类进行集合操作

当创建基于字符串的集合（如 Dictionary<string, T> 或 HashSet<string>）时，使用 StringComparer 来指定比较方式。
```csharp
// 创建一个不区分大小写的字典
var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
{
{ "Key1", "Value1" },
{ "KEY2", "Value2" }
};

// 这样可以通过 "key1" 或 "KEY1" 来访问
Console.WriteLine(dict["key1"]); // 输出 "Value1" 6. 注意 == 操作符的行为
```
string 类型重载了 == 操作符，它执行的是区分大小写的序号比较（相当于 StringComparison.Ordinal）。

可以安全使用 == 进行简单的、区分大小写的相等判断。
但如果有忽略大小写的需求，必须使用 Equals 方法并指定 StringComparison.OrdinalIgnoreCase。

```csharp
string a = "Hello";
string b = "HELLO";

Console.WriteLine(a == b); // False (Ordinal)
Console.WriteLine(string.Equals(a, b, StringComparison.OrdinalIgnoreCase)); // True 7. 跨平台一致性考虑
```
在 .NET Framework 和 .NET Core/.NET 5+ 之间，或在不同操作系统上，文化感知比较的结果可能略有差异。如果需要绝对一致的结果，优先使用 Ordinal、OrdinalIgnoreCase 或 InvariantCulture。

总结：微软推荐的检查清单

1. 明确指定：在所有字符串比较操作中，使用 StringComparison 枚举。
2. 默认序号：除非有特定的语言学需求，否则优先选择 StringComparison.Ordinal 或 StringComparison.OrdinalIgnoreCase。
3. 用户界面用文化：仅在向用户显示排序或比较结果时，使用 CurrentCulture。
4. 集合用 StringComparer：为字符串集合指定合适的比较器。
5. 避免旧式方法：不要依赖 ToLower()/ToUpper() 进行比较，这既低效又可能出错。

遵循这些实践，可以确保你的字符串比较代码是高效、正确、安全且可维护的。
