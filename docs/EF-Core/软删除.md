### 软删除标记做成阴影属性的完整流程

#### 1. 数据库表结构（SQL Server 示例）
```sql
CREATE TABLE Blogs (
    BlogId    INT IDENTITY PRIMARY KEY,
    Url       NVARCHAR(200) NOT NULL,
    -- 没有显式定义 IsDeleted，它只存在于 EF 模型里
);
```

#### 2. 实体类（完全不知道“软删除”这件事）
```csharp
public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }
    // 不包含 IsDeleted、DeletedAt 等任何软删除字段
}
```

#### 3. 在 `OnModelCreating` 里把 `IsDeleted` 声明为阴影属性，并加上全局过滤
```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Blog>()
        .Property<bool>("IsDeleted")            // 阴影属性：数据库列存在，但实体类看不到
        .HasDefaultValue(false);

    modelBuilder.Entity<Blog>()
        .HasQueryFilter(b => !EF.Property<bool>(b, "IsDeleted"));  // 全局过滤：默认查询只返回未删除的记录
}
```

#### 4. 正常业务查询（自动忽略已删除数据）
```csharp
// 生成的 SQL 会自动加上 WHERE [IsDeleted] = 0
var activeBlogs = context.Blogs.ToList();
```

#### 5. 需要查看“已删除”数据时，显式关闭过滤器
```csharp
// 生成的 SQL 不再带 WHERE [IsDeleted] = 0，能查出所有记录
var allBlogs = context.Blogs.IgnoreQueryFilters().ToList();
```

#### 6. 执行“软删除”操作
```csharp
var blog = context.Blogs.Find(1);
context.Entry(blog).Property("IsDeleted").CurrentValue = true;
context.SaveChanges();
// 数据库里该行的 IsDeleted 被设为 1，但记录仍在；下次普通查询就查不到它了
```

#### 7. 恢复已删除数据
```csharp
var blog = context.Blogs.IgnoreQueryFilters().First(b => b.BlogId == 1);
context.Entry(blog).Property("IsDeleted").CurrentValue = false;
context.SaveChanges();
```

一句话总结  
把 `IsDeleted` 放进阴影属性后，实体类完全不感知软删除逻辑；EF Core 通过全局过滤器自动屏蔽已删除数据，业务代码只需在需要时用 `.IgnoreQueryFilters()` 打开“查看全部”的开关即可。

把 `IsDeleted` 放在阴影属性里确实能实现“实体类不感知”，但它只是软删除的一种**实现技巧**，并不是“最佳实践”的全部。  

真正的“最佳实践”还要考虑：  
- **级联软删除**：父实体被软删除后，子实体是否也要自动标记为已删除？  
- **性能**：软删除后数据量持续增长，查询会变慢，需要定期归档或清理。  
- **恢复机制**：如何把误删的数据一键恢复？有没有“回收站”界面？  
- **硬删除策略**：某些场景（如合规要求）仍需物理删除，不能只靠软删除。  

一句话总结：阴影属性 + 全局过滤器是实现软删除的**一种手段**，但“最佳实践”需要结合业务场景、性能、合规等多方面权衡，不能只靠这一招。

级联软删除 = “删父带子”  
核心思路：父实体被打上删除标记后，所有子实体也自动被标记为已删除，且后续恢复时能一起还原。  

### 1. 数据库准备  
- 父表、子表都加 `IsDeleted BIT DEFAULT 0`（或 `DeletedAt DATETIME2`）。  
- 外键保持 `NOT NULL`，确保关系完整。  

### 2. EF Core 模型  
- 父、子实体类都不写 `IsDeleted` 属性。  
- 在 `OnModelCreating` 里把 `IsDeleted` 声明为阴影属性，并给父、子表都加上全局过滤器：  
  ```csharp
  modelBuilder.Entity<Parent>()
      .Property<bool>("IsDeleted")
      .HasDefaultValue(false);
  modelBuilder.Entity<Parent>()
      .HasQueryFilter(p => !EF.Property<bool>(p, "IsDeleted"));
  
  // 子表同理
  ```

### 3. 级联软删除逻辑  
- 删除父实体时，手动把所有子实体的 `IsDeleted` 也设为 `true`：  
  ```csharp
  var parent = context.Parents.Find(id);
  context.Entry(parent).Property("IsDeleted").CurrentValue = true;
  
  var children = context.Children.Where(c => c.ParentId == id);
  foreach (var child in children)
      context.Entry(child).Property("IsDeleted").CurrentValue = true;
  
  context.SaveChanges();
  ```
- 恢复时同理：先把父实体的 `IsDeleted` 设回 `false`，再把子实体全部恢复。  

### 4. 优化：自动级联  
- 重写 `SaveChanges`，当发现父实体被软删除时，自动把所有关联子实体也标记为已删除。  
- 或者用 EF Core 的 `DeleteBehavior.Cascade` 配合软删除标记，但需注意：  
  - 数据库层面不要启用 `ON DELETE CASCADE`，否则会物理删除子表，破坏软删除语义。  

一句话总结：级联软删除 = 父子表都用阴影属性 + 全局过滤器，删除时手动或自动把所有子实体的 `IsDeleted` 一起设为 `true`，恢复时再一起还原。