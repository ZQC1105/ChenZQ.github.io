
  ##  备用密钥


你提供的这个例子非常经典，它展示了一个 非主键字段之间的实体关联。我们来结合代码详细讲解：

```csharp
modelBuilder.Entity<Post>()
.HasOne(p => p.Blog)
.WithMany(b => b.Posts)
.HasForeignKey(p => p.BlogUrl)
.HasPrincipalKey(b => b.Url);
```
✅ 先回答你的核心问题：
.HasForeignKey(p => p.BlogUrl) 和 .HasPrincipalKey(b => b.Url) 必须一起使用吗？
🔥 是的，在这种情况下必须一起使用！

原因如下：

方法 作用

---

.HasForeignKey(...) 指定“外键字段” —— 哪个字段存储了引用值（这里是 Post.BlogUrl）
.HasPrincipalKey(...) 指定“被引用的键” —— 引用的是主表中的哪个唯一字段（这里是 Blog.Url）

👉 因为：
外键 BlogUrl 不是指向主键 BlogId
而是指向另一个字段 Url

所以 EF Core 无法自动推断关系目标，你必须明确告诉它：“我引用的是 Blog.Url 字段”，这就需要 .HasPrincipalKey()。

如果不写 .HasPrincipalKey(b => b.Url)，EF 默认会尝试引用主键 BlogId，就会出错或生成错误的关系。

🧩 一、整体关系图解

text
Post 表
┌─────────┬───────────┬──────────┬────────────┐
│ PostId │ Title │ Content │ BlogUrl │ ← 外键字段
└─────────┴───────────┴──────────┴────────────┘
│
↓ 引用
Blog 表
┌─────────┬──────────────┐
│ BlogId │ Url │ ← 被引用字段（不是主键！）
└─────────┴──────────────┘

📌 关系含义：
“每篇博客文章（Post）属于一个博客（Blog），通过博客的 URL 关联”

例如：
Post.BlogUrl = "https://example.com" → 对应 → Blog.Url = "https://example.com"

🔍 二、逐行解释配置

csharp
modelBuilder.Entity<Post>()
.HasOne(p => p.Blog) // 一个 Post 属于一个 Blog
.WithMany(b => b.Posts) // 一个 Blog 有多个 Posts
.HasForeignKey(p => p.BlogUrl) // 外键是 Post.BlogUrl
.HasPrincipalKey(b => b.Url); // 引用的是 Blog.Url（不是主键）

1. .HasOne(p => p.Blog)
   表示：Post 导航到一个 Blog 对象。
   定义关系的一端：从 Post 到 Blog。
2. .WithMany(b => b.Posts)
   表示：每个 Blog 可以有多个 Post。
   定义另一端：从 Blog 到 Posts 的集合。

✅ 合起来就是：一对多关系（1 对多）

3. .HasForeignKey(p => p.BlogUrl)
   明确指出：用来建立关系的“外键字段”是 Post 类的 BlogUrl 属性。
   数据库存储的是对方 Blog 的某个唯一标识（这里是 Url）。

🔧 作用：
在数据库中创建外键约束：
sql
FOREIGN KEY (BlogUrl) REFERENCES Blogs(Url)

4. .HasPrincipalKey(b => b.Url)
   关键点来了：告诉 EF Core，“我引用的不是主键 BlogId，而是 Url 字段”
   所以 Blog.Url 必须能唯一标识一条记录 → 必须设置为备用密钥（Alternate Key）

⚠️ 如果你不先让 Url 成为备用密钥，这段代码会运行时报错！

⚠️ 三、你漏掉了一步：必须配置备用密钥！

你现在只写了关系映射，但 没有告诉 EF Core Blog.Url 是唯一标识符。
❌ 当前代码会失败！

你需要补充这一句：

csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
// 👉 新增：把 Url 设为备用密钥（唯一 + 可被外键引用）
modelBuilder.Entity<Blog>()
.HasAlternateKey(b => b.Url);

// 原来的关系配置
modelBuilder.Entity<Post>()
.HasOne(p => p.Blog)
.WithMany(b => b.Posts)
.HasForeignKey(p => p.BlogUrl)
.HasPrincipalKey(b => b.Url);
}

否则你会遇到错误：
The referenced entity key 'Blog { Url }' does not contain all of the key properties. Either add the missing properties or specify an alternate name using 'HasForeignKey'.

或者更常见的：
The properties {'Url'} on entity type 'Blog' are not configured as a primary or alternate key. They should be configured as a primary or alternate key to be used in a foreign key.

🧱 数据库最终生成什么？

加上 .HasAlternateKey(b => b.Url) 后，生成的 SQL 类似：

sql
-- Blog 表
CREATE TABLE Blogs (
BlogId int PRIMARY KEY,
Url nvarchar(max) NOT NULL
);

-- 创建唯一约束：Url 必须唯一（因为是备用密钥）
ALTER TABLE Blogs ADD CONSTRAINT AK_Blogs_Url UNIQUE (Url);

-- Post 表
CREATE TABLE Posts (
PostId int PRIMARY KEY,
Title nvarchar(max),
Content nvarchar(max),
BlogUrl nvarchar(max) NOT NULL -- 外键字段
);

-- 创建外键：指向 Blogs.Url（不是主键！）
ALTER TABLE Posts
ADD CONSTRAINT FK_Posts_Blogs_BlogUrl
FOREIGN KEY (BlogUrl) REFERENCES Blogs(Url);

✅ 正确完整的代码

```csharp
internal class MyContext : DbContext
{
public DbSet<Blog> Blogs { get; set; }
public DbSet<Post> Posts { get; set; }

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
// ✅ 第一步：设置备用密钥
modelBuilder.Entity<Blog>()
.HasAlternateKey(b => b.Url);

// ✅ 第二步：配置关系
modelBuilder.Entity<Post>()
.HasOne(p => p.Blog)
.WithMany(b => b.Posts)
.HasForeignKey(p => p.BlogUrl)
.HasPrincipalKey(b => b.Url);
}
}

public class Blog
{
public int BlogId { get; set; }
public string Url { get; set; }
public List<Post> Posts { get; set; }
}

public class Post
{
public int PostId { get; set; }
public string Title { get; set; }
public string Content { get; set; }
public string BlogUrl { get; set; }
public Blog Blog { get; set; }
}
```
📌 总结

问题 回答

---

.HasForeignKey 和 .HasPrincipalKey 必须一起用吗？ ✅ 是的！ 当外键不指向主键时，必须同时指定“谁是外键”和“引用谁”
为什么需要 .HasPrincipalKey？ 因为默认引用主键，现在你要引用非主键字段（如 Url），必须明确指定
HasPrincipalKey 指向的字段有什么要求？ 必须是 主键 或 备用密钥（即唯一标识）
我的代码有问题吗？ ❌ 有！缺了 .HasAlternateKey(b => b.Url)，必须补上

💡 最佳实践建议：
尽量用主键做外键关联（最简单安全）。
只有在特殊业务场景下（如第三方系统用 URL 标识资源），才用非主键字段关联，并记得配置 备用密钥！

如果你还有类似 Username、SSN、Code 等字段做关联的需求，这套模式完全适用。
