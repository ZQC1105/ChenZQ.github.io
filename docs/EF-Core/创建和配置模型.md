---
title: "创建和配置模型"
excerpt_separator: "<!--more-->"
categories:
  - EF Core
tags:
  - System.ComponentModel.DataAnnotations
  - Microsoft.EntityFrameworkCore.Metadata.Builders
---

## [创建和配置模型](https://learn.microsoft.com/zh-cn/ef/core/modeling/)

在 EF Core 中，数据注释（Data Annotations） 和 Fluent API 在很多功能上确实可以相互替代，它们都用于对模型进行配置，以覆盖默认的约定。然而，两者在使用方式、灵活性和功能范围上存在一些关键区别。
相同点：可替代性

对于许多常见的配置需求，你既可以用数据注释，也可以用 Fluent API 来实现。例如：

### 配置目标 数据注释示例 Fluent API 示例

```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using Microsoft.EntityFrameworkCore;

// 实体类定义
public class Blog
{
    // 主键
    [Key]
    public int Id { get; set; }

    // 必填字段，最大长度 200
    [Required]
    [MaxLength(200)]
    public string Url { get; set; }

    // 导航属性：一对多关系中的“一”端
    public ICollection<Post> Posts { get; set; }
}

public class Post
{
    [Key]
    public int Id { get; set; }

    // 外键属性
    [ForeignKey("BlogId")]
    public int BlogId { get; set; }

    // 导航属性：一对多关系中的“多”端
    public Blog Blog { get; set; }
}

// DbContext 配置
public class BloggingContext : DbContext
{
    public DbSet<Blog> Blogs { get; set; }
    public DbSet<Post> Posts { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // 表名映射
        modelBuilder.Entity<Blog>().ToTable("Blogs");

        // 主键配置
        modelBuilder.Entity<Blog>().HasKey(b => b.Id);
        modelBuilder.Entity<Post>().HasKey(p => p.Id);

        // 字符串长度/最大长度
        modelBuilder.Entity<Blog>().Property(b => b.Url).HasMaxLength(200);

        // 必填字段
        modelBuilder.Entity<Blog>().Property(b => b.Url).IsRequired();

        // 关系配置（一对多）
        modelBuilder.Entity<Post>()
            .HasOne(p => p.Blog)           // Post 有一个 Blog
            .WithMany(b => b.Posts)        // Blog 有多个 Posts
            .HasForeignKey(p => p.BlogId); // 外键是 Post.BlogId
    }
}
```

说明：
[Key]：指定主键。
[Required]：表示该字段不能为空（对应数据库中的 NOT NULL）。
[MaxLength] / [StringLength]：限制字符串最大长度。
[Table("Blogs")]：将 Blog 实体映射到名为 "Blogs" 的数据库表。
[ForeignKey("BlogId")]：显式指定外键属性。
Fluent API：在 OnModelCreating 中使用 modelBuilder 进行更灵活的配置，优先级高于数据注解。

不同点：优势与限制
尽管功能有重叠，但两者在实际使用中各有优劣：
✅ 数据注释（Data Annotations）  
优点：
简洁直观，直接写在实体类上，便于快速查看。
适合简单的、与业务逻辑紧密相关的验证规则（如 [Required], [EmailAddress]）。
缺点：
将 EF Core 的依赖引入了实体类，违反了“关注点分离”原则。
功能有限，无法完成一些高级或复杂配置。
不支持所有 Fluent API 的功能。
⚠️ 注意：某些属性（如 [Column(Order = ...)]）在 EF Core 中已被移除或不支持顺序定义。
✅ Fluent API
优点：
更强大、更灵活，支持几乎所有模型配置选项。
可以配置数据注释无法完成的内容，例如：
复合主键
索引创建（.HasIndex()）
值转换器（Value Converters）
查询过滤器（Query Filters）
复杂的关系导航配置
属性映射到 JSON 列等
保持实体类“纯净”，不依赖 EF Core 命名空间。
集中管理，在 OnModelCreating 中统一配置，便于维护。
缺点：
写法相对繁琐，代码量较多。
需要跳转到 DbContext 类才能查看完整配置。

推荐实践

大多数现代 EF Core 开发中推荐：
✅ 优先使用 Fluent API 进行模型配置，尤其是在大型项目或需要精细控制时。
🟡 数据注释可用于轻量级项目或结合 ASP.NET Core MVC 验证（如 [Required] 同时用于 UI 验证和数据库约束）。
🔁 混合使用也是常见做法：用数据注释处理简单验证，Fluent API 处理复杂映射。

总结

是的，数据注释和 Fluent API 在部分功能上可以相互替代，比如设置主键、长度、必填等。
但 Fluent API 更强大、更灵活，能做数据注释做不到的事，因此在需要高级配置或追求代码清晰结构时，应优先选用 Fluent API。
